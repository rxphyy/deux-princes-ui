{"ast":null,"code":"\"use strict\";\n\nvar _objectWithoutProperties = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\").default;\nvar _objectDestructuringEmpty = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/objectDestructuringEmpty.js\").default;\nvar _regeneratorRuntime = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _objectSpread = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _excluded = [\"encryptedFields\"];\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClientEncryption = void 0;\nvar bson_1 = require(\"../bson\");\nvar deps_1 = require(\"../deps\");\nvar utils_1 = require(\"../utils\");\nvar cryptoCallbacks = require(\"./crypto_callbacks\");\nvar errors_1 = require(\"./errors\");\nvar index_1 = require(\"./providers/index\");\nvar state_machine_1 = require(\"./state_machine\");\n/**\n * @public\n * The public interface for explicit in-use encryption\n */\nvar ClientEncryption = /*#__PURE__*/function () {\n  /**\n   * Create a new encryption instance\n   *\n   * @example\n   * ```ts\n   * new ClientEncryption(mongoClient, {\n   *   keyVaultNamespace: 'client.encryption',\n   *   kmsProviders: {\n   *     local: {\n   *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```ts\n   * new ClientEncryption(mongoClient, {\n   *   keyVaultNamespace: 'client.encryption',\n   *   kmsProviders: {\n   *     aws: {\n   *       accessKeyId: AWS_ACCESS_KEY,\n   *       secretAccessKey: AWS_SECRET_KEY\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  function ClientEncryption(client, options) {\n    var _options$proxyOptions, _options$tlsOptions;\n    _classCallCheck(this, ClientEncryption);\n    this._client = client;\n    this._proxyOptions = (_options$proxyOptions = options.proxyOptions) !== null && _options$proxyOptions !== void 0 ? _options$proxyOptions : {};\n    this._tlsOptions = (_options$tlsOptions = options.tlsOptions) !== null && _options$tlsOptions !== void 0 ? _options$tlsOptions : {};\n    this._kmsProviders = options.kmsProviders || {};\n    if (options.keyVaultNamespace == null) {\n      throw new errors_1.MongoCryptInvalidArgumentError('Missing required option `keyVaultNamespace`');\n    }\n    var mongoCryptOptions = _objectSpread(_objectSpread({}, options), {}, {\n      cryptoCallbacks: cryptoCallbacks,\n      kmsProviders: !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders\n    });\n    this._keyVaultNamespace = options.keyVaultNamespace;\n    this._keyVaultClient = options.keyVaultClient || client;\n    var MongoCrypt = ClientEncryption.getMongoCrypt();\n    this._mongoCrypt = new MongoCrypt(mongoCryptOptions);\n  }\n  /**\n   * Creates a data key used for explicit encryption and inserts it into the key vault namespace\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create a local key\n   * const dataKeyId = await clientEncryption.createDataKey('local');\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create an aws key\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\n   *   masterKey: {\n   *     region: 'us-east-1',\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create an aws key with a keyAltName\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\n   *   masterKey: {\n   *     region: 'us-east-1',\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n   *   },\n   *   keyAltNames: [ 'mySpecialKey' ]\n   * });\n   * ```\n   */\n  _createClass(ClientEncryption, [{\n    key: \"createDataKey\",\n    value: function () {\n      var _createDataKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(provider) {\n        var options,\n          keyAltNames,\n          keyMaterial,\n          dataKeyBson,\n          context,\n          stateMachine,\n          dataKey,\n          _utils_1$MongoDBColle,\n          dbName,\n          collectionName,\n          _yield$this$_keyVault,\n          insertedId,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n              if (!(options.keyAltNames && !Array.isArray(options.keyAltNames))) {\n                _context.next = 3;\n                break;\n              }\n              throw new errors_1.MongoCryptInvalidArgumentError(\"Option \\\"keyAltNames\\\" must be an array of strings, but was of type \".concat(typeof options.keyAltNames, \".\"));\n            case 3:\n              keyAltNames = undefined;\n              if (options.keyAltNames && options.keyAltNames.length > 0) {\n                keyAltNames = options.keyAltNames.map(function (keyAltName, i) {\n                  if (typeof keyAltName !== 'string') {\n                    throw new errors_1.MongoCryptInvalidArgumentError(\"Option \\\"keyAltNames\\\" must be an array of strings, but item at index \".concat(i, \" was of type \").concat(typeof keyAltName));\n                  }\n                  return (0, bson_1.serialize)({\n                    keyAltName: keyAltName\n                  });\n                });\n              }\n              keyMaterial = undefined;\n              if (options.keyMaterial) {\n                keyMaterial = (0, bson_1.serialize)({\n                  keyMaterial: options.keyMaterial\n                });\n              }\n              dataKeyBson = (0, bson_1.serialize)(_objectSpread({\n                provider: provider\n              }, options.masterKey));\n              context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {\n                keyAltNames: keyAltNames,\n                keyMaterial: keyMaterial\n              });\n              stateMachine = new state_machine_1.StateMachine({\n                proxyOptions: this._proxyOptions,\n                tlsOptions: this._tlsOptions\n              });\n              _context.next = 12;\n              return stateMachine.execute(this, context);\n            case 12:\n              dataKey = _context.sent;\n              _utils_1$MongoDBColle = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace), dbName = _utils_1$MongoDBColle.db, collectionName = _utils_1$MongoDBColle.collection;\n              _context.next = 16;\n              return this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey, {\n                writeConcern: {\n                  w: 'majority'\n                }\n              });\n            case 16:\n              _yield$this$_keyVault = _context.sent;\n              insertedId = _yield$this$_keyVault.insertedId;\n              return _context.abrupt(\"return\", insertedId);\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function createDataKey(_x) {\n        return _createDataKey.apply(this, arguments);\n      }\n      return createDataKey;\n    }()\n    /**\n     * Searches the keyvault for any data keys matching the provided filter.  If there are matches, rewrapManyDataKey then attempts to re-wrap the data keys using the provided options.\n     *\n     * If no matches are found, then no bulk write is performed.\n     *\n     * @example\n     * ```ts\n     * // rewrapping all data data keys (using a filter that matches all documents)\n     * const filter = {};\n     *\n     * const result = await clientEncryption.rewrapManyDataKey(filter);\n     * if (result.bulkWriteResult != null) {\n     *  // keys were re-wrapped, results will be available in the bulkWrite object.\n     * }\n     * ```\n     *\n     * @example\n     * ```ts\n     * // attempting to rewrap all data keys with no matches\n     * const filter = { _id: new Binary() } // assume _id matches no documents in the database\n     * const result = await clientEncryption.rewrapManyDataKey(filter);\n     *\n     * if (result.bulkWriteResult == null) {\n     *  // no keys matched, `bulkWriteResult` does not exist on the result object\n     * }\n     * ```\n     */\n  }, {\n    key: \"rewrapManyDataKey\",\n    value: function () {\n      var _rewrapManyDataKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(filter, options) {\n        var keyEncryptionKeyBson, keyEncryptionKey, filterBson, context, stateMachine, _yield$stateMachine$e, dataKeys, _utils_1$MongoDBColle2, dbName, collectionName, replacements, result;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              keyEncryptionKeyBson = undefined;\n              if (options) {\n                keyEncryptionKey = Object.assign({\n                  provider: options.provider\n                }, options.masterKey);\n                keyEncryptionKeyBson = (0, bson_1.serialize)(keyEncryptionKey);\n              }\n              filterBson = (0, bson_1.serialize)(filter);\n              context = this._mongoCrypt.makeRewrapManyDataKeyContext(filterBson, keyEncryptionKeyBson);\n              stateMachine = new state_machine_1.StateMachine({\n                proxyOptions: this._proxyOptions,\n                tlsOptions: this._tlsOptions\n              });\n              _context2.next = 7;\n              return stateMachine.execute(this, context);\n            case 7:\n              _yield$stateMachine$e = _context2.sent;\n              dataKeys = _yield$stateMachine$e.v;\n              if (!(dataKeys.length === 0)) {\n                _context2.next = 11;\n                break;\n              }\n              return _context2.abrupt(\"return\", {});\n            case 11:\n              _utils_1$MongoDBColle2 = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace), dbName = _utils_1$MongoDBColle2.db, collectionName = _utils_1$MongoDBColle2.collection;\n              replacements = dataKeys.map(function (key) {\n                return {\n                  updateOne: {\n                    filter: {\n                      _id: key._id\n                    },\n                    update: {\n                      $set: {\n                        masterKey: key.masterKey,\n                        keyMaterial: key.keyMaterial\n                      },\n                      $currentDate: {\n                        updateDate: true\n                      }\n                    }\n                  }\n                };\n              });\n              _context2.next = 15;\n              return this._keyVaultClient.db(dbName).collection(collectionName).bulkWrite(replacements, {\n                writeConcern: {\n                  w: 'majority'\n                }\n              });\n            case 15:\n              result = _context2.sent;\n              return _context2.abrupt(\"return\", {\n                bulkWriteResult: result\n              });\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function rewrapManyDataKey(_x2, _x3) {\n        return _rewrapManyDataKey.apply(this, arguments);\n      }\n      return rewrapManyDataKey;\n    }()\n    /**\n     * Deletes the key with the provided id from the keyvault, if it exists.\n     *\n     * @example\n     * ```ts\n     * // delete a key by _id\n     * const id = new Binary(); // id is a bson binary subtype 4 object\n     * const { deletedCount } = await clientEncryption.deleteKey(id);\n     *\n     * if (deletedCount != null && deletedCount > 0) {\n     *   // successful deletion\n     * }\n     * ```\n     *\n     */\n  }, {\n    key: \"deleteKey\",\n    value: function () {\n      var _deleteKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_id) {\n        var _utils_1$MongoDBColle3, dbName, collectionName;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _utils_1$MongoDBColle3 = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace), dbName = _utils_1$MongoDBColle3.db, collectionName = _utils_1$MongoDBColle3.collection;\n              return _context3.abrupt(\"return\", this._keyVaultClient.db(dbName).collection(collectionName).deleteOne({\n                _id: _id\n              }, {\n                writeConcern: {\n                  w: 'majority'\n                }\n              }));\n            case 2:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function deleteKey(_x4) {\n        return _deleteKey.apply(this, arguments);\n      }\n      return deleteKey;\n    }()\n    /**\n     * Finds all the keys currently stored in the keyvault.\n     *\n     * This method will not throw.\n     *\n     * @returns a FindCursor over all keys in the keyvault.\n     * @example\n     * ```ts\n     * // fetching all keys\n     * const keys = await clientEncryption.getKeys().toArray();\n     * ```\n     */\n  }, {\n    key: \"getKeys\",\n    value: function getKeys() {\n      var _utils_1$MongoDBColle4 = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace),\n        dbName = _utils_1$MongoDBColle4.db,\n        collectionName = _utils_1$MongoDBColle4.collection;\n      return this._keyVaultClient.db(dbName).collection(collectionName).find({}, {\n        readConcern: {\n          level: 'majority'\n        }\n      });\n    }\n    /**\n     * Finds a key in the keyvault with the specified _id.\n     *\n     * Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n     * match the id.  The promise rejects with an error if an error is thrown.\n     * @example\n     * ```ts\n     * // getting a key by id\n     * const id = new Binary(); // id is a bson binary subtype 4 object\n     * const key = await clientEncryption.getKey(id);\n     * if (!key) {\n     *  // key is null if there was no matching key\n     * }\n     * ```\n     */\n  }, {\n    key: \"getKey\",\n    value: function () {\n      var _getKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_id) {\n        var _utils_1$MongoDBColle5, dbName, collectionName;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _utils_1$MongoDBColle5 = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace), dbName = _utils_1$MongoDBColle5.db, collectionName = _utils_1$MongoDBColle5.collection;\n              return _context4.abrupt(\"return\", this._keyVaultClient.db(dbName).collection(collectionName).findOne({\n                _id: _id\n              }, {\n                readConcern: {\n                  level: 'majority'\n                }\n              }));\n            case 2:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function getKey(_x5) {\n        return _getKey.apply(this, arguments);\n      }\n      return getKey;\n    }()\n    /**\n     * Finds a key in the keyvault which has the specified keyAltName.\n     *\n     * @param keyAltName - a keyAltName to search for a key\n     * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n     * match the keyAltName.  The promise rejects with an error if an error is thrown.\n     * @example\n     * ```ts\n     * // get a key by alt name\n     * const keyAltName = 'keyAltName';\n     * const key = await clientEncryption.getKeyByAltName(keyAltName);\n     * if (!key) {\n     *  // key is null if there is no matching key\n     * }\n     * ```\n     */\n  }, {\n    key: \"getKeyByAltName\",\n    value: function () {\n      var _getKeyByAltName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(keyAltName) {\n        var _utils_1$MongoDBColle6, dbName, collectionName;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _utils_1$MongoDBColle6 = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace), dbName = _utils_1$MongoDBColle6.db, collectionName = _utils_1$MongoDBColle6.collection;\n              return _context5.abrupt(\"return\", this._keyVaultClient.db(dbName).collection(collectionName).findOne({\n                keyAltNames: keyAltName\n              }, {\n                readConcern: {\n                  level: 'majority'\n                }\n              }));\n            case 2:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function getKeyByAltName(_x6) {\n        return _getKeyByAltName.apply(this, arguments);\n      }\n      return getKeyByAltName;\n    }()\n    /**\n     * Adds a keyAltName to a key identified by the provided _id.\n     *\n     * This method resolves to/returns the *old* key value (prior to adding the new altKeyName).\n     *\n     * @param _id - The id of the document to update.\n     * @param keyAltName - a keyAltName to search for a key\n     * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n     * match the id.  The promise rejects with an error if an error is thrown.\n     * @example\n     * ```ts\n     * // adding an keyAltName to a data key\n     * const id = new Binary();  // id is a bson binary subtype 4 object\n     * const keyAltName = 'keyAltName';\n     * const oldKey = await clientEncryption.addKeyAltName(id, keyAltName);\n     * if (!oldKey) {\n     *  // null is returned if there is no matching document with an id matching the supplied id\n     * }\n     * ```\n     */\n  }, {\n    key: \"addKeyAltName\",\n    value: function () {\n      var _addKeyAltName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_id, keyAltName) {\n        var _utils_1$MongoDBColle7, dbName, collectionName, value;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _utils_1$MongoDBColle7 = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace), dbName = _utils_1$MongoDBColle7.db, collectionName = _utils_1$MongoDBColle7.collection;\n              _context6.next = 3;\n              return this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({\n                _id: _id\n              }, {\n                $addToSet: {\n                  keyAltNames: keyAltName\n                }\n              }, {\n                writeConcern: {\n                  w: 'majority'\n                },\n                returnDocument: 'before'\n              });\n            case 3:\n              value = _context6.sent;\n              return _context6.abrupt(\"return\", value);\n            case 5:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function addKeyAltName(_x7, _x8) {\n        return _addKeyAltName.apply(this, arguments);\n      }\n      return addKeyAltName;\n    }()\n    /**\n     * Adds a keyAltName to a key identified by the provided _id.\n     *\n     * This method resolves to/returns the *old* key value (prior to removing the new altKeyName).\n     *\n     * If the removed keyAltName is the last keyAltName for that key, the `altKeyNames` property is unset from the document.\n     *\n     * @param _id - The id of the document to update.\n     * @param keyAltName - a keyAltName to search for a key\n     * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n     * match the id.  The promise rejects with an error if an error is thrown.\n     * @example\n     * ```ts\n     * // removing a key alt name from a data key\n     * const id = new Binary();  // id is a bson binary subtype 4 object\n     * const keyAltName = 'keyAltName';\n     * const oldKey = await clientEncryption.removeKeyAltName(id, keyAltName);\n     *\n     * if (!oldKey) {\n     *  // null is returned if there is no matching document with an id matching the supplied id\n     * }\n     * ```\n     */\n  }, {\n    key: \"removeKeyAltName\",\n    value: function () {\n      var _removeKeyAltName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_id, keyAltName) {\n        var _utils_1$MongoDBColle8, dbName, collectionName, pipeline, value;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _utils_1$MongoDBColle8 = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace), dbName = _utils_1$MongoDBColle8.db, collectionName = _utils_1$MongoDBColle8.collection;\n              pipeline = [{\n                $set: {\n                  keyAltNames: {\n                    $cond: [{\n                      $eq: ['$keyAltNames', [keyAltName]]\n                    }, '$$REMOVE', {\n                      $filter: {\n                        input: '$keyAltNames',\n                        cond: {\n                          $ne: ['$$this', keyAltName]\n                        }\n                      }\n                    }]\n                  }\n                }\n              }];\n              _context7.next = 4;\n              return this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({\n                _id: _id\n              }, pipeline, {\n                writeConcern: {\n                  w: 'majority'\n                },\n                returnDocument: 'before'\n              });\n            case 4:\n              value = _context7.sent;\n              return _context7.abrupt(\"return\", value);\n            case 6:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function removeKeyAltName(_x9, _x10) {\n        return _removeKeyAltName.apply(this, arguments);\n      }\n      return removeKeyAltName;\n    }()\n    /**\n     * A convenience method for creating an encrypted collection.\n     * This method will create data keys for any encryptedFields that do not have a `keyId` defined\n     * and then create a new collection with the full set of encryptedFields.\n     *\n     * @param db - A Node.js driver Db object with which to create the collection\n     * @param name - The name of the collection to be created\n     * @param options - Options for createDataKey and for createCollection\n     * @returns created collection and generated encryptedFields\n     * @throws MongoCryptCreateDataKeyError - If part way through the process a createDataKey invocation fails, an error will be rejected that has the partial `encryptedFields` that were created.\n     * @throws MongoCryptCreateEncryptedCollectionError - If creating the collection fails, an error will be rejected that has the entire `encryptedFields` that were created.\n     */\n  }, {\n    key: \"createEncryptedCollection\",\n    value: function () {\n      var _createEncryptedCollection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(db, name, options) {\n        var _this = this;\n        var provider, masterKey, _options$createCollec, encryptedFields, createCollectionOptions, createDataKeyPromises, createDataKeyResolutions, rejection, collection;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              provider = options.provider, masterKey = options.masterKey, _options$createCollec = options.createCollectionOptions, encryptedFields = Object.assign({}, (_objectDestructuringEmpty(_options$createCollec.encryptedFields), _options$createCollec.encryptedFields)), createCollectionOptions = _objectWithoutProperties(_options$createCollec, _excluded);\n              if (!Array.isArray(encryptedFields.fields)) {\n                _context9.next = 10;\n                break;\n              }\n              createDataKeyPromises = encryptedFields.fields.map( /*#__PURE__*/function () {\n                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(field) {\n                  return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n                    while (1) switch (_context8.prev = _context8.next) {\n                      case 0:\n                        if (!(field == null || typeof field !== 'object' || field.keyId != null)) {\n                          _context8.next = 4;\n                          break;\n                        }\n                        _context8.t0 = field;\n                        _context8.next = 12;\n                        break;\n                      case 4:\n                        _context8.t1 = _objectSpread;\n                        _context8.t2 = _objectSpread({}, field);\n                        _context8.t3 = {};\n                        _context8.next = 9;\n                        return _this.createDataKey(provider, {\n                          masterKey: masterKey\n                        });\n                      case 9:\n                        _context8.t4 = _context8.sent;\n                        _context8.t5 = {\n                          keyId: _context8.t4\n                        };\n                        _context8.t0 = (0, _context8.t1)(_context8.t2, _context8.t3, _context8.t5);\n                      case 12:\n                        return _context8.abrupt(\"return\", _context8.t0);\n                      case 13:\n                      case \"end\":\n                        return _context8.stop();\n                    }\n                  }, _callee8);\n                }));\n                return function (_x14) {\n                  return _ref.apply(this, arguments);\n                };\n              }());\n              _context9.next = 5;\n              return Promise.allSettled(createDataKeyPromises);\n            case 5:\n              createDataKeyResolutions = _context9.sent;\n              encryptedFields.fields = createDataKeyResolutions.map(function (resolution, index) {\n                return resolution.status === 'fulfilled' ? resolution.value : encryptedFields.fields[index];\n              });\n              rejection = createDataKeyResolutions.find(function (result) {\n                return result.status === 'rejected';\n              });\n              if (!(rejection != null)) {\n                _context9.next = 10;\n                break;\n              }\n              throw new errors_1.MongoCryptCreateDataKeyError(encryptedFields, {\n                cause: rejection.reason\n              });\n            case 10:\n              _context9.prev = 10;\n              _context9.next = 13;\n              return db.createCollection(name, _objectSpread(_objectSpread({}, createCollectionOptions), {}, {\n                encryptedFields: encryptedFields\n              }));\n            case 13:\n              collection = _context9.sent;\n              return _context9.abrupt(\"return\", {\n                collection: collection,\n                encryptedFields: encryptedFields\n              });\n            case 17:\n              _context9.prev = 17;\n              _context9.t0 = _context9[\"catch\"](10);\n              throw new errors_1.MongoCryptCreateEncryptedCollectionError(encryptedFields, {\n                cause: _context9.t0\n              });\n            case 20:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, null, [[10, 17]]);\n      }));\n      function createEncryptedCollection(_x11, _x12, _x13) {\n        return _createEncryptedCollection.apply(this, arguments);\n      }\n      return createEncryptedCollection;\n    }()\n    /**\n     * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n     * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n     *\n     * @param value - The value that you wish to serialize. Must be of a type that can be serialized into BSON\n     * @param options -\n     * @returns a Promise that either resolves with the encrypted value, or rejects with an error.\n     *\n     * @example\n     * ```ts\n     * // Encryption with async/await api\n     * async function encryptMyData(value) {\n     *   const keyId = await clientEncryption.createDataKey('local');\n     *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n     * }\n     * ```\n     *\n     * @example\n     * ```ts\n     * // Encryption using a keyAltName\n     * async function encryptMyData(value) {\n     *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });\n     *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n     * }\n     * ```\n     */\n  }, {\n    key: \"encrypt\",\n    value: function () {\n      var _encrypt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(value, options) {\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              return _context10.abrupt(\"return\", this._encrypt(value, false, options));\n            case 1:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function encrypt(_x15, _x16) {\n        return _encrypt2.apply(this, arguments);\n      }\n      return encrypt;\n    }()\n    /**\n     * Encrypts a Match Expression or Aggregate Expression to query a range index.\n     *\n     * Only supported when queryType is \"rangePreview\" and algorithm is \"RangePreview\".\n     *\n     * @experimental The Range algorithm is experimental only. It is not intended for production use. It is subject to breaking changes.\n     *\n     * @param expression - a BSON document of one of the following forms:\n     *  1. A Match Expression of this form:\n     *      `{$and: [{<field>: {$gt: <value1>}}, {<field>: {$lt: <value2> }}]}`\n     *  2. An Aggregate Expression of this form:\n     *      `{$and: [{$gt: [<fieldpath>, <value1>]}, {$lt: [<fieldpath>, <value2>]}]}`\n     *\n     *    `$gt` may also be `$gte`. `$lt` may also be `$lte`.\n     *\n     * @param options -\n     * @returns Returns a Promise that either resolves with the encrypted value or rejects with an error.\n     */\n  }, {\n    key: \"encryptExpression\",\n    value: function () {\n      var _encryptExpression = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(expression, options) {\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              return _context11.abrupt(\"return\", this._encrypt(expression, true, options));\n            case 1:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function encryptExpression(_x17, _x18) {\n        return _encryptExpression.apply(this, arguments);\n      }\n      return encryptExpression;\n    }()\n    /**\n     * Explicitly decrypt a provided encrypted value\n     *\n     * @param value - An encrypted value\n     * @returns a Promise that either resolves with the decrypted value, or rejects with an error\n     *\n     * @example\n     * ```ts\n     * // Decrypting value with async/await API\n     * async function decryptMyValue(value) {\n     *   return clientEncryption.decrypt(value);\n     * }\n     * ```\n     */\n  }, {\n    key: \"decrypt\",\n    value: function () {\n      var _decrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(value) {\n        var valueBuffer, context, stateMachine, _yield$stateMachine$e2, v;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              valueBuffer = (0, bson_1.serialize)({\n                v: value\n              });\n              context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);\n              stateMachine = new state_machine_1.StateMachine({\n                proxyOptions: this._proxyOptions,\n                tlsOptions: this._tlsOptions\n              });\n              _context12.next = 5;\n              return stateMachine.execute(this, context);\n            case 5:\n              _yield$stateMachine$e2 = _context12.sent;\n              v = _yield$stateMachine$e2.v;\n              return _context12.abrupt(\"return\", v);\n            case 8:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function decrypt(_x19) {\n        return _decrypt.apply(this, arguments);\n      }\n      return decrypt;\n    }()\n    /**\n     * @internal\n     * Ask the user for KMS credentials.\n     *\n     * This returns anything that looks like the kmsProviders original input\n     * option. It can be empty, and any provider specified here will override\n     * the original ones.\n     */\n  }, {\n    key: \"askForKMSCredentials\",\n    value: function () {\n      var _askForKMSCredentials = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              return _context13.abrupt(\"return\", (0, index_1.refreshKMSCredentials)(this._kmsProviders));\n            case 1:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function askForKMSCredentials() {\n        return _askForKMSCredentials.apply(this, arguments);\n      }\n      return askForKMSCredentials;\n    }()\n  }, {\n    key: \"_encrypt\",\n    value:\n    /**\n     * @internal\n     * A helper that perform explicit encryption of values and expressions.\n     * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n     * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n     *\n     * @param value - The value that you wish to encrypt. Must be of a type that can be serialized into BSON\n     * @param expressionMode - a boolean that indicates whether or not to encrypt the value as an expression\n     * @param options - options to pass to encrypt\n     * @returns the raw result of the call to stateMachine.execute().  When expressionMode is set to true, the return\n     *          value will be a bson document.  When false, the value will be a BSON Binary.\n     *\n     */\n    function () {\n      var _encrypt3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(value, expressionMode, options) {\n        var algorithm, keyId, keyAltName, contentionFactor, queryType, rangeOptions, contextOptions, valueBuffer, stateMachine, context, result;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              algorithm = options.algorithm, keyId = options.keyId, keyAltName = options.keyAltName, contentionFactor = options.contentionFactor, queryType = options.queryType, rangeOptions = options.rangeOptions;\n              contextOptions = {\n                expressionMode: expressionMode,\n                algorithm: algorithm\n              };\n              if (keyId) {\n                contextOptions.keyId = keyId.buffer;\n              }\n              if (!keyAltName) {\n                _context14.next = 9;\n                break;\n              }\n              if (!keyId) {\n                _context14.next = 6;\n                break;\n              }\n              throw new errors_1.MongoCryptInvalidArgumentError(\"\\\"options\\\" cannot contain both \\\"keyId\\\" and \\\"keyAltName\\\"\");\n            case 6:\n              if (!(typeof keyAltName !== 'string')) {\n                _context14.next = 8;\n                break;\n              }\n              throw new errors_1.MongoCryptInvalidArgumentError(\"\\\"options.keyAltName\\\" must be of type string, but was of type \".concat(typeof keyAltName));\n            case 8:\n              contextOptions.keyAltName = (0, bson_1.serialize)({\n                keyAltName: keyAltName\n              });\n            case 9:\n              if (typeof contentionFactor === 'number' || typeof contentionFactor === 'bigint') {\n                contextOptions.contentionFactor = contentionFactor;\n              }\n              if (typeof queryType === 'string') {\n                contextOptions.queryType = queryType;\n              }\n              if (typeof rangeOptions === 'object') {\n                contextOptions.rangeOptions = (0, bson_1.serialize)(rangeOptions);\n              }\n              valueBuffer = (0, bson_1.serialize)({\n                v: value\n              });\n              stateMachine = new state_machine_1.StateMachine({\n                proxyOptions: this._proxyOptions,\n                tlsOptions: this._tlsOptions\n              });\n              context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);\n              _context14.next = 17;\n              return stateMachine.execute(this, context);\n            case 17:\n              result = _context14.sent;\n              return _context14.abrupt(\"return\", result.v);\n            case 19:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function _encrypt(_x20, _x21, _x22) {\n        return _encrypt3.apply(this, arguments);\n      }\n      return _encrypt;\n    }()\n  }], [{\n    key: \"getMongoCrypt\",\n    value: /** @internal */\n    function getMongoCrypt() {\n      var encryption = (0, deps_1.getMongoDBClientEncryption)();\n      if ('kModuleError' in encryption) {\n        throw encryption.kModuleError;\n      }\n      return encryption.MongoCrypt;\n    }\n  }, {\n    key: \"libmongocryptVersion\",\n    get: function get() {\n      return ClientEncryption.getMongoCrypt().libmongocryptVersion;\n    }\n  }]);\n  return ClientEncryption;\n}();\nexports.ClientEncryption = ClientEncryption;","map":{"version":3,"names":["bson_1","require","deps_1","utils_1","cryptoCallbacks","errors_1","index_1","state_machine_1","ClientEncryption","client","options","_options$proxyOptions","_options$tlsOptions","_classCallCheck","_client","_proxyOptions","proxyOptions","_tlsOptions","tlsOptions","_kmsProviders","kmsProviders","keyVaultNamespace","MongoCryptInvalidArgumentError","mongoCryptOptions","_objectSpread","Buffer","isBuffer","serialize","_keyVaultNamespace","_keyVaultClient","keyVaultClient","MongoCrypt","getMongoCrypt","_mongoCrypt","_createClass","key","value","_createDataKey","_asyncToGenerator","_regeneratorRuntime","mark","_callee","provider","keyAltNames","keyMaterial","dataKeyBson","context","stateMachine","dataKey","_utils_1$MongoDBColle","dbName","collectionName","_yield$this$_keyVault","insertedId","_args","arguments","wrap","_callee$","_context","prev","next","length","undefined","Array","isArray","concat","map","keyAltName","i","masterKey","makeDataKeyContext","StateMachine","execute","sent","MongoDBCollectionNamespace","fromString","db","collection","insertOne","writeConcern","w","abrupt","stop","createDataKey","_x","apply","_rewrapManyDataKey","_callee2","filter","keyEncryptionKeyBson","keyEncryptionKey","filterBson","_yield$stateMachine$e","dataKeys","_utils_1$MongoDBColle2","replacements","result","_callee2$","_context2","Object","assign","makeRewrapManyDataKeyContext","v","updateOne","_id","update","$set","$currentDate","updateDate","bulkWrite","bulkWriteResult","rewrapManyDataKey","_x2","_x3","_deleteKey","_callee3","_utils_1$MongoDBColle3","_callee3$","_context3","deleteOne","deleteKey","_x4","getKeys","_utils_1$MongoDBColle4","find","readConcern","level","_getKey","_callee4","_utils_1$MongoDBColle5","_callee4$","_context4","findOne","getKey","_x5","_getKeyByAltName","_callee5","_utils_1$MongoDBColle6","_callee5$","_context5","getKeyByAltName","_x6","_addKeyAltName","_callee6","_utils_1$MongoDBColle7","_callee6$","_context6","findOneAndUpdate","$addToSet","returnDocument","addKeyAltName","_x7","_x8","_removeKeyAltName","_callee7","_utils_1$MongoDBColle8","pipeline","_callee7$","_context7","$cond","$eq","$filter","input","cond","$ne","removeKeyAltName","_x9","_x10","_createEncryptedCollection","_callee9","name","_this","_options$createCollec","encryptedFields","createCollectionOptions","createDataKeyPromises","createDataKeyResolutions","rejection","_callee9$","_context9","_objectDestructuringEmpty","_objectWithoutProperties","_excluded","fields","_ref","_callee8","field","_callee8$","_context8","keyId","t0","t1","t2","t3","t4","t5","_x14","Promise","allSettled","resolution","index","status","MongoCryptCreateDataKeyError","cause","reason","createCollection","MongoCryptCreateEncryptedCollectionError","createEncryptedCollection","_x11","_x12","_x13","_encrypt2","_callee10","_callee10$","_context10","_encrypt","encrypt","_x15","_x16","_encryptExpression","_callee11","expression","_callee11$","_context11","encryptExpression","_x17","_x18","_decrypt","_callee12","valueBuffer","_yield$stateMachine$e2","_callee12$","_context12","makeExplicitDecryptionContext","decrypt","_x19","_askForKMSCredentials","_callee13","_callee13$","_context13","refreshKMSCredentials","askForKMSCredentials","_encrypt3","_callee14","expressionMode","algorithm","contentionFactor","queryType","rangeOptions","contextOptions","_callee14$","_context14","buffer","makeExplicitEncryptionContext","_x20","_x21","_x22","encryption","getMongoDBClientEncryption","kModuleError","get","libmongocryptVersion","exports"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\client-side-encryption\\client_encryption.ts"],"sourcesContent":["import type {\n  ExplicitEncryptionContextOptions,\n  MongoCrypt,\n  MongoCryptConstructor,\n  MongoCryptOptions\n} from 'mongodb-client-encryption';\n\nimport { type Binary, type Document, type Long, serialize, type UUID } from '../bson';\nimport { type AnyBulkWriteOperation, type BulkWriteResult } from '../bulk/common';\nimport { type ProxyOptions } from '../cmap/connection';\nimport { type Collection } from '../collection';\nimport { type FindCursor } from '../cursor/find_cursor';\nimport { type Db } from '../db';\nimport { getMongoDBClientEncryption } from '../deps';\nimport { type MongoClient } from '../mongo_client';\nimport { type Filter, type WithId } from '../mongo_types';\nimport { type CreateCollectionOptions } from '../operations/create_collection';\nimport { type DeleteResult } from '../operations/delete';\nimport { MongoDBCollectionNamespace } from '../utils';\nimport * as cryptoCallbacks from './crypto_callbacks';\nimport {\n  MongoCryptCreateDataKeyError,\n  MongoCryptCreateEncryptedCollectionError,\n  MongoCryptInvalidArgumentError\n} from './errors';\nimport {\n  type ClientEncryptionDataKeyProvider,\n  type KMSProviders,\n  refreshKMSCredentials\n} from './providers/index';\nimport { type CSFLEKMSTlsOptions, StateMachine } from './state_machine';\n\n/**\n * @public\n * The schema for a DataKey in the key vault collection.\n */\nexport interface DataKey {\n  _id: UUID;\n  version?: number;\n  keyAltNames?: string[];\n  keyMaterial: Binary;\n  creationDate: Date;\n  updateDate: Date;\n  status: number;\n  masterKey: Document;\n}\n\n/**\n * @public\n * The public interface for explicit in-use encryption\n */\nexport class ClientEncryption {\n  /** @internal */\n  _client: MongoClient;\n  /** @internal */\n  _keyVaultNamespace: string;\n  /** @internal */\n  _keyVaultClient: MongoClient;\n  /** @internal */\n  _proxyOptions: ProxyOptions;\n  /** @internal */\n  _tlsOptions: CSFLEKMSTlsOptions;\n  /** @internal */\n  _kmsProviders: KMSProviders;\n\n  /** @internal */\n  _mongoCrypt: MongoCrypt;\n\n  /** @internal */\n  static getMongoCrypt(): MongoCryptConstructor {\n    const encryption = getMongoDBClientEncryption();\n    if ('kModuleError' in encryption) {\n      throw encryption.kModuleError;\n    }\n    return encryption.MongoCrypt;\n  }\n\n  /**\n   * Create a new encryption instance\n   *\n   * @example\n   * ```ts\n   * new ClientEncryption(mongoClient, {\n   *   keyVaultNamespace: 'client.encryption',\n   *   kmsProviders: {\n   *     local: {\n   *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```ts\n   * new ClientEncryption(mongoClient, {\n   *   keyVaultNamespace: 'client.encryption',\n   *   kmsProviders: {\n   *     aws: {\n   *       accessKeyId: AWS_ACCESS_KEY,\n   *       secretAccessKey: AWS_SECRET_KEY\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  constructor(client: MongoClient, options: ClientEncryptionOptions) {\n    this._client = client;\n    this._proxyOptions = options.proxyOptions ?? {};\n    this._tlsOptions = options.tlsOptions ?? {};\n    this._kmsProviders = options.kmsProviders || {};\n\n    if (options.keyVaultNamespace == null) {\n      throw new MongoCryptInvalidArgumentError('Missing required option `keyVaultNamespace`');\n    }\n\n    const mongoCryptOptions: MongoCryptOptions = {\n      ...options,\n      cryptoCallbacks,\n      kmsProviders: !Buffer.isBuffer(this._kmsProviders)\n        ? (serialize(this._kmsProviders) as Buffer)\n        : this._kmsProviders\n    };\n\n    this._keyVaultNamespace = options.keyVaultNamespace;\n    this._keyVaultClient = options.keyVaultClient || client;\n    const MongoCrypt = ClientEncryption.getMongoCrypt();\n    this._mongoCrypt = new MongoCrypt(mongoCryptOptions);\n  }\n\n  /**\n   * Creates a data key used for explicit encryption and inserts it into the key vault namespace\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create a local key\n   * const dataKeyId = await clientEncryption.createDataKey('local');\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create an aws key\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\n   *   masterKey: {\n   *     region: 'us-east-1',\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create an aws key with a keyAltName\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\n   *   masterKey: {\n   *     region: 'us-east-1',\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n   *   },\n   *   keyAltNames: [ 'mySpecialKey' ]\n   * });\n   * ```\n   */\n  async createDataKey(\n    provider: ClientEncryptionDataKeyProvider,\n    options: ClientEncryptionCreateDataKeyProviderOptions = {}\n  ): Promise<UUID> {\n    if (options.keyAltNames && !Array.isArray(options.keyAltNames)) {\n      throw new MongoCryptInvalidArgumentError(\n        `Option \"keyAltNames\" must be an array of strings, but was of type ${typeof options.keyAltNames}.`\n      );\n    }\n\n    let keyAltNames = undefined;\n    if (options.keyAltNames && options.keyAltNames.length > 0) {\n      keyAltNames = options.keyAltNames.map((keyAltName, i) => {\n        if (typeof keyAltName !== 'string') {\n          throw new MongoCryptInvalidArgumentError(\n            `Option \"keyAltNames\" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`\n          );\n        }\n\n        return serialize({ keyAltName });\n      });\n    }\n\n    let keyMaterial = undefined;\n    if (options.keyMaterial) {\n      keyMaterial = serialize({ keyMaterial: options.keyMaterial });\n    }\n\n    const dataKeyBson = serialize({\n      provider,\n      ...options.masterKey\n    });\n\n    const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {\n      keyAltNames,\n      keyMaterial\n    });\n\n    const stateMachine = new StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n\n    const dataKey = await stateMachine.execute<DataKey>(this, context);\n\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    const { insertedId } = await this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .insertOne(dataKey, { writeConcern: { w: 'majority' } });\n\n    return insertedId;\n  }\n\n  /**\n   * Searches the keyvault for any data keys matching the provided filter.  If there are matches, rewrapManyDataKey then attempts to re-wrap the data keys using the provided options.\n   *\n   * If no matches are found, then no bulk write is performed.\n   *\n   * @example\n   * ```ts\n   * // rewrapping all data data keys (using a filter that matches all documents)\n   * const filter = {};\n   *\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\n   * if (result.bulkWriteResult != null) {\n   *  // keys were re-wrapped, results will be available in the bulkWrite object.\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * // attempting to rewrap all data keys with no matches\n   * const filter = { _id: new Binary() } // assume _id matches no documents in the database\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\n   *\n   * if (result.bulkWriteResult == null) {\n   *  // no keys matched, `bulkWriteResult` does not exist on the result object\n   * }\n   * ```\n   */\n  async rewrapManyDataKey(\n    filter: Filter<DataKey>,\n    options: ClientEncryptionRewrapManyDataKeyProviderOptions\n  ): Promise<{ bulkWriteResult?: BulkWriteResult }> {\n    let keyEncryptionKeyBson = undefined;\n    if (options) {\n      const keyEncryptionKey = Object.assign({ provider: options.provider }, options.masterKey);\n      keyEncryptionKeyBson = serialize(keyEncryptionKey);\n    }\n    const filterBson = serialize(filter);\n    const context = this._mongoCrypt.makeRewrapManyDataKeyContext(filterBson, keyEncryptionKeyBson);\n    const stateMachine = new StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n\n    const { v: dataKeys } = await stateMachine.execute<{ v: DataKey[] }>(this, context);\n    if (dataKeys.length === 0) {\n      return {};\n    }\n\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    const replacements = dataKeys.map(\n      (key: DataKey): AnyBulkWriteOperation<DataKey> => ({\n        updateOne: {\n          filter: { _id: key._id },\n          update: {\n            $set: {\n              masterKey: key.masterKey,\n              keyMaterial: key.keyMaterial\n            },\n            $currentDate: {\n              updateDate: true\n            }\n          }\n        }\n      })\n    );\n\n    const result = await this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .bulkWrite(replacements, {\n        writeConcern: { w: 'majority' }\n      });\n\n    return { bulkWriteResult: result };\n  }\n\n  /**\n   * Deletes the key with the provided id from the keyvault, if it exists.\n   *\n   * @example\n   * ```ts\n   * // delete a key by _id\n   * const id = new Binary(); // id is a bson binary subtype 4 object\n   * const { deletedCount } = await clientEncryption.deleteKey(id);\n   *\n   * if (deletedCount != null && deletedCount > 0) {\n   *   // successful deletion\n   * }\n   * ```\n   *\n   */\n  async deleteKey(_id: Binary): Promise<DeleteResult> {\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    return this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .deleteOne({ _id }, { writeConcern: { w: 'majority' } });\n  }\n\n  /**\n   * Finds all the keys currently stored in the keyvault.\n   *\n   * This method will not throw.\n   *\n   * @returns a FindCursor over all keys in the keyvault.\n   * @example\n   * ```ts\n   * // fetching all keys\n   * const keys = await clientEncryption.getKeys().toArray();\n   * ```\n   */\n  getKeys(): FindCursor<DataKey> {\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    return this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .find({}, { readConcern: { level: 'majority' } });\n  }\n\n  /**\n   * Finds a key in the keyvault with the specified _id.\n   *\n   * Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // getting a key by id\n   * const id = new Binary(); // id is a bson binary subtype 4 object\n   * const key = await clientEncryption.getKey(id);\n   * if (!key) {\n   *  // key is null if there was no matching key\n   * }\n   * ```\n   */\n  async getKey(_id: Binary): Promise<DataKey | null> {\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    return this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .findOne({ _id }, { readConcern: { level: 'majority' } });\n  }\n\n  /**\n   * Finds a key in the keyvault which has the specified keyAltName.\n   *\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the keyAltName.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // get a key by alt name\n   * const keyAltName = 'keyAltName';\n   * const key = await clientEncryption.getKeyByAltName(keyAltName);\n   * if (!key) {\n   *  // key is null if there is no matching key\n   * }\n   * ```\n   */\n  async getKeyByAltName(keyAltName: string): Promise<WithId<DataKey> | null> {\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    return this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .findOne({ keyAltNames: keyAltName }, { readConcern: { level: 'majority' } });\n  }\n\n  /**\n   * Adds a keyAltName to a key identified by the provided _id.\n   *\n   * This method resolves to/returns the *old* key value (prior to adding the new altKeyName).\n   *\n   * @param _id - The id of the document to update.\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // adding an keyAltName to a data key\n   * const id = new Binary();  // id is a bson binary subtype 4 object\n   * const keyAltName = 'keyAltName';\n   * const oldKey = await clientEncryption.addKeyAltName(id, keyAltName);\n   * if (!oldKey) {\n   *  // null is returned if there is no matching document with an id matching the supplied id\n   * }\n   * ```\n   */\n  async addKeyAltName(_id: Binary, keyAltName: string): Promise<WithId<DataKey> | null> {\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    const value = await this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .findOneAndUpdate(\n        { _id },\n        { $addToSet: { keyAltNames: keyAltName } },\n        { writeConcern: { w: 'majority' }, returnDocument: 'before' }\n      );\n\n    return value;\n  }\n\n  /**\n   * Adds a keyAltName to a key identified by the provided _id.\n   *\n   * This method resolves to/returns the *old* key value (prior to removing the new altKeyName).\n   *\n   * If the removed keyAltName is the last keyAltName for that key, the `altKeyNames` property is unset from the document.\n   *\n   * @param _id - The id of the document to update.\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // removing a key alt name from a data key\n   * const id = new Binary();  // id is a bson binary subtype 4 object\n   * const keyAltName = 'keyAltName';\n   * const oldKey = await clientEncryption.removeKeyAltName(id, keyAltName);\n   *\n   * if (!oldKey) {\n   *  // null is returned if there is no matching document with an id matching the supplied id\n   * }\n   * ```\n   */\n  async removeKeyAltName(_id: Binary, keyAltName: string): Promise<WithId<DataKey> | null> {\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    const pipeline = [\n      {\n        $set: {\n          keyAltNames: {\n            $cond: [\n              {\n                $eq: ['$keyAltNames', [keyAltName]]\n              },\n              '$$REMOVE',\n              {\n                $filter: {\n                  input: '$keyAltNames',\n                  cond: {\n                    $ne: ['$$this', keyAltName]\n                  }\n                }\n              }\n            ]\n          }\n        }\n      }\n    ];\n    const value = await this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .findOneAndUpdate({ _id }, pipeline, {\n        writeConcern: { w: 'majority' },\n        returnDocument: 'before'\n      });\n\n    return value;\n  }\n\n  /**\n   * A convenience method for creating an encrypted collection.\n   * This method will create data keys for any encryptedFields that do not have a `keyId` defined\n   * and then create a new collection with the full set of encryptedFields.\n   *\n   * @param db - A Node.js driver Db object with which to create the collection\n   * @param name - The name of the collection to be created\n   * @param options - Options for createDataKey and for createCollection\n   * @returns created collection and generated encryptedFields\n   * @throws MongoCryptCreateDataKeyError - If part way through the process a createDataKey invocation fails, an error will be rejected that has the partial `encryptedFields` that were created.\n   * @throws MongoCryptCreateEncryptedCollectionError - If creating the collection fails, an error will be rejected that has the entire `encryptedFields` that were created.\n   */\n  async createEncryptedCollection<TSchema extends Document = Document>(\n    db: Db,\n    name: string,\n    options: {\n      provider: ClientEncryptionDataKeyProvider;\n      createCollectionOptions: Omit<CreateCollectionOptions, 'encryptedFields'> & {\n        encryptedFields: Document;\n      };\n      masterKey?: AWSEncryptionKeyOptions | AzureEncryptionKeyOptions | GCPEncryptionKeyOptions;\n    }\n  ): Promise<{ collection: Collection<TSchema>; encryptedFields: Document }> {\n    const {\n      provider,\n      masterKey,\n      createCollectionOptions: {\n        encryptedFields: { ...encryptedFields },\n        ...createCollectionOptions\n      }\n    } = options;\n\n    if (Array.isArray(encryptedFields.fields)) {\n      const createDataKeyPromises = encryptedFields.fields.map(async field =>\n        field == null || typeof field !== 'object' || field.keyId != null\n          ? field\n          : {\n              ...field,\n              keyId: await this.createDataKey(provider, { masterKey })\n            }\n      );\n\n      const createDataKeyResolutions = await Promise.allSettled(createDataKeyPromises);\n\n      encryptedFields.fields = createDataKeyResolutions.map((resolution, index) =>\n        resolution.status === 'fulfilled' ? resolution.value : encryptedFields.fields[index]\n      );\n\n      const rejection = createDataKeyResolutions.find(\n        (result): result is PromiseRejectedResult => result.status === 'rejected'\n      );\n      if (rejection != null) {\n        throw new MongoCryptCreateDataKeyError(encryptedFields, { cause: rejection.reason });\n      }\n    }\n\n    try {\n      const collection = await db.createCollection<TSchema>(name, {\n        ...createCollectionOptions,\n        encryptedFields\n      });\n      return { collection, encryptedFields };\n    } catch (cause) {\n      throw new MongoCryptCreateEncryptedCollectionError(encryptedFields, { cause });\n    }\n  }\n\n  /**\n   * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n   * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n   *\n   * @param value - The value that you wish to serialize. Must be of a type that can be serialized into BSON\n   * @param options -\n   * @returns a Promise that either resolves with the encrypted value, or rejects with an error.\n   *\n   * @example\n   * ```ts\n   * // Encryption with async/await api\n   * async function encryptMyData(value) {\n   *   const keyId = await clientEncryption.createDataKey('local');\n   *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Encryption using a keyAltName\n   * async function encryptMyData(value) {\n   *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });\n   *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n   * }\n   * ```\n   */\n  async encrypt(value: unknown, options: ClientEncryptionEncryptOptions): Promise<Binary> {\n    return this._encrypt(value, false, options);\n  }\n\n  /**\n   * Encrypts a Match Expression or Aggregate Expression to query a range index.\n   *\n   * Only supported when queryType is \"rangePreview\" and algorithm is \"RangePreview\".\n   *\n   * @experimental The Range algorithm is experimental only. It is not intended for production use. It is subject to breaking changes.\n   *\n   * @param expression - a BSON document of one of the following forms:\n   *  1. A Match Expression of this form:\n   *      `{$and: [{<field>: {$gt: <value1>}}, {<field>: {$lt: <value2> }}]}`\n   *  2. An Aggregate Expression of this form:\n   *      `{$and: [{$gt: [<fieldpath>, <value1>]}, {$lt: [<fieldpath>, <value2>]}]}`\n   *\n   *    `$gt` may also be `$gte`. `$lt` may also be `$lte`.\n   *\n   * @param options -\n   * @returns Returns a Promise that either resolves with the encrypted value or rejects with an error.\n   */\n  async encryptExpression(\n    expression: Document,\n    options: ClientEncryptionEncryptOptions\n  ): Promise<Binary> {\n    return this._encrypt(expression, true, options);\n  }\n\n  /**\n   * Explicitly decrypt a provided encrypted value\n   *\n   * @param value - An encrypted value\n   * @returns a Promise that either resolves with the decrypted value, or rejects with an error\n   *\n   * @example\n   * ```ts\n   * // Decrypting value with async/await API\n   * async function decryptMyValue(value) {\n   *   return clientEncryption.decrypt(value);\n   * }\n   * ```\n   */\n  async decrypt<T = any>(value: Binary): Promise<T> {\n    const valueBuffer = serialize({ v: value });\n    const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);\n\n    const stateMachine = new StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n\n    const { v } = await stateMachine.execute<{ v: T }>(this, context);\n\n    return v;\n  }\n\n  /**\n   * @internal\n   * Ask the user for KMS credentials.\n   *\n   * This returns anything that looks like the kmsProviders original input\n   * option. It can be empty, and any provider specified here will override\n   * the original ones.\n   */\n  async askForKMSCredentials(): Promise<KMSProviders> {\n    return refreshKMSCredentials(this._kmsProviders);\n  }\n\n  static get libmongocryptVersion() {\n    return ClientEncryption.getMongoCrypt().libmongocryptVersion;\n  }\n\n  /**\n   * @internal\n   * A helper that perform explicit encryption of values and expressions.\n   * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n   * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n   *\n   * @param value - The value that you wish to encrypt. Must be of a type that can be serialized into BSON\n   * @param expressionMode - a boolean that indicates whether or not to encrypt the value as an expression\n   * @param options - options to pass to encrypt\n   * @returns the raw result of the call to stateMachine.execute().  When expressionMode is set to true, the return\n   *          value will be a bson document.  When false, the value will be a BSON Binary.\n   *\n   */\n  private async _encrypt(\n    value: unknown,\n    expressionMode: boolean,\n    options: ClientEncryptionEncryptOptions\n  ): Promise<Binary> {\n    const { algorithm, keyId, keyAltName, contentionFactor, queryType, rangeOptions } = options;\n    const contextOptions: ExplicitEncryptionContextOptions = {\n      expressionMode,\n      algorithm\n    };\n    if (keyId) {\n      contextOptions.keyId = keyId.buffer;\n    }\n    if (keyAltName) {\n      if (keyId) {\n        throw new MongoCryptInvalidArgumentError(\n          `\"options\" cannot contain both \"keyId\" and \"keyAltName\"`\n        );\n      }\n      if (typeof keyAltName !== 'string') {\n        throw new MongoCryptInvalidArgumentError(\n          `\"options.keyAltName\" must be of type string, but was of type ${typeof keyAltName}`\n        );\n      }\n\n      contextOptions.keyAltName = serialize({ keyAltName });\n    }\n    if (typeof contentionFactor === 'number' || typeof contentionFactor === 'bigint') {\n      contextOptions.contentionFactor = contentionFactor;\n    }\n    if (typeof queryType === 'string') {\n      contextOptions.queryType = queryType;\n    }\n\n    if (typeof rangeOptions === 'object') {\n      contextOptions.rangeOptions = serialize(rangeOptions);\n    }\n\n    const valueBuffer = serialize({ v: value });\n    const stateMachine = new StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n    const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);\n\n    const result = await stateMachine.execute<{ v: Binary }>(this, context);\n    return result.v;\n  }\n}\n\n/**\n * @public\n * Options to provide when encrypting data.\n */\nexport interface ClientEncryptionEncryptOptions {\n  /**\n   * The algorithm to use for encryption.\n   */\n  algorithm:\n    | 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic'\n    | 'AEAD_AES_256_CBC_HMAC_SHA_512-Random'\n    | 'Indexed'\n    | 'Unindexed'\n    | 'RangePreview';\n\n  /**\n   * The id of the Binary dataKey to use for encryption\n   */\n  keyId?: Binary;\n\n  /**\n   * A unique string name corresponding to an already existing dataKey.\n   */\n  keyAltName?: string;\n\n  /** The contention factor. */\n  contentionFactor?: bigint | number;\n\n  /**\n   * The query type supported.  Only the queryType `equality` is stable.\n   *\n   * @experimental Public Technical Preview: The queryType `rangePreview` is experimental.\n   */\n  queryType?: 'equality' | 'rangePreview';\n\n  /** @experimental Public Technical Preview: The index options for a Queryable Encryption field supporting \"rangePreview\" queries.*/\n  rangeOptions?: RangeOptions;\n}\n\n/**\n * @public\n * @experimental\n */\nexport interface ClientEncryptionRewrapManyDataKeyProviderOptions {\n  provider: ClientEncryptionDataKeyProvider;\n  masterKey?:\n    | AWSEncryptionKeyOptions\n    | AzureEncryptionKeyOptions\n    | GCPEncryptionKeyOptions\n    | undefined;\n}\n\n/**\n * @public\n * Additional settings to provide when creating a new `ClientEncryption` instance.\n */\nexport interface ClientEncryptionOptions {\n  /**\n   * The namespace of the key vault, used to store encryption keys\n   */\n  keyVaultNamespace: string;\n\n  /**\n   * A MongoClient used to fetch keys from a key vault. Defaults to client.\n   */\n  keyVaultClient?: MongoClient | undefined;\n\n  /**\n   * Options for specific KMS providers to use\n   */\n  kmsProviders?: KMSProviders;\n\n  /**\n   * Options for specifying a Socks5 proxy to use for connecting to the KMS.\n   */\n  proxyOptions?: ProxyOptions;\n\n  /**\n   * TLS options for kms providers to use.\n   */\n  tlsOptions?: CSFLEKMSTlsOptions;\n}\n\n/**\n * @public\n * Configuration options for making an AWS encryption key\n */\nexport interface AWSEncryptionKeyOptions {\n  /**\n   * The AWS region of the KMS\n   */\n  region: string;\n\n  /**\n   * The Amazon Resource Name (ARN) to the AWS customer master key (CMK)\n   */\n  key: string;\n\n  /**\n   * An alternate host to send KMS requests to. May include port number.\n   */\n  endpoint?: string | undefined;\n}\n\n/**\n * @public\n * Configuration options for making an AWS encryption key\n */\nexport interface GCPEncryptionKeyOptions {\n  /**\n   * GCP project ID\n   */\n  projectId: string;\n\n  /**\n   * Location name (e.g. \"global\")\n   */\n  location: string;\n\n  /**\n   * Key ring name\n   */\n  keyRing: string;\n\n  /**\n   * Key name\n   */\n  keyName: string;\n\n  /**\n   * Key version\n   */\n  keyVersion?: string | undefined;\n\n  /**\n   * KMS URL, defaults to `https://www.googleapis.com/auth/cloudkms`\n   */\n  endpoint?: string | undefined;\n}\n\n/**\n * @public\n * Configuration options for making an Azure encryption key\n */\nexport interface AzureEncryptionKeyOptions {\n  /**\n   * Key name\n   */\n  keyName: string;\n\n  /**\n   * Key vault URL, typically `<name>.vault.azure.net`\n   */\n  keyVaultEndpoint: string;\n\n  /**\n   * Key version\n   */\n  keyVersion?: string | undefined;\n}\n\n/**\n * @public\n * Options to provide when creating a new data key.\n */\nexport interface ClientEncryptionCreateDataKeyProviderOptions {\n  /**\n   * Identifies a new KMS-specific key used to encrypt the new data key\n   */\n  masterKey?:\n    | AWSEncryptionKeyOptions\n    | AzureEncryptionKeyOptions\n    | GCPEncryptionKeyOptions\n    | undefined;\n\n  /**\n   * An optional list of string alternate names used to reference a key.\n   * If a key is created with alternate names, then encryption may refer to the key by the unique alternate name instead of by _id.\n   */\n  keyAltNames?: string[] | undefined;\n\n  /** @experimental */\n  keyMaterial?: Buffer | Binary;\n}\n\n/**\n * @public\n * @experimental\n */\nexport interface ClientEncryptionRewrapManyDataKeyProviderOptions {\n  provider: ClientEncryptionDataKeyProvider;\n  masterKey?:\n    | AWSEncryptionKeyOptions\n    | AzureEncryptionKeyOptions\n    | GCPEncryptionKeyOptions\n    | undefined;\n}\n\n/**\n * @public\n * @experimental\n */\nexport interface ClientEncryptionRewrapManyDataKeyResult {\n  /** The result of rewrapping data keys. If unset, no keys matched the filter. */\n  bulkWriteResult?: BulkWriteResult;\n}\n\n/**\n * @public\n * RangeOptions specifies index options for a Queryable Encryption field supporting \"rangePreview\" queries.\n * min, max, sparsity, and range must match the values set in the encryptedFields of the destination collection.\n * For double and decimal128, min/max/precision must all be set, or all be unset.\n */\nexport interface RangeOptions {\n  min?: any;\n  max?: any;\n  sparsity: Long;\n  precision?: number;\n}\n\n/**\n * @public\n * Options to provide when encrypting data.\n */\nexport interface ClientEncryptionEncryptOptions {\n  /**\n   * The algorithm to use for encryption.\n   */\n  algorithm:\n    | 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic'\n    | 'AEAD_AES_256_CBC_HMAC_SHA_512-Random'\n    | 'Indexed'\n    | 'Unindexed'\n    | 'RangePreview';\n\n  /**\n   * The id of the Binary dataKey to use for encryption\n   */\n  keyId?: Binary;\n\n  /**\n   * A unique string name corresponding to an already existing dataKey.\n   */\n  keyAltName?: string;\n\n  /** The contention factor. */\n  contentionFactor?: bigint | number;\n\n  /**\n   * The query type supported.  Only the queryType `equality` is stable.\n   *\n   * @experimental Public Technical Preview: The queryType `rangePreview` is experimental.\n   */\n  queryType?: 'equality' | 'rangePreview';\n\n  /** @experimental Public Technical Preview: The index options for a Queryable Encryption field supporting \"rangePreview\" queries.*/\n  rangeOptions?: RangeOptions;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}