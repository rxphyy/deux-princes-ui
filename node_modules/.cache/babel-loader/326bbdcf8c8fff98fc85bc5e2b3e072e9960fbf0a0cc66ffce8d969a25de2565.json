{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _objectSpread = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _regeneratorRuntime = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Collection = void 0;\nvar bson_1 = require(\"./bson\");\nvar ordered_1 = require(\"./bulk/ordered\");\nvar unordered_1 = require(\"./bulk/unordered\");\nvar change_stream_1 = require(\"./change_stream\");\nvar aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\nvar find_cursor_1 = require(\"./cursor/find_cursor\");\nvar list_indexes_cursor_1 = require(\"./cursor/list_indexes_cursor\");\nvar list_search_indexes_cursor_1 = require(\"./cursor/list_search_indexes_cursor\");\nvar error_1 = require(\"./error\");\nvar bulk_write_1 = require(\"./operations/bulk_write\");\nvar count_1 = require(\"./operations/count\");\nvar count_documents_1 = require(\"./operations/count_documents\");\nvar delete_1 = require(\"./operations/delete\");\nvar distinct_1 = require(\"./operations/distinct\");\nvar drop_1 = require(\"./operations/drop\");\nvar estimated_document_count_1 = require(\"./operations/estimated_document_count\");\nvar execute_operation_1 = require(\"./operations/execute_operation\");\nvar find_and_modify_1 = require(\"./operations/find_and_modify\");\nvar indexes_1 = require(\"./operations/indexes\");\nvar insert_1 = require(\"./operations/insert\");\nvar is_capped_1 = require(\"./operations/is_capped\");\nvar options_operation_1 = require(\"./operations/options_operation\");\nvar rename_1 = require(\"./operations/rename\");\nvar create_1 = require(\"./operations/search_indexes/create\");\nvar drop_2 = require(\"./operations/search_indexes/drop\");\nvar update_1 = require(\"./operations/search_indexes/update\");\nvar update_2 = require(\"./operations/update\");\nvar read_concern_1 = require(\"./read_concern\");\nvar read_preference_1 = require(\"./read_preference\");\nvar utils_1 = require(\"./utils\");\nvar write_concern_1 = require(\"./write_concern\");\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/find/update/delete and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * interface Pet {\n *   name: string;\n *   kind: 'dog' | 'cat' | 'fish';\n * }\n *\n * const client = new MongoClient('mongodb://localhost:27017');\n * const pets = client.db().collection<Pet>('pets');\n *\n * const petCursor = pets.find();\n *\n * for await (const pet of petCursor) {\n *   console.log(`${pet.name} is a ${pet.kind}!`);\n * }\n * ```\n */\nvar Collection = /*#__PURE__*/function () {\n  /**\n   * Create a new Collection instance\n   * @internal\n   */\n  function Collection(db, name, options) {\n    var _db$options$pkFactory, _db$options;\n    _classCallCheck(this, Collection);\n    (0, utils_1.checkCollectionName)(name);\n    // Internal state\n    this.s = {\n      db: db,\n      options: options,\n      namespace: new utils_1.MongoDBCollectionNamespace(db.databaseName, name),\n      pkFactory: (_db$options$pkFactory = (_db$options = db.options) === null || _db$options === void 0 ? void 0 : _db$options.pkFactory) !== null && _db$options$pkFactory !== void 0 ? _db$options$pkFactory : utils_1.DEFAULT_PK_FACTORY,\n      readPreference: read_preference_1.ReadPreference.fromOptions(options),\n      bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),\n      readConcern: read_concern_1.ReadConcern.fromOptions(options),\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    };\n    this.client = db.client;\n  }\n  /**\n   * The name of the database this collection belongs to\n   */\n  _createClass(Collection, [{\n    key: \"dbName\",\n    get: function get() {\n      return this.s.namespace.db;\n    }\n    /**\n     * The name of this collection\n     */\n  }, {\n    key: \"collectionName\",\n    get: function get() {\n      return this.s.namespace.collection;\n    }\n    /**\n     * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n     */\n  }, {\n    key: \"namespace\",\n    get: function get() {\n      return this.fullNamespace.toString();\n    }\n    /**\n     *  @internal\n     *\n     * The `MongoDBNamespace` for the collection.\n     */\n  }, {\n    key: \"fullNamespace\",\n    get: function get() {\n      return this.s.namespace;\n    }\n    /**\n     * The current readConcern of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n  }, {\n    key: \"readConcern\",\n    get: function get() {\n      if (this.s.readConcern == null) {\n        return this.s.db.readConcern;\n      }\n      return this.s.readConcern;\n    }\n    /**\n     * The current readPreference of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n  }, {\n    key: \"readPreference\",\n    get: function get() {\n      if (this.s.readPreference == null) {\n        return this.s.db.readPreference;\n      }\n      return this.s.readPreference;\n    }\n  }, {\n    key: \"bsonOptions\",\n    get: function get() {\n      return this.s.bsonOptions;\n    }\n    /**\n     * The current writeConcern of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n  }, {\n    key: \"writeConcern\",\n    get: function get() {\n      if (this.s.writeConcern == null) {\n        return this.s.db.writeConcern;\n      }\n      return this.s.writeConcern;\n    }\n    /** The current index hint for the collection */\n  }, {\n    key: \"hint\",\n    get: function get() {\n      return this.s.collectionHint;\n    },\n    set: function set(v) {\n      this.s.collectionHint = (0, utils_1.normalizeHintField)(v);\n    }\n    /**\n     * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,\n     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n     * can be overridden by setting the **forceServerObjectId** flag.\n     *\n     * @param doc - The document to insert\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"insertOne\",\n    value: function () {\n      var _insertOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(doc, options) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options))));\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function insertOne(_x, _x2) {\n        return _insertOne.apply(this, arguments);\n      }\n      return insertOne;\n    }()\n    /**\n     * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n     * can be overridden by setting the **forceServerObjectId** flag.\n     *\n     * @param docs - The documents to insert\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"insertMany\",\n    value: function () {\n      var _insertMany = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(docs, options) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options !== null && options !== void 0 ? options : {\n                ordered: true\n              }))));\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function insertMany(_x3, _x4) {\n        return _insertMany.apply(this, arguments);\n      }\n      return insertMany;\n    }()\n    /**\n     * Perform a bulkWrite operation without a fluent API\n     *\n     * Legal operation types are\n     * - `insertOne`\n     * - `replaceOne`\n     * - `updateOne`\n     * - `updateMany`\n     * - `deleteOne`\n     * - `deleteMany`\n     *\n     * If documents passed in do not contain the **_id** field,\n     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n     * can be overridden by setting the **forceServerObjectId** flag.\n     *\n     * @param operations - Bulk operations to perform\n     * @param options - Optional settings for the command\n     * @throws MongoDriverError if operations is not an array\n     */\n  }, {\n    key: \"bulkWrite\",\n    value: function () {\n      var _bulkWrite = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(operations, options) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (Array.isArray(operations)) {\n                _context3.next = 2;\n                break;\n              }\n              throw new error_1.MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n            case 2:\n              return _context3.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options !== null && options !== void 0 ? options : {\n                ordered: true\n              }))));\n            case 3:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function bulkWrite(_x5, _x6) {\n        return _bulkWrite.apply(this, arguments);\n      }\n      return bulkWrite;\n    }()\n    /**\n     * Update a single document in a collection\n     *\n     * @param filter - The filter used to select the document to update\n     * @param update - The update operations to be applied to the document\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"updateOne\",\n    value: function () {\n      var _updateOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(filter, update, options) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              return _context4.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options))));\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function updateOne(_x7, _x8, _x9) {\n        return _updateOne.apply(this, arguments);\n      }\n      return updateOne;\n    }()\n    /**\n     * Replace a document in a collection with another document\n     *\n     * @param filter - The filter used to select the document to replace\n     * @param replacement - The Document that replaces the matching document\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"replaceOne\",\n    value: function () {\n      var _replaceOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(filter, replacement, options) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new update_2.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options))));\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function replaceOne(_x10, _x11, _x12) {\n        return _replaceOne.apply(this, arguments);\n      }\n      return replaceOne;\n    }()\n    /**\n     * Update multiple documents in a collection\n     *\n     * @param filter - The filter used to select the documents to update\n     * @param update - The update operations to be applied to the documents\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"updateMany\",\n    value: function () {\n      var _updateMany = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(filter, update, options) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options))));\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function updateMany(_x13, _x14, _x15) {\n        return _updateMany.apply(this, arguments);\n      }\n      return updateMany;\n    }()\n    /**\n     * Delete a document from a collection\n     *\n     * @param filter - The filter used to select the document to remove\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"deleteOne\",\n    value: function () {\n      var _deleteOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var filter,\n          options,\n          _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              filter = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};\n              options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n              return _context7.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options))));\n            case 3:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function deleteOne() {\n        return _deleteOne.apply(this, arguments);\n      }\n      return deleteOne;\n    }()\n    /**\n     * Delete multiple documents from a collection\n     *\n     * @param filter - The filter used to select the documents to remove\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"deleteMany\",\n    value: function () {\n      var _deleteMany = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var filter,\n          options,\n          _args8 = arguments;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              filter = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};\n              options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n              return _context8.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options))));\n            case 3:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function deleteMany() {\n        return _deleteMany.apply(this, arguments);\n      }\n      return deleteMany;\n    }()\n    /**\n     * Rename the collection.\n     *\n     * @remarks\n     * This operation does not inherit options from the Db or MongoClient.\n     *\n     * @param newName - New name of of the collection.\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"rename\",\n    value: function () {\n      var _rename = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(newName, options) {\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              return _context9.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this, newName, _objectSpread(_objectSpread({}, options), {}, {\n                readPreference: read_preference_1.ReadPreference.PRIMARY\n              }))));\n            case 1:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function rename(_x16, _x17) {\n        return _rename.apply(this, arguments);\n      }\n      return rename;\n    }()\n    /**\n     * Drop the collection from the database, removing it permanently. New accesses will create a new collection.\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"drop\",\n    value: function () {\n      var _drop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(options) {\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              return _context10.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options)));\n            case 1:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function drop(_x18) {\n        return _drop.apply(this, arguments);\n      }\n      return drop;\n    }()\n  }, {\n    key: \"findOne\",\n    value: function () {\n      var _findOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var filter,\n          options,\n          _args11 = arguments;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              filter = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};\n              options = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : {};\n              return _context11.abrupt(\"return\", this.find(filter, options).limit(-1).batchSize(1).next());\n            case 3:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function findOne() {\n        return _findOne.apply(this, arguments);\n      }\n      return findOne;\n    }()\n  }, {\n    key: \"find\",\n    value: function find() {\n      var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new find_cursor_1.FindCursor(this.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Returns the options of the collection.\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"options\",\n    value: function () {\n      var _options2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_options) {\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              return _context12.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, _options))));\n            case 1:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function options(_x19) {\n        return _options2.apply(this, arguments);\n      }\n      return options;\n    }()\n    /**\n     * Returns if the collection is a capped collection\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"isCapped\",\n    value: function () {\n      var _isCapped = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(options) {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              return _context13.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options))));\n            case 1:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function isCapped(_x20) {\n        return _isCapped.apply(this, arguments);\n      }\n      return isCapped;\n    }()\n    /**\n     * Creates an index on the db and collection collection.\n     *\n     * @param indexSpec - The field name or index specification to create an index for\n     * @param options - Optional settings for the command\n     *\n     * @example\n     * ```ts\n     * const collection = client.db('foo').collection('bar');\n     *\n     * await collection.createIndex({ a: 1, b: -1 });\n     *\n     * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes\n     * await collection.createIndex([ [c, 1], [d, -1] ]);\n     *\n     * // Equivalent to { e: 1 }\n     * await collection.createIndex('e');\n     *\n     * // Equivalent to { f: 1, g: 1 }\n     * await collection.createIndex(['f', 'g'])\n     *\n     * // Equivalent to { h: 1, i: -1 }\n     * await collection.createIndex([ { h: 1 }, { i: -1 } ]);\n     *\n     * // Equivalent to { j: 1, k: -1, l: 2d }\n     * await collection.createIndex(['j', ['k', -1], { l: '2d' }])\n     * ```\n     */\n  }, {\n    key: \"createIndex\",\n    value: function () {\n      var _createIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(indexSpec, options) {\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              return _context14.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options))));\n            case 1:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function createIndex(_x21, _x22) {\n        return _createIndex.apply(this, arguments);\n      }\n      return createIndex;\n    }()\n    /**\n     * Creates multiple indexes in the collection, this method is only supported for\n     * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n     * error.\n     *\n     * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.\n     * Index specifications are defined {@link https://www.mongodb.com/docs/manual/reference/command/createIndexes/| here}.\n     *\n     * @param indexSpecs - An array of index specifications to be created\n     * @param options - Optional settings for the command\n     *\n     * @example\n     * ```ts\n     * const collection = client.db('foo').collection('bar');\n     * await collection.createIndexes([\n     *   // Simple index on field fizz\n     *   {\n     *     key: { fizz: 1 },\n     *   }\n     *   // wildcard index\n     *   {\n     *     key: { '$**': 1 }\n     *   },\n     *   // named index on darmok and jalad\n     *   {\n     *     key: { darmok: 1, jalad: -1 }\n     *     name: 'tanagra'\n     *   }\n     * ]);\n     * ```\n     */\n  }, {\n    key: \"createIndexes\",\n    value: function () {\n      var _createIndexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(indexSpecs, options) {\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              return _context15.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, _objectSpread(_objectSpread({}, options), {}, {\n                maxTimeMS: undefined\n              })))));\n            case 1:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n      function createIndexes(_x23, _x24) {\n        return _createIndexes.apply(this, arguments);\n      }\n      return createIndexes;\n    }()\n    /**\n     * Drops an index from this collection.\n     *\n     * @param indexName - Name of the index to drop.\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"dropIndex\",\n    value: function () {\n      var _dropIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(indexName, options) {\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              return _context16.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, indexName, _objectSpread(_objectSpread({}, (0, utils_1.resolveOptions)(this, options)), {}, {\n                readPreference: read_preference_1.ReadPreference.primary\n              }))));\n            case 1:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function dropIndex(_x25, _x26) {\n        return _dropIndex.apply(this, arguments);\n      }\n      return dropIndex;\n    }()\n    /**\n     * Drops all indexes from this collection.\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"dropIndexes\",\n    value: function () {\n      var _dropIndexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(options) {\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              _context17.prev = 0;\n              _context17.next = 3;\n              return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, '*', (0, utils_1.resolveOptions)(this, options)));\n            case 3:\n              return _context17.abrupt(\"return\", true);\n            case 6:\n              _context17.prev = 6;\n              _context17.t0 = _context17[\"catch\"](0);\n              return _context17.abrupt(\"return\", false);\n            case 9:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this, [[0, 6]]);\n      }));\n      function dropIndexes(_x27) {\n        return _dropIndexes.apply(this, arguments);\n      }\n      return dropIndexes;\n    }()\n    /**\n     * Get the list of all indexes information for the collection.\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"listIndexes\",\n    value: function listIndexes(options) {\n      return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Checks if one or more indexes exist on the collection, fails on first non-existing index\n     *\n     * @param indexes - One or more index names to check.\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"indexExists\",\n    value: function () {\n      var _indexExists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(indexes, options) {\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              return _context18.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexExistsOperation(this, indexes, (0, utils_1.resolveOptions)(this, options))));\n            case 1:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n      function indexExists(_x28, _x29) {\n        return _indexExists.apply(this, arguments);\n      }\n      return indexExists;\n    }()\n    /**\n     * Retrieves this collections index info.\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"indexInformation\",\n    value: function () {\n      var _indexInformation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(options) {\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              return _context19.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, (0, utils_1.resolveOptions)(this, options))));\n            case 1:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n      function indexInformation(_x30) {\n        return _indexInformation.apply(this, arguments);\n      }\n      return indexInformation;\n    }()\n    /**\n     * Gets an estimate of the count of documents in a collection using collection metadata.\n     * This will always run a count command on all server versions.\n     *\n     * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,\n     * which estimatedDocumentCount uses in its implementation, was not included in v1 of\n     * the Stable API, and so users of the Stable API with estimatedDocumentCount are\n     * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid\n     * encountering errors.\n     *\n     * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"estimatedDocumentCount\",\n    value: function () {\n      var _estimatedDocumentCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(options) {\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              return _context20.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options))));\n            case 1:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this);\n      }));\n      function estimatedDocumentCount(_x31) {\n        return _estimatedDocumentCount.apply(this, arguments);\n      }\n      return estimatedDocumentCount;\n    }()\n    /**\n     * Gets the number of documents matching the filter.\n     * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n     * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}\n     * the following query operators must be replaced:\n     *\n     * | Operator | Replacement |\n     * | -------- | ----------- |\n     * | `$where`   | [`$expr`][1] |\n     * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |\n     * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |\n     *\n     * [1]: https://www.mongodb.com/docs/manual/reference/operator/query/expr/\n     * [2]: https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n     * [3]: https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center\n     * [4]: https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n     *\n     * @param filter - The filter for the count\n     * @param options - Optional settings for the command\n     *\n     * @see https://www.mongodb.com/docs/manual/reference/operator/query/expr/\n     * @see https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n     * @see https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center\n     * @see https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n     */\n  }, {\n    key: \"countDocuments\",\n    value: function () {\n      var _countDocuments = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n        var filter,\n          options,\n          _args21 = arguments;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              filter = _args21.length > 0 && _args21[0] !== undefined ? _args21[0] : {};\n              options = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : {};\n              return _context21.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new count_documents_1.CountDocumentsOperation(this, filter, (0, utils_1.resolveOptions)(this, options))));\n            case 3:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n      function countDocuments() {\n        return _countDocuments.apply(this, arguments);\n      }\n      return countDocuments;\n    }()\n  }, {\n    key: \"distinct\",\n    value: function () {\n      var _distinct = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(key) {\n        var filter,\n          options,\n          _args22 = arguments;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              filter = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : {};\n              options = _args22.length > 2 && _args22[2] !== undefined ? _args22[2] : {};\n              return _context22.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options))));\n            case 3:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n      function distinct(_x32) {\n        return _distinct.apply(this, arguments);\n      }\n      return distinct;\n    }()\n    /**\n     * Retrieve all the indexes on the collection.\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"indexes\",\n    value: function () {\n      var _indexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(options) {\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              return _context23.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexesOperation(this, (0, utils_1.resolveOptions)(this, options))));\n            case 1:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this);\n      }));\n      function indexes(_x33) {\n        return _indexes.apply(this, arguments);\n      }\n      return indexes;\n    }()\n  }, {\n    key: \"findOneAndDelete\",\n    value: function () {\n      var _findOneAndDelete = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(filter, options) {\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              return _context24.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options))));\n            case 1:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this);\n      }));\n      function findOneAndDelete(_x34, _x35) {\n        return _findOneAndDelete.apply(this, arguments);\n      }\n      return findOneAndDelete;\n    }()\n  }, {\n    key: \"findOneAndReplace\",\n    value: function () {\n      var _findOneAndReplace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(filter, replacement, options) {\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              return _context25.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options))));\n            case 1:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this);\n      }));\n      function findOneAndReplace(_x36, _x37, _x38) {\n        return _findOneAndReplace.apply(this, arguments);\n      }\n      return findOneAndReplace;\n    }()\n  }, {\n    key: \"findOneAndUpdate\",\n    value: function () {\n      var _findOneAndUpdate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(filter, update, options) {\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              return _context26.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options))));\n            case 1:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this);\n      }));\n      function findOneAndUpdate(_x39, _x40, _x41) {\n        return _findOneAndUpdate.apply(this, arguments);\n      }\n      return findOneAndUpdate;\n    }()\n    /**\n     * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n     *\n     * @param pipeline - An array of aggregation pipelines to execute\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"aggregate\",\n    value: function aggregate() {\n      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var options = arguments.length > 1 ? arguments[1] : undefined;\n      if (!Array.isArray(pipeline)) {\n        throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must be an array of aggregation stages');\n      }\n      return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n     *\n     * @remarks\n     * watch() accepts two generic arguments for distinct use cases:\n     * - The first is to override the schema that may be defined for this specific collection\n     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n     * @example\n     * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`\n     * ```ts\n     * collection.watch<{ _id: number }>()\n     *   .on('change', change => console.log(change._id.toFixed(4)));\n     * ```\n     *\n     * @example\n     * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.\n     * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.\n     * No need start from scratch on the ChangeStreamInsertDocument type!\n     * By using an intersection we can save time and ensure defaults remain the same type!\n     * ```ts\n     * collection\n     *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([\n     *     { $addFields: { comment: 'big changes' } },\n     *     { $match: { operationType: 'insert' } }\n     *   ])\n     *   .on('change', change => {\n     *     change.comment.startsWith('big');\n     *     change.operationType === 'insert';\n     *     // No need to narrow in code because the generics did that for us!\n     *     expectType<Schema>(change.fullDocument);\n     *   });\n     * ```\n     *\n     * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n     * @param options - Optional settings for the command\n     * @typeParam TLocal - Type of the data being detected by the change stream\n     * @typeParam TChange - Type of the whole change stream document emitted\n     */\n  }, {\n    key: \"watch\",\n    value: function watch() {\n      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // Allow optionally not specifying a pipeline\n      if (!Array.isArray(pipeline)) {\n        options = pipeline;\n        pipeline = [];\n      }\n      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n     *\n     * @throws MongoNotConnectedError\n     * @remarks\n     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n     */\n  }, {\n    key: \"initializeUnorderedBulkOp\",\n    value: function initializeUnorderedBulkOp(options) {\n      return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n     *\n     * @throws MongoNotConnectedError\n     * @remarks\n     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n     */\n  }, {\n    key: \"initializeOrderedBulkOp\",\n    value: function initializeOrderedBulkOp(options) {\n      return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * An estimated count of matching documents in the db to a filter.\n     *\n     * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents\n     * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.\n     * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n     *\n     * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead\n     *\n     * @param filter - The filter for the count.\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"count\",\n    value: function () {\n      var _count = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {\n        var filter,\n          options,\n          _args27 = arguments;\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              filter = _args27.length > 0 && _args27[0] !== undefined ? _args27[0] : {};\n              options = _args27.length > 1 && _args27[1] !== undefined ? _args27[1] : {};\n              return _context27.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.fullNamespace, filter, (0, utils_1.resolveOptions)(this, options))));\n            case 3:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee27, this);\n      }));\n      function count() {\n        return _count.apply(this, arguments);\n      }\n      return count;\n    }()\n  }, {\n    key: \"listSearchIndexes\",\n    value: function listSearchIndexes(indexNameOrOptions, options) {\n      options = typeof indexNameOrOptions === 'object' ? indexNameOrOptions : options == null ? {} : options;\n      var indexName = indexNameOrOptions == null ? null : typeof indexNameOrOptions === 'object' ? null : indexNameOrOptions;\n      return new list_search_indexes_cursor_1.ListSearchIndexesCursor(this, indexName, options);\n    }\n    /**\n     * Creates a single search index for the collection.\n     *\n     * @param description - The index description for the new search index.\n     * @returns A promise that resolves to the name of the new search index.\n     *\n     * @remarks Only available when used against a 7.0+ Atlas cluster.\n     */\n  }, {\n    key: \"createSearchIndex\",\n    value: function () {\n      var _createSearchIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(description) {\n        var _yield$this$createSea, _yield$this$createSea2, index;\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) switch (_context28.prev = _context28.next) {\n            case 0:\n              _context28.next = 2;\n              return this.createSearchIndexes([description]);\n            case 2:\n              _yield$this$createSea = _context28.sent;\n              _yield$this$createSea2 = _slicedToArray(_yield$this$createSea, 1);\n              index = _yield$this$createSea2[0];\n              return _context28.abrupt(\"return\", index);\n            case 6:\n            case \"end\":\n              return _context28.stop();\n          }\n        }, _callee28, this);\n      }));\n      function createSearchIndex(_x42) {\n        return _createSearchIndex.apply(this, arguments);\n      }\n      return createSearchIndex;\n    }()\n    /**\n     * Creates multiple search indexes for the current collection.\n     *\n     * @param descriptions - An array of `SearchIndexDescription`s for the new search indexes.\n     * @returns A promise that resolves to an array of the newly created search index names.\n     *\n     * @remarks Only available when used against a 7.0+ Atlas cluster.\n     * @returns\n     */\n  }, {\n    key: \"createSearchIndexes\",\n    value: function () {\n      var _createSearchIndexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(descriptions) {\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) switch (_context29.prev = _context29.next) {\n            case 0:\n              return _context29.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new create_1.CreateSearchIndexesOperation(this, descriptions)));\n            case 1:\n            case \"end\":\n              return _context29.stop();\n          }\n        }, _callee29, this);\n      }));\n      function createSearchIndexes(_x43) {\n        return _createSearchIndexes.apply(this, arguments);\n      }\n      return createSearchIndexes;\n    }()\n    /**\n     * Deletes a search index by index name.\n     *\n     * @param name - The name of the search index to be deleted.\n     *\n     * @remarks Only available when used against a 7.0+ Atlas cluster.\n     */\n  }, {\n    key: \"dropSearchIndex\",\n    value: function () {\n      var _dropSearchIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(name) {\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) switch (_context30.prev = _context30.next) {\n            case 0:\n              return _context30.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new drop_2.DropSearchIndexOperation(this, name)));\n            case 1:\n            case \"end\":\n              return _context30.stop();\n          }\n        }, _callee30, this);\n      }));\n      function dropSearchIndex(_x44) {\n        return _dropSearchIndex.apply(this, arguments);\n      }\n      return dropSearchIndex;\n    }()\n    /**\n     * Updates a search index by replacing the existing index definition with the provided definition.\n     *\n     * @param name - The name of the search index to update.\n     * @param definition - The new search index definition.\n     *\n     * @remarks Only available when used against a 7.0+ Atlas cluster.\n     */\n  }, {\n    key: \"updateSearchIndex\",\n    value: function () {\n      var _updateSearchIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(name, definition) {\n        return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n          while (1) switch (_context31.prev = _context31.next) {\n            case 0:\n              return _context31.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new update_1.UpdateSearchIndexOperation(this, name, definition)));\n            case 1:\n            case \"end\":\n              return _context31.stop();\n          }\n        }, _callee31, this);\n      }));\n      function updateSearchIndex(_x45, _x46) {\n        return _updateSearchIndex.apply(this, arguments);\n      }\n      return updateSearchIndex;\n    }()\n  }]);\n  return Collection;\n}();\nexports.Collection = Collection;","map":{"version":3,"names":["bson_1","require","ordered_1","unordered_1","change_stream_1","aggregation_cursor_1","find_cursor_1","list_indexes_cursor_1","list_search_indexes_cursor_1","error_1","bulk_write_1","count_1","count_documents_1","delete_1","distinct_1","drop_1","estimated_document_count_1","execute_operation_1","find_and_modify_1","indexes_1","insert_1","is_capped_1","options_operation_1","rename_1","create_1","drop_2","update_1","update_2","read_concern_1","read_preference_1","utils_1","write_concern_1","Collection","db","name","options","_db$options$pkFactory","_db$options","_classCallCheck","checkCollectionName","s","namespace","MongoDBCollectionNamespace","databaseName","pkFactory","DEFAULT_PK_FACTORY","readPreference","ReadPreference","fromOptions","bsonOptions","resolveBSONOptions","readConcern","ReadConcern","writeConcern","WriteConcern","client","_createClass","key","get","collection","fullNamespace","toString","collectionHint","set","v","normalizeHintField","value","_insertOne","_asyncToGenerator","_regeneratorRuntime","mark","_callee","doc","wrap","_callee$","_context","prev","next","abrupt","executeOperation","InsertOneOperation","resolveOptions","stop","insertOne","_x","_x2","apply","arguments","_insertMany","_callee2","docs","_callee2$","_context2","InsertManyOperation","ordered","insertMany","_x3","_x4","_bulkWrite","_callee3","operations","_callee3$","_context3","Array","isArray","MongoInvalidArgumentError","BulkWriteOperation","bulkWrite","_x5","_x6","_updateOne","_callee4","filter","update","_callee4$","_context4","UpdateOneOperation","updateOne","_x7","_x8","_x9","_replaceOne","_callee5","replacement","_callee5$","_context5","ReplaceOneOperation","replaceOne","_x10","_x11","_x12","_updateMany","_callee6","_callee6$","_context6","UpdateManyOperation","updateMany","_x13","_x14","_x15","_deleteOne","_callee7","_args7","_callee7$","_context7","length","undefined","DeleteOneOperation","deleteOne","_deleteMany","_callee8","_args8","_callee8$","_context8","DeleteManyOperation","deleteMany","_rename","_callee9","newName","_callee9$","_context9","RenameOperation","_objectSpread","PRIMARY","rename","_x16","_x17","_drop","_callee10","_callee10$","_context10","DropCollectionOperation","collectionName","drop","_x18","_findOne","_callee11","_args11","_callee11$","_context11","find","limit","batchSize","findOne","FindCursor","_options2","_callee12","_callee12$","_context12","OptionsOperation","_x19","_isCapped","_callee13","_callee13$","_context13","IsCappedOperation","isCapped","_x20","_createIndex","_callee14","indexSpec","_callee14$","_context14","CreateIndexOperation","createIndex","_x21","_x22","_createIndexes","_callee15","indexSpecs","_callee15$","_context15","CreateIndexesOperation","maxTimeMS","createIndexes","_x23","_x24","_dropIndex","_callee16","indexName","_callee16$","_context16","DropIndexOperation","primary","dropIndex","_x25","_x26","_dropIndexes","_callee17","_callee17$","_context17","t0","dropIndexes","_x27","listIndexes","ListIndexesCursor","_indexExists","_callee18","indexes","_callee18$","_context18","IndexExistsOperation","indexExists","_x28","_x29","_indexInformation","_callee19","_callee19$","_context19","IndexInformationOperation","indexInformation","_x30","_estimatedDocumentCount","_callee20","_callee20$","_context20","EstimatedDocumentCountOperation","estimatedDocumentCount","_x31","_countDocuments","_callee21","_args21","_callee21$","_context21","CountDocumentsOperation","countDocuments","_distinct","_callee22","_args22","_callee22$","_context22","DistinctOperation","distinct","_x32","_indexes","_callee23","_callee23$","_context23","IndexesOperation","_x33","_findOneAndDelete","_callee24","_callee24$","_context24","FindOneAndDeleteOperation","findOneAndDelete","_x34","_x35","_findOneAndReplace","_callee25","_callee25$","_context25","FindOneAndReplaceOperation","findOneAndReplace","_x36","_x37","_x38","_findOneAndUpdate","_callee26","_callee26$","_context26","FindOneAndUpdateOperation","findOneAndUpdate","_x39","_x40","_x41","aggregate","pipeline","AggregationCursor","watch","ChangeStream","initializeUnorderedBulkOp","UnorderedBulkOperation","initializeOrderedBulkOp","OrderedBulkOperation","_count","_callee27","_args27","_callee27$","_context27","CountOperation","count","listSearchIndexes","indexNameOrOptions","ListSearchIndexesCursor","_createSearchIndex","_callee28","description","_yield$this$createSea","_yield$this$createSea2","index","_callee28$","_context28","createSearchIndexes","sent","_slicedToArray","createSearchIndex","_x42","_createSearchIndexes","_callee29","descriptions","_callee29$","_context29","CreateSearchIndexesOperation","_x43","_dropSearchIndex","_callee30","_callee30$","_context30","DropSearchIndexOperation","dropSearchIndex","_x44","_updateSearchIndex","_callee31","definition","_callee31$","_context31","UpdateSearchIndexOperation","updateSearchIndex","_x45","_x46","exports"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\collection.ts"],"sourcesContent":["import { type BSONSerializeOptions, type Document, resolveBSONOptions } from './bson';\nimport type { AnyBulkWriteOperation, BulkWriteOptions, BulkWriteResult } from './bulk/common';\nimport { OrderedBulkOperation } from './bulk/ordered';\nimport { UnorderedBulkOperation } from './bulk/unordered';\nimport { ChangeStream, type ChangeStreamDocument, type ChangeStreamOptions } from './change_stream';\nimport { AggregationCursor } from './cursor/aggregation_cursor';\nimport { FindCursor } from './cursor/find_cursor';\nimport { ListIndexesCursor } from './cursor/list_indexes_cursor';\nimport {\n  ListSearchIndexesCursor,\n  type ListSearchIndexesOptions\n} from './cursor/list_search_indexes_cursor';\nimport type { Db } from './db';\nimport { MongoInvalidArgumentError } from './error';\nimport type { MongoClient, PkFactory } from './mongo_client';\nimport type {\n  Filter,\n  Flatten,\n  OptionalUnlessRequiredId,\n  TODO_NODE_3286,\n  UpdateFilter,\n  WithId,\n  WithoutId\n} from './mongo_types';\nimport type { AggregateOptions } from './operations/aggregate';\nimport { BulkWriteOperation } from './operations/bulk_write';\nimport type { IndexInformationOptions } from './operations/common_functions';\nimport { CountOperation, type CountOptions } from './operations/count';\nimport { CountDocumentsOperation, type CountDocumentsOptions } from './operations/count_documents';\nimport {\n  DeleteManyOperation,\n  DeleteOneOperation,\n  type DeleteOptions,\n  type DeleteResult\n} from './operations/delete';\nimport { DistinctOperation, type DistinctOptions } from './operations/distinct';\nimport { DropCollectionOperation, type DropCollectionOptions } from './operations/drop';\nimport {\n  EstimatedDocumentCountOperation,\n  type EstimatedDocumentCountOptions\n} from './operations/estimated_document_count';\nimport { executeOperation } from './operations/execute_operation';\nimport type { FindOptions } from './operations/find';\nimport {\n  FindOneAndDeleteOperation,\n  type FindOneAndDeleteOptions,\n  FindOneAndReplaceOperation,\n  type FindOneAndReplaceOptions,\n  FindOneAndUpdateOperation,\n  type FindOneAndUpdateOptions\n} from './operations/find_and_modify';\nimport {\n  CreateIndexesOperation,\n  type CreateIndexesOptions,\n  CreateIndexOperation,\n  type DropIndexesOptions,\n  DropIndexOperation,\n  type IndexDescription,\n  IndexesOperation,\n  IndexExistsOperation,\n  IndexInformationOperation,\n  type IndexSpecification,\n  type ListIndexesOptions\n} from './operations/indexes';\nimport {\n  InsertManyOperation,\n  type InsertManyResult,\n  InsertOneOperation,\n  type InsertOneOptions,\n  type InsertOneResult\n} from './operations/insert';\nimport { IsCappedOperation } from './operations/is_capped';\nimport type { Hint, OperationOptions } from './operations/operation';\nimport { OptionsOperation } from './operations/options_operation';\nimport { RenameOperation, type RenameOptions } from './operations/rename';\nimport {\n  CreateSearchIndexesOperation,\n  type SearchIndexDescription\n} from './operations/search_indexes/create';\nimport { DropSearchIndexOperation } from './operations/search_indexes/drop';\nimport { UpdateSearchIndexOperation } from './operations/search_indexes/update';\nimport {\n  ReplaceOneOperation,\n  type ReplaceOptions,\n  UpdateManyOperation,\n  UpdateOneOperation,\n  type UpdateOptions,\n  type UpdateResult\n} from './operations/update';\nimport { ReadConcern, type ReadConcernLike } from './read_concern';\nimport { ReadPreference, type ReadPreferenceLike } from './read_preference';\nimport {\n  checkCollectionName,\n  DEFAULT_PK_FACTORY,\n  MongoDBCollectionNamespace,\n  normalizeHintField,\n  resolveOptions\n} from './utils';\nimport { WriteConcern, type WriteConcernOptions } from './write_concern';\n\n/** @public */\nexport interface ModifyResult<TSchema = Document> {\n  value: WithId<TSchema> | null;\n  lastErrorObject?: Document;\n  ok: 0 | 1;\n}\n\n/** @public */\nexport interface CollectionOptions extends BSONSerializeOptions, WriteConcernOptions {\n  /** Specify a read concern for the collection. (only MongoDB 3.2 or higher supported) */\n  readConcern?: ReadConcernLike;\n  /** The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST). */\n  readPreference?: ReadPreferenceLike;\n}\n\n/** @internal */\nexport interface CollectionPrivate {\n  pkFactory: PkFactory;\n  db: Db;\n  options: any;\n  namespace: MongoDBCollectionNamespace;\n  readPreference?: ReadPreference;\n  bsonOptions: BSONSerializeOptions;\n  collectionHint?: Hint;\n  readConcern?: ReadConcern;\n  writeConcern?: WriteConcern;\n}\n\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/find/update/delete and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * interface Pet {\n *   name: string;\n *   kind: 'dog' | 'cat' | 'fish';\n * }\n *\n * const client = new MongoClient('mongodb://localhost:27017');\n * const pets = client.db().collection<Pet>('pets');\n *\n * const petCursor = pets.find();\n *\n * for await (const pet of petCursor) {\n *   console.log(`${pet.name} is a ${pet.kind}!`);\n * }\n * ```\n */\nexport class Collection<TSchema extends Document = Document> {\n  /** @internal */\n  s: CollectionPrivate;\n\n  /** @internal */\n  client: MongoClient;\n\n  /**\n   * Create a new Collection instance\n   * @internal\n   */\n  constructor(db: Db, name: string, options?: CollectionOptions) {\n    checkCollectionName(name);\n\n    // Internal state\n    this.s = {\n      db,\n      options,\n      namespace: new MongoDBCollectionNamespace(db.databaseName, name),\n      pkFactory: db.options?.pkFactory ?? DEFAULT_PK_FACTORY,\n      readPreference: ReadPreference.fromOptions(options),\n      bsonOptions: resolveBSONOptions(options, db),\n      readConcern: ReadConcern.fromOptions(options),\n      writeConcern: WriteConcern.fromOptions(options)\n    };\n\n    this.client = db.client;\n  }\n\n  /**\n   * The name of the database this collection belongs to\n   */\n  get dbName(): string {\n    return this.s.namespace.db;\n  }\n\n  /**\n   * The name of this collection\n   */\n  get collectionName(): string {\n    return this.s.namespace.collection;\n  }\n\n  /**\n   * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n   */\n  get namespace(): string {\n    return this.fullNamespace.toString();\n  }\n\n  /**\n   *  @internal\n   *\n   * The `MongoDBNamespace` for the collection.\n   */\n  get fullNamespace(): MongoDBCollectionNamespace {\n    return this.s.namespace;\n  }\n\n  /**\n   * The current readConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readConcern(): ReadConcern | undefined {\n    if (this.s.readConcern == null) {\n      return this.s.db.readConcern;\n    }\n    return this.s.readConcern;\n  }\n\n  /**\n   * The current readPreference of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readPreference(): ReadPreference | undefined {\n    if (this.s.readPreference == null) {\n      return this.s.db.readPreference;\n    }\n\n    return this.s.readPreference;\n  }\n\n  get bsonOptions(): BSONSerializeOptions {\n    return this.s.bsonOptions;\n  }\n\n  /**\n   * The current writeConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get writeConcern(): WriteConcern | undefined {\n    if (this.s.writeConcern == null) {\n      return this.s.db.writeConcern;\n    }\n    return this.s.writeConcern;\n  }\n\n  /** The current index hint for the collection */\n  get hint(): Hint | undefined {\n    return this.s.collectionHint;\n  }\n\n  set hint(v: Hint | undefined) {\n    this.s.collectionHint = normalizeHintField(v);\n  }\n\n  /**\n   * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param doc - The document to insert\n   * @param options - Optional settings for the command\n   */\n  async insertOne(\n    doc: OptionalUnlessRequiredId<TSchema>,\n    options?: InsertOneOptions\n  ): Promise<InsertOneResult<TSchema>> {\n    return executeOperation(\n      this.client,\n      new InsertOneOperation(\n        this as TODO_NODE_3286,\n        doc,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param docs - The documents to insert\n   * @param options - Optional settings for the command\n   */\n  async insertMany(\n    docs: OptionalUnlessRequiredId<TSchema>[],\n    options?: BulkWriteOptions\n  ): Promise<InsertManyResult<TSchema>> {\n    return executeOperation(\n      this.client,\n      new InsertManyOperation(\n        this as TODO_NODE_3286,\n        docs,\n        resolveOptions(this, options ?? { ordered: true })\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Perform a bulkWrite operation without a fluent API\n   *\n   * Legal operation types are\n   * - `insertOne`\n   * - `replaceOne`\n   * - `updateOne`\n   * - `updateMany`\n   * - `deleteOne`\n   * - `deleteMany`\n   *\n   * If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param operations - Bulk operations to perform\n   * @param options - Optional settings for the command\n   * @throws MongoDriverError if operations is not an array\n   */\n  async bulkWrite(\n    operations: AnyBulkWriteOperation<TSchema>[],\n    options?: BulkWriteOptions\n  ): Promise<BulkWriteResult> {\n    if (!Array.isArray(operations)) {\n      throw new MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n    }\n\n    return executeOperation(\n      this.client,\n      new BulkWriteOperation(\n        this as TODO_NODE_3286,\n        operations as TODO_NODE_3286,\n        resolveOptions(this, options ?? { ordered: true })\n      )\n    );\n  }\n\n  /**\n   * Update a single document in a collection\n   *\n   * @param filter - The filter used to select the document to update\n   * @param update - The update operations to be applied to the document\n   * @param options - Optional settings for the command\n   */\n  async updateOne(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema> | Partial<TSchema>,\n    options?: UpdateOptions\n  ): Promise<UpdateResult<TSchema>> {\n    return executeOperation(\n      this.client,\n      new UpdateOneOperation(\n        this as TODO_NODE_3286,\n        filter,\n        update,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Replace a document in a collection with another document\n   *\n   * @param filter - The filter used to select the document to replace\n   * @param replacement - The Document that replaces the matching document\n   * @param options - Optional settings for the command\n   */\n  async replaceOne(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    options?: ReplaceOptions\n  ): Promise<UpdateResult<TSchema> | Document> {\n    return executeOperation(\n      this.client,\n      new ReplaceOneOperation(\n        this as TODO_NODE_3286,\n        filter,\n        replacement,\n        resolveOptions(this, options)\n      )\n    );\n  }\n\n  /**\n   * Update multiple documents in a collection\n   *\n   * @param filter - The filter used to select the documents to update\n   * @param update - The update operations to be applied to the documents\n   * @param options - Optional settings for the command\n   */\n  async updateMany(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options?: UpdateOptions\n  ): Promise<UpdateResult<TSchema>> {\n    return executeOperation(\n      this.client,\n      new UpdateManyOperation(\n        this as TODO_NODE_3286,\n        filter,\n        update,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Delete a document from a collection\n   *\n   * @param filter - The filter used to select the document to remove\n   * @param options - Optional settings for the command\n   */\n  async deleteOne(\n    filter: Filter<TSchema> = {},\n    options: DeleteOptions = {}\n  ): Promise<DeleteResult> {\n    return executeOperation(\n      this.client,\n      new DeleteOneOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Delete multiple documents from a collection\n   *\n   * @param filter - The filter used to select the documents to remove\n   * @param options - Optional settings for the command\n   */\n  async deleteMany(\n    filter: Filter<TSchema> = {},\n    options: DeleteOptions = {}\n  ): Promise<DeleteResult> {\n    return executeOperation(\n      this.client,\n      new DeleteManyOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Rename the collection.\n   *\n   * @remarks\n   * This operation does not inherit options from the Db or MongoClient.\n   *\n   * @param newName - New name of of the collection.\n   * @param options - Optional settings for the command\n   */\n  async rename(newName: string, options?: RenameOptions): Promise<Collection> {\n    // Intentionally, we do not inherit options from parent for this operation.\n    return executeOperation(\n      this.client,\n      new RenameOperation(this as TODO_NODE_3286, newName, {\n        ...options,\n        readPreference: ReadPreference.PRIMARY\n      }) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Drop the collection from the database, removing it permanently. New accesses will create a new collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  async drop(options?: DropCollectionOptions): Promise<boolean> {\n    return executeOperation(\n      this.client,\n      new DropCollectionOperation(this.s.db, this.collectionName, options)\n    );\n  }\n\n  /**\n   * Fetches the first document that matches the filter\n   *\n   * @param filter - Query for find Operation\n   * @param options - Optional settings for the command\n   */\n  async findOne(): Promise<WithId<TSchema> | null>;\n  async findOne(filter: Filter<TSchema>): Promise<WithId<TSchema> | null>;\n  async findOne(filter: Filter<TSchema>, options: FindOptions): Promise<WithId<TSchema> | null>;\n\n  // allow an override of the schema.\n  async findOne<T = TSchema>(): Promise<T | null>;\n  async findOne<T = TSchema>(filter: Filter<TSchema>): Promise<T | null>;\n  async findOne<T = TSchema>(filter: Filter<TSchema>, options?: FindOptions): Promise<T | null>;\n\n  async findOne(\n    filter: Filter<TSchema> = {},\n    options: FindOptions = {}\n  ): Promise<WithId<TSchema> | null> {\n    return this.find(filter, options).limit(-1).batchSize(1).next();\n  }\n\n  /**\n   * Creates a cursor for a filter that can be used to iterate over results from MongoDB\n   *\n   * @param filter - The filter predicate. If unspecified, then all documents in the collection will match the predicate\n   */\n  find(): FindCursor<WithId<TSchema>>;\n  find(filter: Filter<TSchema>, options?: FindOptions): FindCursor<WithId<TSchema>>;\n  find<T extends Document>(filter: Filter<TSchema>, options?: FindOptions): FindCursor<T>;\n  find(filter: Filter<TSchema> = {}, options: FindOptions = {}): FindCursor<WithId<TSchema>> {\n    return new FindCursor<WithId<TSchema>>(\n      this.client,\n      this.s.namespace,\n      filter,\n      resolveOptions(this as TODO_NODE_3286, options)\n    );\n  }\n\n  /**\n   * Returns the options of the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  async options(options?: OperationOptions): Promise<Document> {\n    return executeOperation(\n      this.client,\n      new OptionsOperation(this as TODO_NODE_3286, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Returns if the collection is a capped collection\n   *\n   * @param options - Optional settings for the command\n   */\n  async isCapped(options?: OperationOptions): Promise<boolean> {\n    return executeOperation(\n      this.client,\n      new IsCappedOperation(this as TODO_NODE_3286, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Creates an index on the db and collection collection.\n   *\n   * @param indexSpec - The field name or index specification to create an index for\n   * @param options - Optional settings for the command\n   *\n   * @example\n   * ```ts\n   * const collection = client.db('foo').collection('bar');\n   *\n   * await collection.createIndex({ a: 1, b: -1 });\n   *\n   * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes\n   * await collection.createIndex([ [c, 1], [d, -1] ]);\n   *\n   * // Equivalent to { e: 1 }\n   * await collection.createIndex('e');\n   *\n   * // Equivalent to { f: 1, g: 1 }\n   * await collection.createIndex(['f', 'g'])\n   *\n   * // Equivalent to { h: 1, i: -1 }\n   * await collection.createIndex([ { h: 1 }, { i: -1 } ]);\n   *\n   * // Equivalent to { j: 1, k: -1, l: 2d }\n   * await collection.createIndex(['j', ['k', -1], { l: '2d' }])\n   * ```\n   */\n  async createIndex(\n    indexSpec: IndexSpecification,\n    options?: CreateIndexesOptions\n  ): Promise<string> {\n    return executeOperation(\n      this.client,\n      new CreateIndexOperation(\n        this as TODO_NODE_3286,\n        this.collectionName,\n        indexSpec,\n        resolveOptions(this, options)\n      )\n    );\n  }\n\n  /**\n   * Creates multiple indexes in the collection, this method is only supported for\n   * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n   * error.\n   *\n   * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.\n   * Index specifications are defined {@link https://www.mongodb.com/docs/manual/reference/command/createIndexes/| here}.\n   *\n   * @param indexSpecs - An array of index specifications to be created\n   * @param options - Optional settings for the command\n   *\n   * @example\n   * ```ts\n   * const collection = client.db('foo').collection('bar');\n   * await collection.createIndexes([\n   *   // Simple index on field fizz\n   *   {\n   *     key: { fizz: 1 },\n   *   }\n   *   // wildcard index\n   *   {\n   *     key: { '$**': 1 }\n   *   },\n   *   // named index on darmok and jalad\n   *   {\n   *     key: { darmok: 1, jalad: -1 }\n   *     name: 'tanagra'\n   *   }\n   * ]);\n   * ```\n   */\n  async createIndexes(\n    indexSpecs: IndexDescription[],\n    options?: CreateIndexesOptions\n  ): Promise<string[]> {\n    return executeOperation(\n      this.client,\n      new CreateIndexesOperation(\n        this as TODO_NODE_3286,\n        this.collectionName,\n        indexSpecs,\n        resolveOptions(this, { ...options, maxTimeMS: undefined })\n      )\n    );\n  }\n\n  /**\n   * Drops an index from this collection.\n   *\n   * @param indexName - Name of the index to drop.\n   * @param options - Optional settings for the command\n   */\n  async dropIndex(indexName: string, options?: DropIndexesOptions): Promise<Document> {\n    return executeOperation(\n      this.client,\n      new DropIndexOperation(this as TODO_NODE_3286, indexName, {\n        ...resolveOptions(this, options),\n        readPreference: ReadPreference.primary\n      })\n    );\n  }\n\n  /**\n   * Drops all indexes from this collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  async dropIndexes(options?: DropIndexesOptions): Promise<boolean> {\n    try {\n      await executeOperation(\n        this.client,\n        new DropIndexOperation(this as TODO_NODE_3286, '*', resolveOptions(this, options))\n      );\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get the list of all indexes information for the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  listIndexes(options?: ListIndexesOptions): ListIndexesCursor {\n    return new ListIndexesCursor(this as TODO_NODE_3286, resolveOptions(this, options));\n  }\n\n  /**\n   * Checks if one or more indexes exist on the collection, fails on first non-existing index\n   *\n   * @param indexes - One or more index names to check.\n   * @param options - Optional settings for the command\n   */\n  async indexExists(\n    indexes: string | string[],\n    options?: IndexInformationOptions\n  ): Promise<boolean> {\n    return executeOperation(\n      this.client,\n      new IndexExistsOperation(this as TODO_NODE_3286, indexes, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Retrieves this collections index info.\n   *\n   * @param options - Optional settings for the command\n   */\n  async indexInformation(options?: IndexInformationOptions): Promise<Document> {\n    return executeOperation(\n      this.client,\n      new IndexInformationOperation(this.s.db, this.collectionName, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Gets an estimate of the count of documents in a collection using collection metadata.\n   * This will always run a count command on all server versions.\n   *\n   * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,\n   * which estimatedDocumentCount uses in its implementation, was not included in v1 of\n   * the Stable API, and so users of the Stable API with estimatedDocumentCount are\n   * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid\n   * encountering errors.\n   *\n   * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}\n   * @param options - Optional settings for the command\n   */\n  async estimatedDocumentCount(options?: EstimatedDocumentCountOptions): Promise<number> {\n    return executeOperation(\n      this.client,\n      new EstimatedDocumentCountOperation(this as TODO_NODE_3286, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Gets the number of documents matching the filter.\n   * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n   * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}\n   * the following query operators must be replaced:\n   *\n   * | Operator | Replacement |\n   * | -------- | ----------- |\n   * | `$where`   | [`$expr`][1] |\n   * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |\n   * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |\n   *\n   * [1]: https://www.mongodb.com/docs/manual/reference/operator/query/expr/\n   * [2]: https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n   * [3]: https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center\n   * [4]: https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n   *\n   * @param filter - The filter for the count\n   * @param options - Optional settings for the command\n   *\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/expr/\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n   */\n  async countDocuments(\n    filter: Document = {},\n    options: CountDocumentsOptions = {}\n  ): Promise<number> {\n    return executeOperation(\n      this.client,\n      new CountDocumentsOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * The distinct command returns a list of distinct values for the given key across a collection.\n   *\n   * @param key - Field of the document to find distinct values for\n   * @param filter - The filter for filtering the set of documents to which we apply the distinct filter.\n   * @param options - Optional settings for the command\n   */\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema>\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema>,\n    options: DistinctOptions\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n\n  // Embedded documents overload\n  distinct(key: string): Promise<any[]>;\n  distinct(key: string, filter: Filter<TSchema>): Promise<any[]>;\n  distinct(key: string, filter: Filter<TSchema>, options: DistinctOptions): Promise<any[]>;\n\n  async distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema> = {},\n    options: DistinctOptions = {}\n  ): Promise<any[]> {\n    return executeOperation(\n      this.client,\n      new DistinctOperation(\n        this as TODO_NODE_3286,\n        key as TODO_NODE_3286,\n        filter,\n        resolveOptions(this, options)\n      )\n    );\n  }\n\n  /**\n   * Retrieve all the indexes on the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  async indexes(options?: IndexInformationOptions): Promise<Document[]> {\n    return executeOperation(\n      this.client,\n      new IndexesOperation(this as TODO_NODE_3286, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Find a document and delete it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to remove\n   * @param options - Optional settings for the command\n   */\n  async findOneAndDelete(\n    filter: Filter<TSchema>,\n    options: FindOneAndDeleteOptions & { includeResultMetadata: true }\n  ): Promise<ModifyResult<TSchema>>;\n  async findOneAndDelete(\n    filter: Filter<TSchema>,\n    options: FindOneAndDeleteOptions & { includeResultMetadata: false }\n  ): Promise<WithId<TSchema> | null>;\n  async findOneAndDelete(\n    filter: Filter<TSchema>,\n    options: FindOneAndDeleteOptions\n  ): Promise<WithId<TSchema> | null>;\n  async findOneAndDelete(filter: Filter<TSchema>): Promise<WithId<TSchema> | null>;\n  async findOneAndDelete(\n    filter: Filter<TSchema>,\n    options?: FindOneAndDeleteOptions\n  ): Promise<WithId<TSchema> | ModifyResult<TSchema> | null> {\n    return executeOperation(\n      this.client,\n      new FindOneAndDeleteOperation(\n        this as TODO_NODE_3286,\n        filter,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Find a document and replace it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to replace\n   * @param replacement - The Document that replaces the matching document\n   * @param options - Optional settings for the command\n   */\n  async findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    options: FindOneAndReplaceOptions & { includeResultMetadata: true }\n  ): Promise<ModifyResult<TSchema>>;\n  async findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    options: FindOneAndReplaceOptions & { includeResultMetadata: false }\n  ): Promise<WithId<TSchema> | null>;\n  async findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    options: FindOneAndReplaceOptions\n  ): Promise<WithId<TSchema> | null>;\n  async findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>\n  ): Promise<WithId<TSchema> | null>;\n  async findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: WithoutId<TSchema>,\n    options?: FindOneAndReplaceOptions\n  ): Promise<WithId<TSchema> | ModifyResult<TSchema> | null> {\n    return executeOperation(\n      this.client,\n      new FindOneAndReplaceOperation(\n        this as TODO_NODE_3286,\n        filter,\n        replacement,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Find a document and update it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to update\n   * @param update - Update operations to be performed on the document\n   * @param options - Optional settings for the command\n   */\n  async findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options: FindOneAndUpdateOptions & { includeResultMetadata: true }\n  ): Promise<ModifyResult<TSchema>>;\n  async findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options: FindOneAndUpdateOptions & { includeResultMetadata: false }\n  ): Promise<WithId<TSchema> | null>;\n  async findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options: FindOneAndUpdateOptions\n  ): Promise<WithId<TSchema> | null>;\n  async findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>\n  ): Promise<WithId<TSchema> | null>;\n  async findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options?: FindOneAndUpdateOptions\n  ): Promise<WithId<TSchema> | ModifyResult<TSchema> | null> {\n    return executeOperation(\n      this.client,\n      new FindOneAndUpdateOperation(\n        this as TODO_NODE_3286,\n        filter,\n        update,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n   *\n   * @param pipeline - An array of aggregation pipelines to execute\n   * @param options - Optional settings for the command\n   */\n  aggregate<T extends Document = Document>(\n    pipeline: Document[] = [],\n    options?: AggregateOptions\n  ): AggregationCursor<T> {\n    if (!Array.isArray(pipeline)) {\n      throw new MongoInvalidArgumentError(\n        'Argument \"pipeline\" must be an array of aggregation stages'\n      );\n    }\n\n    return new AggregationCursor(\n      this.client,\n      this.s.namespace,\n      pipeline,\n      resolveOptions(this, options)\n    );\n  }\n\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n   *\n   * @remarks\n   * watch() accepts two generic arguments for distinct use cases:\n   * - The first is to override the schema that may be defined for this specific collection\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n   * @example\n   * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`\n   * ```ts\n   * collection.watch<{ _id: number }>()\n   *   .on('change', change => console.log(change._id.toFixed(4)));\n   * ```\n   *\n   * @example\n   * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.\n   * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.\n   * No need start from scratch on the ChangeStreamInsertDocument type!\n   * By using an intersection we can save time and ensure defaults remain the same type!\n   * ```ts\n   * collection\n   *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([\n   *     { $addFields: { comment: 'big changes' } },\n   *     { $match: { operationType: 'insert' } }\n   *   ])\n   *   .on('change', change => {\n   *     change.comment.startsWith('big');\n   *     change.operationType === 'insert';\n   *     // No need to narrow in code because the generics did that for us!\n   *     expectType<Schema>(change.fullDocument);\n   *   });\n   * ```\n   *\n   * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   * @typeParam TLocal - Type of the data being detected by the change stream\n   * @typeParam TChange - Type of the whole change stream document emitted\n   */\n  watch<TLocal extends Document = TSchema, TChange extends Document = ChangeStreamDocument<TLocal>>(\n    pipeline: Document[] = [],\n    options: ChangeStreamOptions = {}\n  ): ChangeStream<TLocal, TChange> {\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new ChangeStream<TLocal, TChange>(this, pipeline, resolveOptions(this, options));\n  }\n\n  /**\n   * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n  initializeUnorderedBulkOp(options?: BulkWriteOptions): UnorderedBulkOperation {\n    return new UnorderedBulkOperation(this as TODO_NODE_3286, resolveOptions(this, options));\n  }\n\n  /**\n   * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n  initializeOrderedBulkOp(options?: BulkWriteOptions): OrderedBulkOperation {\n    return new OrderedBulkOperation(this as TODO_NODE_3286, resolveOptions(this, options));\n  }\n\n  /**\n   * An estimated count of matching documents in the db to a filter.\n   *\n   * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents\n   * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.\n   * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n   *\n   * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead\n   *\n   * @param filter - The filter for the count.\n   * @param options - Optional settings for the command\n   */\n  async count(filter: Filter<TSchema> = {}, options: CountOptions = {}): Promise<number> {\n    return executeOperation(\n      this.client,\n      new CountOperation(this.fullNamespace, filter, resolveOptions(this, options))\n    );\n  }\n\n  /**\n   * Returns all search indexes for the current collection.\n   *\n   * @param options - The options for the list indexes operation.\n   *\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\n   */\n  listSearchIndexes(options?: ListSearchIndexesOptions): ListSearchIndexesCursor;\n  /**\n   * Returns all search indexes for the current collection.\n   *\n   * @param name - The name of the index to search for.  Only indexes with matching index names will be returned.\n   * @param options - The options for the list indexes operation.\n   *\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\n   */\n  listSearchIndexes(name: string, options?: ListSearchIndexesOptions): ListSearchIndexesCursor;\n  listSearchIndexes(\n    indexNameOrOptions?: string | ListSearchIndexesOptions,\n    options?: ListSearchIndexesOptions\n  ): ListSearchIndexesCursor {\n    options =\n      typeof indexNameOrOptions === 'object' ? indexNameOrOptions : options == null ? {} : options;\n    const indexName =\n      indexNameOrOptions == null\n        ? null\n        : typeof indexNameOrOptions === 'object'\n        ? null\n        : indexNameOrOptions;\n\n    return new ListSearchIndexesCursor(this as TODO_NODE_3286, indexName, options);\n  }\n\n  /**\n   * Creates a single search index for the collection.\n   *\n   * @param description - The index description for the new search index.\n   * @returns A promise that resolves to the name of the new search index.\n   *\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\n   */\n  async createSearchIndex(description: SearchIndexDescription): Promise<string> {\n    const [index] = await this.createSearchIndexes([description]);\n    return index;\n  }\n\n  /**\n   * Creates multiple search indexes for the current collection.\n   *\n   * @param descriptions - An array of `SearchIndexDescription`s for the new search indexes.\n   * @returns A promise that resolves to an array of the newly created search index names.\n   *\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\n   * @returns\n   */\n  async createSearchIndexes(descriptions: SearchIndexDescription[]): Promise<string[]> {\n    return executeOperation(\n      this.client,\n      new CreateSearchIndexesOperation(this as TODO_NODE_3286, descriptions)\n    );\n  }\n\n  /**\n   * Deletes a search index by index name.\n   *\n   * @param name - The name of the search index to be deleted.\n   *\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\n   */\n  async dropSearchIndex(name: string): Promise<void> {\n    return executeOperation(\n      this.client,\n      new DropSearchIndexOperation(this as TODO_NODE_3286, name)\n    );\n  }\n\n  /**\n   * Updates a search index by replacing the existing index definition with the provided definition.\n   *\n   * @param name - The name of the search index to update.\n   * @param definition - The new search index definition.\n   *\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\n   */\n  async updateSearchIndex(name: string, definition: Document): Promise<void> {\n    return executeOperation(\n      this.client,\n      new UpdateSearchIndexOperation(this as TODO_NODE_3286, name, definition)\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}