{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _objectSpread = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _get = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChangeStreamCursor = void 0;\nvar change_stream_1 = require(\"../change_stream\");\nvar constants_1 = require(\"../constants\");\nvar aggregate_1 = require(\"../operations/aggregate\");\nvar execute_operation_1 = require(\"../operations/execute_operation\");\nvar utils_1 = require(\"../utils\");\nvar abstract_cursor_1 = require(\"./abstract_cursor\");\n/** @internal */\nvar ChangeStreamCursor = /*#__PURE__*/function (_abstract_cursor_1$Ab) {\n  _inherits(ChangeStreamCursor, _abstract_cursor_1$Ab);\n  var _super = _createSuper(ChangeStreamCursor);\n  function ChangeStreamCursor(client, namespace) {\n    var _this;\n    var pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    _classCallCheck(this, ChangeStreamCursor);\n    _this = _super.call(this, client, namespace, options);\n    _this.pipeline = pipeline;\n    _this.options = options;\n    _this._resumeToken = null;\n    _this.startAtOperationTime = options.startAtOperationTime;\n    if (options.startAfter) {\n      _this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      _this.resumeToken = options.resumeAfter;\n    }\n    return _this;\n  }\n  _createClass(ChangeStreamCursor, [{\n    key: \"resumeToken\",\n    get: function get() {\n      return this._resumeToken;\n    },\n    set: function set(token) {\n      this._resumeToken = token;\n      this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);\n    }\n  }, {\n    key: \"resumeOptions\",\n    get: function get() {\n      var options = _objectSpread({}, this.options);\n      for (var _i = 0, _arr = ['resumeAfter', 'startAfter', 'startAtOperationTime']; _i < _arr.length; _i++) {\n        var key = _arr[_i];\n        delete options[key];\n      }\n      if (this.resumeToken != null) {\n        if (this.options.startAfter && !this.hasReceived) {\n          options.startAfter = this.resumeToken;\n        } else {\n          options.resumeAfter = this.resumeToken;\n        }\n      } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {\n        options.startAtOperationTime = this.startAtOperationTime;\n      }\n      return options;\n    }\n  }, {\n    key: \"cacheResumeToken\",\n    value: function cacheResumeToken(resumeToken) {\n      if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n        this.resumeToken = this.postBatchResumeToken;\n      } else {\n        this.resumeToken = resumeToken;\n      }\n      this.hasReceived = true;\n    }\n  }, {\n    key: \"_processBatch\",\n    value: function _processBatch(response) {\n      var cursor = response.cursor;\n      if (cursor.postBatchResumeToken) {\n        this.postBatchResumeToken = response.cursor.postBatchResumeToken;\n        var batch = 'firstBatch' in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;\n        if (batch.length === 0) {\n          this.resumeToken = cursor.postBatchResumeToken;\n        }\n      }\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, _objectSpread({}, this.cursorOptions));\n    }\n  }, {\n    key: \"_initialize\",\n    value: function () {\n      var _initialize2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(session) {\n        var aggregateOperation, response, server;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, _objectSpread(_objectSpread(_objectSpread({}, this.cursorOptions), this.options), {}, {\n                session: session\n              }));\n              _context.next = 3;\n              return (0, execute_operation_1.executeOperation)(session.client, aggregateOperation);\n            case 3:\n              response = _context.sent;\n              server = aggregateOperation.server;\n              this.maxWireVersion = (0, utils_1.maxWireVersion)(server);\n              if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && this.maxWireVersion >= 7) {\n                this.startAtOperationTime = response.operationTime;\n              }\n              this._processBatch(response);\n              this.emit(constants_1.INIT, response);\n              this.emit(constants_1.RESPONSE);\n              // TODO: NODE-2882\n              return _context.abrupt(\"return\", {\n                server: server,\n                session: session,\n                response: response\n              });\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function _initialize(_x) {\n        return _initialize2.apply(this, arguments);\n      }\n      return _initialize;\n    }()\n  }, {\n    key: \"getMore\",\n    value: function () {\n      var _getMore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(batchSize) {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return _get(_getPrototypeOf(ChangeStreamCursor.prototype), \"getMore\", this).call(this, batchSize);\n            case 2:\n              response = _context2.sent;\n              this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);\n              this._processBatch(response);\n              this.emit(change_stream_1.ChangeStream.MORE, response);\n              this.emit(change_stream_1.ChangeStream.RESPONSE);\n              return _context2.abrupt(\"return\", response);\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function getMore(_x2) {\n        return _getMore.apply(this, arguments);\n      }\n      return getMore;\n    }()\n  }]);\n  return ChangeStreamCursor;\n}(abstract_cursor_1.AbstractCursor);\nexports.ChangeStreamCursor = ChangeStreamCursor;","map":{"version":3,"names":["change_stream_1","require","constants_1","aggregate_1","execute_operation_1","utils_1","abstract_cursor_1","ChangeStreamCursor","_abstract_cursor_1$Ab","_inherits","_super","_createSuper","client","namespace","_this","pipeline","arguments","length","undefined","options","_classCallCheck","call","_resumeToken","startAtOperationTime","startAfter","resumeToken","resumeAfter","_createClass","key","get","set","token","emit","ChangeStream","RESUME_TOKEN_CHANGED","_objectSpread","_i","_arr","hasReceived","maxWireVersion","server","value","cacheResumeToken","bufferedCount","postBatchResumeToken","_processBatch","response","cursor","batch","firstBatch","nextBatch","clone","cursorOptions","_initialize2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","session","aggregateOperation","wrap","_callee$","_context","prev","next","AggregateOperation","executeOperation","sent","operationTime","INIT","RESPONSE","abrupt","stop","_initialize","_x","apply","_getMore","_callee2","batchSize","_callee2$","_context2","_get","_getPrototypeOf","prototype","MORE","getMore","_x2","AbstractCursor","exports"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\cursor\\change_stream_cursor.ts"],"sourcesContent":["import type { Document, Long, Timestamp } from '../bson';\nimport {\n  ChangeStream,\n  type ChangeStreamDocument,\n  type ChangeStreamEvents,\n  type OperationTime,\n  type ResumeToken\n} from '../change_stream';\nimport { INIT, RESPONSE } from '../constants';\nimport type { MongoClient } from '../mongo_client';\nimport type { TODO_NODE_3286 } from '../mongo_types';\nimport { AggregateOperation } from '../operations/aggregate';\nimport type { CollationOptions } from '../operations/command';\nimport { executeOperation, type ExecutionResult } from '../operations/execute_operation';\nimport type { ClientSession } from '../sessions';\nimport { maxWireVersion, type MongoDBNamespace } from '../utils';\nimport { AbstractCursor, type AbstractCursorOptions } from './abstract_cursor';\n\n/** @internal */\nexport interface ChangeStreamCursorOptions extends AbstractCursorOptions {\n  startAtOperationTime?: OperationTime;\n  resumeAfter?: ResumeToken;\n  startAfter?: ResumeToken;\n  maxAwaitTimeMS?: number;\n  collation?: CollationOptions;\n  fullDocument?: string;\n}\n\n/** @internal */\nexport type ChangeStreamAggregateRawResult<TChange> = {\n  $clusterTime: { clusterTime: Timestamp };\n  cursor: {\n    postBatchResumeToken: ResumeToken;\n    ns: string;\n    id: number | Long;\n  } & ({ firstBatch: TChange[] } | { nextBatch: TChange[] });\n  ok: 1;\n  operationTime: Timestamp;\n};\n\n/** @internal */\nexport class ChangeStreamCursor<\n  TSchema extends Document = Document,\n  TChange extends Document = ChangeStreamDocument<TSchema>\n> extends AbstractCursor<TChange, ChangeStreamEvents> {\n  _resumeToken: ResumeToken;\n  startAtOperationTime?: OperationTime;\n  hasReceived?: boolean;\n  resumeAfter: ResumeToken;\n  startAfter: ResumeToken;\n  options: ChangeStreamCursorOptions;\n\n  postBatchResumeToken?: ResumeToken;\n  pipeline: Document[];\n\n  /**\n   * @internal\n   *\n   * used to determine change stream resumability\n   */\n  maxWireVersion: number | undefined;\n\n  constructor(\n    client: MongoClient,\n    namespace: MongoDBNamespace,\n    pipeline: Document[] = [],\n    options: ChangeStreamCursorOptions = {}\n  ) {\n    super(client, namespace, options);\n\n    this.pipeline = pipeline;\n    this.options = options;\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token: ResumeToken) {\n    this._resumeToken = token;\n    this.emit(ChangeStream.RESUME_TOKEN_CHANGED, token);\n  }\n\n  get resumeToken(): ResumeToken {\n    return this._resumeToken;\n  }\n\n  get resumeOptions(): ChangeStreamCursorOptions {\n    const options: ChangeStreamCursorOptions = {\n      ...this.options\n    };\n\n    for (const key of ['resumeAfter', 'startAfter', 'startAtOperationTime'] as const) {\n      delete options[key];\n    }\n\n    if (this.resumeToken != null) {\n      if (this.options.startAfter && !this.hasReceived) {\n        options.startAfter = this.resumeToken;\n      } else {\n        options.resumeAfter = this.resumeToken;\n      }\n    } else if (this.startAtOperationTime != null && maxWireVersion(this.server) >= 7) {\n      options.startAtOperationTime = this.startAtOperationTime;\n    }\n\n    return options;\n  }\n\n  cacheResumeToken(resumeToken: ResumeToken): void {\n    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n      this.resumeToken = this.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n    this.hasReceived = true;\n  }\n\n  _processBatch(response: ChangeStreamAggregateRawResult<TChange>): void {\n    const cursor = response.cursor;\n    if (cursor.postBatchResumeToken) {\n      this.postBatchResumeToken = response.cursor.postBatchResumeToken;\n\n      const batch =\n        'firstBatch' in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;\n      if (batch.length === 0) {\n        this.resumeToken = cursor.postBatchResumeToken;\n      }\n    }\n  }\n\n  clone(): AbstractCursor<TChange> {\n    return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {\n      ...this.cursorOptions\n    });\n  }\n\n  async _initialize(session: ClientSession): Promise<ExecutionResult> {\n    const aggregateOperation = new AggregateOperation(this.namespace, this.pipeline, {\n      ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n\n    const response = await executeOperation<\n      TODO_NODE_3286,\n      ChangeStreamAggregateRawResult<TChange>\n    >(session.client, aggregateOperation);\n\n    const server = aggregateOperation.server;\n    this.maxWireVersion = maxWireVersion(server);\n\n    if (\n      this.startAtOperationTime == null &&\n      this.resumeAfter == null &&\n      this.startAfter == null &&\n      this.maxWireVersion >= 7\n    ) {\n      this.startAtOperationTime = response.operationTime;\n    }\n\n    this._processBatch(response);\n\n    this.emit(INIT, response);\n    this.emit(RESPONSE);\n\n    // TODO: NODE-2882\n    return { server, session, response };\n  }\n\n  override async getMore(batchSize: number): Promise<Document | null> {\n    const response = await super.getMore(batchSize);\n\n    this.maxWireVersion = maxWireVersion(this.server);\n    this._processBatch(response as ChangeStreamAggregateRawResult<TChange>);\n\n    this.emit(ChangeStream.MORE, response);\n    this.emit(ChangeStream.RESPONSE);\n    return response;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}