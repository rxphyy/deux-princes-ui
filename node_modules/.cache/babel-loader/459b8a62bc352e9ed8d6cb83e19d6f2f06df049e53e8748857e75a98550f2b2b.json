{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _regeneratorRuntime = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _objectSpread = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\nvar util_1 = require(\"util\");\nvar bson_1 = require(\"./bson\");\nvar metrics_1 = require(\"./cmap/metrics\");\nvar shared_1 = require(\"./cmap/wire_protocol/shared\");\nvar constants_1 = require(\"./constants\");\nvar error_1 = require(\"./error\");\nvar mongo_types_1 = require(\"./mongo_types\");\nvar execute_operation_1 = require(\"./operations/execute_operation\");\nvar run_command_1 = require(\"./operations/run_command\");\nvar read_concern_1 = require(\"./read_concern\");\nvar read_preference_1 = require(\"./read_preference\");\nvar common_1 = require(\"./sdam/common\");\nvar transactions_1 = require(\"./transactions\");\nvar utils_1 = require(\"./utils\");\nvar write_concern_1 = require(\"./write_concern\");\nvar minWireVersionForShardedTransactions = 8;\n/** @internal */\nvar kServerSession = Symbol('serverSession');\n/** @internal */\nvar kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nvar kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nvar kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\nvar kTxnNumberIncrement = Symbol('txnNumberIncrement');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nvar ClientSession = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(ClientSession, _mongo_types_1$TypedE);\n  var _super = _createSuper(ClientSession);\n  /**\n   * Create a client session.\n   * @internal\n   * @param client - The current client\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  function ClientSession(client, sessionPool, options, clientOptions) {\n    var _options, _options$causalConsis;\n    var _this;\n    _classCallCheck(this, ClientSession);\n    _this = _super.call(this);\n    /** @internal */\n    _this[_a] = false;\n    if (client == null) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');\n    }\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n    options = (_options = options) !== null && _options !== void 0 ? _options : {};\n    if (options.snapshot === true) {\n      _this[kSnapshotEnabled] = true;\n      if (options.causalConsistency === true) {\n        throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n      }\n    }\n    _this.client = client;\n    _this.sessionPool = sessionPool;\n    _this.hasEnded = false;\n    _this.clientOptions = clientOptions;\n    _this.explicit = !!options.explicit;\n    _this[kServerSession] = _this.explicit ? _this.sessionPool.acquire() : null;\n    _this[kTxnNumberIncrement] = 0;\n    var defaultCausalConsistencyValue = _this.explicit && options.snapshot !== true;\n    _this.supports = {\n      // if we can enable causal consistency, do so by default\n      causalConsistency: (_options$causalConsis = options.causalConsistency) !== null && _options$causalConsis !== void 0 ? _options$causalConsis : defaultCausalConsistencyValue\n    };\n    _this.clusterTime = options.initialClusterTime;\n    _this.operationTime = undefined;\n    _this.owner = options.owner;\n    _this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    _this.transaction = new transactions_1.Transaction();\n    return _this;\n  }\n  /** The server id associated with this session */\n  _createClass(ClientSession, [{\n    key: \"id\",\n    get: function get() {\n      var _this$kServerSession;\n      return (_this$kServerSession = this[kServerSession]) === null || _this$kServerSession === void 0 ? void 0 : _this$kServerSession.id;\n    }\n  }, {\n    key: \"serverSession\",\n    get: function get() {\n      var serverSession = this[kServerSession];\n      if (serverSession == null) {\n        if (this.explicit) {\n          throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');\n        }\n        if (this.hasEnded) {\n          throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n        }\n        serverSession = this.sessionPool.acquire();\n        this[kServerSession] = serverSession;\n      }\n      return serverSession;\n    }\n    /** Whether or not this session is configured for snapshot reads */\n  }, {\n    key: \"snapshotEnabled\",\n    get: function get() {\n      return this[kSnapshotEnabled];\n    }\n  }, {\n    key: \"loadBalanced\",\n    get: function get() {\n      var _this$client$topology;\n      return ((_this$client$topology = this.client.topology) === null || _this$client$topology === void 0 ? void 0 : _this$client$topology.description.type) === common_1.TopologyType.LoadBalanced;\n    }\n    /** @internal */\n  }, {\n    key: \"pinnedConnection\",\n    get: function get() {\n      return this[kPinnedConnection];\n    }\n    /** @internal */\n  }, {\n    key: \"pin\",\n    value: function pin(conn) {\n      if (this[kPinnedConnection]) {\n        throw TypeError('Cannot pin multiple connections to the same session');\n      }\n      this[kPinnedConnection] = conn;\n      conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n    }\n    /** @internal */\n  }, {\n    key: \"unpin\",\n    value: function unpin(options) {\n      if (this.loadBalanced) {\n        return maybeClearPinnedConnection(this, options);\n      }\n      this.transaction.unpinServer();\n    }\n  }, {\n    key: \"isPinned\",\n    get: function get() {\n      return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n    }\n    /**\n     * Ends this session on the server\n     *\n     * @param options - Optional settings. Currently reserved for future use\n     */\n  }, {\n    key: \"endSession\",\n    value: function () {\n      var _endSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {\n        var serverSession;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              if (!this.inTransaction()) {\n                _context.next = 4;\n                break;\n              }\n              _context.next = 4;\n              return this.abortTransaction();\n            case 4:\n              if (!this.hasEnded) {\n                serverSession = this[kServerSession];\n                if (serverSession != null) {\n                  // release the server session back to the pool\n                  this.sessionPool.release(serverSession);\n                  // Make sure a new serverSession never makes it onto this ClientSession\n                  Object.defineProperty(this, kServerSession, {\n                    value: ServerSession.clone(serverSession),\n                    writable: false\n                  });\n                }\n                // mark the session as ended, and emit a signal\n                this.hasEnded = true;\n                this.emit('ended', this);\n              }\n              _context.next = 9;\n              break;\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](0);\n            case 9:\n              _context.prev = 9;\n              maybeClearPinnedConnection(this, _objectSpread({\n                force: true\n              }, options));\n              return _context.finish(9);\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[0, 7, 9, 12]]);\n      }));\n      function endSession(_x) {\n        return _endSession.apply(this, arguments);\n      }\n      return endSession;\n    }()\n    /**\n     * Advances the operationTime for a ClientSession.\n     *\n     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n     */\n  }, {\n    key: \"advanceOperationTime\",\n    value: function advanceOperationTime(operationTime) {\n      if (this.operationTime == null) {\n        this.operationTime = operationTime;\n        return;\n      }\n      if (operationTime.greaterThan(this.operationTime)) {\n        this.operationTime = operationTime;\n      }\n    }\n    /**\n     * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n     *\n     * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n     */\n  }, {\n    key: \"advanceClusterTime\",\n    value: function advanceClusterTime(clusterTime) {\n      var _clusterTime$signatur, _clusterTime$signatur2;\n      if (!clusterTime || typeof clusterTime !== 'object') {\n        throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n      }\n      if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n        throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n      }\n      if (!clusterTime.signature || ((_clusterTime$signatur = clusterTime.signature.hash) === null || _clusterTime$signatur === void 0 ? void 0 : _clusterTime$signatur._bsontype) !== 'Binary' || typeof clusterTime.signature.keyId !== 'bigint' && typeof clusterTime.signature.keyId !== 'number' && ((_clusterTime$signatur2 = clusterTime.signature.keyId) === null || _clusterTime$signatur2 === void 0 ? void 0 : _clusterTime$signatur2._bsontype) !== 'Long' // apparently we decode the key to number?\n      ) {\n        throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n      }\n      (0, common_1._advanceClusterTime)(this, clusterTime);\n    }\n    /**\n     * Used to determine if this session equals another\n     *\n     * @param session - The session to compare to\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(session) {\n      if (!(session instanceof ClientSession)) {\n        return false;\n      }\n      if (this.id == null || session.id == null) {\n        return false;\n      }\n      return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);\n    }\n    /**\n     * Increment the transaction number on the internal ServerSession\n     *\n     * @privateRemarks\n     * This helper increments a value stored on the client session that will be\n     * added to the serverSession's txnNumber upon applying it to a command.\n     * This is because the serverSession is lazily acquired after a connection is obtained\n     */\n  }, {\n    key: \"incrementTransactionNumber\",\n    value: function incrementTransactionNumber() {\n      this[kTxnNumberIncrement] += 1;\n    }\n    /** @returns whether this session is currently in a transaction or not */\n  }, {\n    key: \"inTransaction\",\n    value: function inTransaction() {\n      return this.transaction.isActive;\n    }\n    /**\n     * Starts a new transaction with the given options.\n     *\n     * @param options - Options for the transaction\n     */\n  }, {\n    key: \"startTransaction\",\n    value: function startTransaction(options) {\n      var _ref, _options$readConcern, _this$clientOptions, _ref2, _options$writeConcern, _this$clientOptions2, _ref3, _options$readPreferen, _this$clientOptions3, _options$maxCommitTim;\n      if (this[kSnapshotEnabled]) {\n        throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n      }\n      if (this.inTransaction()) {\n        throw new error_1.MongoTransactionError('Transaction already in progress');\n      }\n      if (this.isPinned && this.transaction.isCommitted) {\n        this.unpin();\n      }\n      var topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);\n      if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n        throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n      }\n      // increment txnNumber\n      this.incrementTransactionNumber();\n      // create transaction state\n      this.transaction = new transactions_1.Transaction({\n        readConcern: (_ref = (_options$readConcern = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _options$readConcern !== void 0 ? _options$readConcern : this.defaultTransactionOptions.readConcern) !== null && _ref !== void 0 ? _ref : (_this$clientOptions = this.clientOptions) === null || _this$clientOptions === void 0 ? void 0 : _this$clientOptions.readConcern,\n        writeConcern: (_ref2 = (_options$writeConcern = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _options$writeConcern !== void 0 ? _options$writeConcern : this.defaultTransactionOptions.writeConcern) !== null && _ref2 !== void 0 ? _ref2 : (_this$clientOptions2 = this.clientOptions) === null || _this$clientOptions2 === void 0 ? void 0 : _this$clientOptions2.writeConcern,\n        readPreference: (_ref3 = (_options$readPreferen = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _options$readPreferen !== void 0 ? _options$readPreferen : this.defaultTransactionOptions.readPreference) !== null && _ref3 !== void 0 ? _ref3 : (_this$clientOptions3 = this.clientOptions) === null || _this$clientOptions3 === void 0 ? void 0 : _this$clientOptions3.readPreference,\n        maxCommitTimeMS: (_options$maxCommitTim = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _options$maxCommitTim !== void 0 ? _options$maxCommitTim : this.defaultTransactionOptions.maxCommitTimeMS\n      });\n      this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n    }\n    /**\n     * Commits the currently active transaction in this session.\n     */\n  }, {\n    key: \"commitTransaction\",\n    value: function () {\n      var _commitTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", endTransactionAsync(this, 'commitTransaction'));\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function commitTransaction() {\n        return _commitTransaction.apply(this, arguments);\n      }\n      return commitTransaction;\n    }()\n    /**\n     * Aborts the currently active transaction in this session.\n     */\n  }, {\n    key: \"abortTransaction\",\n    value: function () {\n      var _abortTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", endTransactionAsync(this, 'abortTransaction'));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function abortTransaction() {\n        return _abortTransaction.apply(this, arguments);\n      }\n      return abortTransaction;\n    }()\n    /**\n     * This is here to ensure that ClientSession is never serialized to BSON.\n     */\n  }, {\n    key: \"toBSON\",\n    value: function toBSON() {\n      throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n    }\n    /**\n     * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.\n     *\n     * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.\n     *\n     * @remarks\n     * This function:\n     * - If all operations successfully complete and the `commitTransaction` operation is successful, then this function will return the result of the provided function.\n     * - If the transaction is unable to complete or an error is thrown from within the provided function, then this function will throw an error.\n     *   - If the transaction is manually aborted within the provided function it will not throw.\n     * - May be called multiple times if the driver needs to attempt to retry the operations.\n     *\n     * Checkout a descriptive example here:\n     * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions\n     *\n     * @param fn - callback to run within a transaction\n     * @param options - optional settings for the transaction\n     * @returns A raw command response or undefined\n     */\n  }, {\n    key: \"withTransaction\",\n    value: function () {\n      var _withTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(fn, options) {\n        var startTime;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              startTime = (0, utils_1.now)();\n              return _context4.abrupt(\"return\", attemptTransaction(this, startTime, fn, options));\n            case 2:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function withTransaction(_x2, _x3) {\n        return _withTransaction.apply(this, arguments);\n      }\n      return withTransaction;\n    }()\n  }]);\n  return ClientSession;\n}(mongo_types_1.TypedEventEmitter);\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nvar MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nvar NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\nfunction hasNotTimedOut(startTime, max) {\n  return (0, utils_1.calculateDurationInMs)(startTime) < max;\n}\nfunction isUnknownTransactionCommitResult(err) {\n  var isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;\n}\nfunction maybeClearPinnedConnection(session, options) {\n  // unpin a connection if it has been pinned\n  var conn = session[kPinnedConnection];\n  var error = options === null || options === void 0 ? void 0 : options.error;\n  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n    return;\n  }\n  var topology = session.client.topology;\n  // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n  if (conn && topology != null) {\n    var servers = Array.from(topology.s.servers.values());\n    var loadBalancer = servers[0];\n    if ((options === null || options === void 0 ? void 0 : options.error) == null || options !== null && options !== void 0 && options.force) {\n      loadBalancer.pool.checkIn(conn);\n      conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n      if (options !== null && options !== void 0 && options.forceClear) {\n        loadBalancer.pool.clear({\n          serviceId: conn.serviceId\n        });\n      }\n    }\n    session[kPinnedConnection] = undefined;\n  }\n}\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null || !(err instanceof error_1.MongoServerError)) {\n    return false;\n  }\n  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n}\nfunction attemptTransactionCommit(session, startTime, fn, result, options) {\n  return session.commitTransaction().then(function () {\n    return result;\n  }, function (err) {\n    if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {\n        return attemptTransactionCommit(session, startTime, fn, result, options);\n      }\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n    throw err;\n  });\n}\nvar USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\nfunction attemptTransaction(session, startTime, fn) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  session.startTransaction(options);\n  var promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n  if (!(0, utils_1.isPromiseLike)(promise)) {\n    session.abortTransaction().catch(function () {\n      return null;\n    });\n    return Promise.reject(new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise'));\n  }\n  return promise.then(function (result) {\n    if (userExplicitlyEndedTransaction(session)) {\n      return result;\n    }\n    return attemptTransactionCommit(session, startTime, fn, result, options);\n  }, function (err) {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof error_1.MongoError && err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n      if (isMaxTimeMSExpiredError(err)) {\n        err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n      }\n      throw err;\n    }\n    if (session.inTransaction()) {\n      return session.abortTransaction().then(function () {\n        return maybeRetryOrThrow(err);\n      });\n    }\n    return maybeRetryOrThrow(err);\n  });\n}\nvar endTransactionAsync = (0, util_1.promisify)(endTransaction);\nfunction endTransaction(session, commandName, callback) {\n  // handle any initial problematic cases\n  var txnState = session.transaction.state;\n  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n    callback(new error_1.MongoTransactionError('No transaction started'));\n    return;\n  }\n  if (commandName === 'commitTransaction') {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  }\n  // construct and send the command\n  var command = _defineProperty({}, commandName, 1);\n  // apply a writeConcern if specified\n  var writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = {\n      w: session.clientOptions.writeConcern.w\n    };\n  }\n  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeoutMS: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n  if (writeConcern) {\n    write_concern_1.WriteConcern.apply(command, writeConcern);\n  }\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n  function commandHandler(error) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, {\n          force: false\n        });\n      }\n      // The spec indicates that we should ignore all errors on `abortTransaction`\n      return callback();\n    }\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n    if (error instanceof error_1.MongoError) {\n      if (error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError) || error instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(error)) {\n        if (isUnknownTransactionCommitResult(error)) {\n          error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n          // per txns spec, must unpin session in this case\n          session.unpin({\n            error: error\n          });\n        }\n      } else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        session.unpin({\n          error: error\n        });\n      }\n    }\n    callback(error);\n  }\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n  // send the command\n  (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(command, {\n    session: session,\n    readPreference: read_preference_1.ReadPreference.primary,\n    bypassPinningCheck: true\n  }), function (error) {\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n    if (error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.unpin({\n          force: true\n        });\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n      return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(command, {\n        session: session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n      }), commandHandler);\n    }\n    commandHandler(error);\n  });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nvar ServerSession = /*#__PURE__*/function () {\n  /** @internal */\n  function ServerSession() {\n    _classCallCheck(this, ServerSession);\n    this.id = {\n      id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = (0, utils_1.now)();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n  _createClass(ServerSession, [{\n    key: \"hasTimedOut\",\n    value: function hasTimedOut(sessionTimeoutMinutes) {\n      // Take the difference of the lastUse timestamp and now, which will result in a value in\n      // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n      var idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);\n      return idleTimeMinutes > sessionTimeoutMinutes - 1;\n    }\n    /**\n     * @internal\n     * Cloning meant to keep a readable reference to the server session data\n     * after ClientSession has ended\n     */\n  }], [{\n    key: \"clone\",\n    value: function clone(serverSession) {\n      var arrayBuffer = new ArrayBuffer(16);\n      var idBytes = Buffer.from(arrayBuffer);\n      idBytes.set(serverSession.id.id.buffer);\n      var id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);\n      // Manual prototype construction to avoid modifying the constructor of this class\n      return Object.setPrototypeOf({\n        id: {\n          id: id\n        },\n        lastUse: serverSession.lastUse,\n        txnNumber: serverSession.txnNumber,\n        isDirty: serverSession.isDirty\n      }, ServerSession.prototype);\n    }\n  }]);\n  return ServerSession;\n}();\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nvar ServerSessionPool = /*#__PURE__*/function () {\n  function ServerSessionPool(client) {\n    _classCallCheck(this, ServerSessionPool);\n    if (client == null) {\n      throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');\n    }\n    this.client = client;\n    this.sessions = new utils_1.List();\n  }\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n  _createClass(ServerSessionPool, [{\n    key: \"acquire\",\n    value: function acquire() {\n      var _this$client$topology2, _this$client$topology3;\n      var sessionTimeoutMinutes = (_this$client$topology2 = (_this$client$topology3 = this.client.topology) === null || _this$client$topology3 === void 0 ? void 0 : _this$client$topology3.logicalSessionTimeoutMinutes) !== null && _this$client$topology2 !== void 0 ? _this$client$topology2 : 10;\n      var session = null;\n      // Try to obtain from session pool\n      while (this.sessions.length > 0) {\n        var _this$client$topology4;\n        var potentialSession = this.sessions.shift();\n        if (potentialSession != null && (!!((_this$client$topology4 = this.client.topology) !== null && _this$client$topology4 !== void 0 && _this$client$topology4.loadBalanced) || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {\n          session = potentialSession;\n          break;\n        }\n      }\n      // If nothing valid came from the pool make a new one\n      if (session == null) {\n        session = new ServerSession();\n      }\n      return session;\n    }\n    /**\n     * Release a session to the session pool\n     * Adds the session back to the session pool if the session has not timed out yet.\n     * This method also removes any stale sessions from the pool.\n     *\n     * @param session - The session to release to the pool\n     */\n  }, {\n    key: \"release\",\n    value: function release(session) {\n      var _this$client$topology5, _this$client$topology6, _this$client$topology7;\n      var sessionTimeoutMinutes = (_this$client$topology5 = (_this$client$topology6 = this.client.topology) === null || _this$client$topology6 === void 0 ? void 0 : _this$client$topology6.logicalSessionTimeoutMinutes) !== null && _this$client$topology5 !== void 0 ? _this$client$topology5 : 10;\n      if ((_this$client$topology7 = this.client.topology) !== null && _this$client$topology7 !== void 0 && _this$client$topology7.loadBalanced && !sessionTimeoutMinutes) {\n        this.sessions.unshift(session);\n      }\n      if (!sessionTimeoutMinutes) {\n        return;\n      }\n      this.sessions.prune(function (session) {\n        return session.hasTimedOut(sessionTimeoutMinutes);\n      });\n      if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n        if (session.isDirty) {\n          return;\n        }\n        // otherwise, readd this session to the session pool\n        this.sessions.unshift(session);\n      }\n    }\n  }]);\n  return ServerSessionPool;\n}();\nexports.ServerSessionPool = ServerSessionPool;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\nfunction applySession(session, command, options) {\n  var _options$writeConcern2;\n  if (session.hasEnded) {\n    return new error_1.MongoExpiredSessionError();\n  }\n  // May acquire serverSession here\n  var serverSession = session.serverSession;\n  if (serverSession == null) {\n    return new error_1.MongoRuntimeError('Unable to acquire server session');\n  }\n  if (((_options$writeConcern2 = options.writeConcern) === null || _options$writeConcern2 === void 0 ? void 0 : _options$writeConcern2.w) === 0) {\n    if (session && session.explicit) {\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n    return;\n  }\n  // mark the last use of this session, and apply the `lsid`\n  serverSession.lastUse = (0, utils_1.now)();\n  command.lsid = serverSession.id;\n  var inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n  var isRetryableWrite = !!options.willRetryWrite;\n  if (isRetryableWrite || inTxnOrTxnCommand) {\n    serverSession.txnNumber += session[kTxnNumberIncrement];\n    session[kTxnNumberIncrement] = 0;\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n  }\n  if (!inTxnOrTxnCommand) {\n    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n    }\n    if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command)) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || {\n        level: read_concern_1.ReadConcernLevel.snapshot\n      };\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, {\n          atClusterTime: session[kSnapshotTime]\n        });\n      }\n    }\n    return;\n  }\n  // now attempt to apply transaction-specific sessions data\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n    var _session$clientOption;\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    var readConcern = session.transaction.options.readConcern || (session === null || session === void 0 || (_session$clientOption = session.clientOptions) === null || _session$clientOption === void 0 ? void 0 : _session$clientOption.readConcern);\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n  return;\n}\nexports.applySession = applySession;\nfunction updateSessionFromResponse(session, document) {\n  if (document.$clusterTime) {\n    (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n  }\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n  if (session !== null && session !== void 0 && session[kSnapshotEnabled] && session[kSnapshotTime] == null) {\n    var _document$cursor;\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    var atClusterTime = ((_document$cursor = document.cursor) === null || _document$cursor === void 0 ? void 0 : _document$cursor.atClusterTime) || document.atClusterTime;\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\nexports.updateSessionFromResponse = updateSessionFromResponse;","map":{"version":3,"names":["util_1","require","bson_1","metrics_1","shared_1","constants_1","error_1","mongo_types_1","execute_operation_1","run_command_1","read_concern_1","read_preference_1","common_1","transactions_1","utils_1","write_concern_1","minWireVersionForShardedTransactions","kServerSession","Symbol","kSnapshotTime","kSnapshotEnabled","kPinnedConnection","kTxnNumberIncrement","ClientSession","_mongo_types_1$TypedE","_inherits","_super","_createSuper","client","sessionPool","options","clientOptions","_options","_options$causalConsis","_this","_classCallCheck","call","_a","MongoRuntimeError","ServerSessionPool","snapshot","causalConsistency","MongoInvalidArgumentError","hasEnded","explicit","acquire","defaultCausalConsistencyValue","supports","clusterTime","initialClusterTime","operationTime","undefined","owner","defaultTransactionOptions","Object","assign","transaction","Transaction","_createClass","key","get","_this$kServerSession","id","serverSession","_this$client$topology","topology","description","type","TopologyType","LoadBalanced","value","pin","conn","TypeError","emit","PINNED","inTransaction","ConnectionPoolMetrics","TXN","CURSOR","unpin","loadBalanced","maybeClearPinnedConnection","unpinServer","isPinned","_endSession","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","abortTransaction","release","defineProperty","ServerSession","clone","writable","t0","_objectSpread","force","finish","stop","endSession","_x","apply","arguments","advanceOperationTime","greaterThan","advanceClusterTime","_clusterTime$signatur","_clusterTime$signatur2","_bsontype","signature","hash","keyId","_advanceClusterTime","equals","session","ByteUtils","buffer","incrementTransactionNumber","isActive","startTransaction","_ref","_options$readConcern","_this$clientOptions","_ref2","_options$writeConcern","_this$clientOptions2","_ref3","_options$readPreferen","_this$clientOptions3","_options$maxCommitTim","MongoCompatibilityError","MongoTransactionError","isCommitted","topologyMaxWireVersion","maxWireVersion","isSharded","readConcern","writeConcern","readPreference","maxCommitTimeMS","transition","TxnState","STARTING_TRANSACTION","_commitTransaction","_callee2","_callee2$","_context2","abrupt","endTransactionAsync","commitTransaction","_abortTransaction","_callee3","_callee3$","_context3","toBSON","_withTransaction","_callee4","fn","startTime","_callee4$","_context4","now","attemptTransaction","withTransaction","_x2","_x3","TypedEventEmitter","exports","MAX_WITH_TRANSACTION_TIMEOUT","NON_DETERMINISTIC_WRITE_CONCERN_ERRORS","Set","hasNotTimedOut","max","calculateDurationInMs","isUnknownTransactionCommitResult","err","isNonDeterministicWriteConcernError","MongoServerError","codeName","has","isMaxTimeMSExpiredError","code","MONGODB_ERROR_CODES","UnsatisfiableWriteConcern","UnknownReplWriteConcern","error","MongoError","hasErrorLabel","MongoErrorLabel","TransientTransactionError","servers","Array","from","s","values","loadBalancer","pool","checkIn","UNPINNED","state","NO_TRANSACTION","forceClear","clear","serviceId","MaxTimeMSExpired","writeConcernError","attemptTransactionCommit","result","then","UnknownTransactionCommitResult","USER_EXPLICIT_TXN_END_STATES","TRANSACTION_COMMITTED","TRANSACTION_ABORTED","userExplicitlyEndedTransaction","length","promise","Promise","reject","isPromiseLike","catch","maybeRetryOrThrow","addErrorLabel","promisify","endTransaction","commandName","callback","txnState","TRANSACTION_COMMITTED_EMPTY","command","_defineProperty","w","wtimeoutMS","WriteConcern","maxTimeMS","commandHandler","RetryableWriteError","MongoWriteConcernError","recoveryToken","executeOperation","RunAdminCommandOperation","ReadPreference","primary","bypassPinningCheck","wtimeout","Binary","uuidV4","SUBTYPE_UUID","lastUse","txnNumber","isDirty","hasTimedOut","sessionTimeoutMinutes","idleTimeMinutes","Math","round","arrayBuffer","ArrayBuffer","idBytes","Buffer","set","sub_type","setPrototypeOf","prototype","sessions","List","_this$client$topology2","_this$client$topology3","logicalSessionTimeoutMinutes","_this$client$topology4","potentialSession","shift","_this$client$topology5","_this$client$topology6","_this$client$topology7","unshift","prune","applySession","_options$writeConcern2","MongoExpiredSessionError","MongoAPIError","lsid","inTxnOrTxnCommand","isTransactionCommand","isRetryableWrite","willRetryWrite","Long","fromNumber","commandSupportsReadConcern","afterClusterTime","level","ReadConcernLevel","atClusterTime","autocommit","_session$clientOption","TRANSACTION_IN_PROGRESS","updateSessionFromResponse","document","$clusterTime","_recoveryToken","_document$cursor","cursor"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\sessions.ts"],"sourcesContent":["import { promisify } from 'util';\n\nimport { Binary, type Document, Long, type Timestamp } from './bson';\nimport type { CommandOptions, Connection } from './cmap/connection';\nimport { ConnectionPoolMetrics } from './cmap/metrics';\nimport { isSharded } from './cmap/wire_protocol/shared';\nimport { PINNED, UNPINNED } from './constants';\nimport type { AbstractCursor } from './cursor/abstract_cursor';\nimport {\n  type AnyError,\n  MongoAPIError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  type MongoDriverError,\n  MongoError,\n  MongoErrorLabel,\n  MongoExpiredSessionError,\n  MongoInvalidArgumentError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoWriteConcernError\n} from './error';\nimport type { MongoClient, MongoOptions } from './mongo_client';\nimport { TypedEventEmitter } from './mongo_types';\nimport { executeOperation } from './operations/execute_operation';\nimport { RunAdminCommandOperation } from './operations/run_command';\nimport { ReadConcernLevel } from './read_concern';\nimport { ReadPreference } from './read_preference';\nimport { _advanceClusterTime, type ClusterTime, TopologyType } from './sdam/common';\nimport {\n  isTransactionCommand,\n  Transaction,\n  type TransactionOptions,\n  TxnState\n} from './transactions';\nimport {\n  ByteUtils,\n  calculateDurationInMs,\n  type Callback,\n  commandSupportsReadConcern,\n  isPromiseLike,\n  List,\n  maxWireVersion,\n  now,\n  uuidV4\n} from './utils';\nimport { WriteConcern } from './write_concern';\n\nconst minWireVersionForShardedTransactions = 8;\n\n/** @public */\nexport interface ClientSessionOptions {\n  /** Whether causal consistency should be enabled on this session */\n  causalConsistency?: boolean;\n  /** Whether all read operations should be read from the same snapshot for this session (NOTE: not compatible with `causalConsistency=true`) */\n  snapshot?: boolean;\n  /** The default TransactionOptions to use for transactions started on this session. */\n  defaultTransactionOptions?: TransactionOptions;\n\n  /** @internal */\n  owner?: symbol | AbstractCursor;\n  /** @internal */\n  explicit?: boolean;\n  /** @internal */\n  initialClusterTime?: ClusterTime;\n}\n\n/** @public */\nexport type WithTransactionCallback<T = any> = (session: ClientSession) => Promise<T>;\n\n/** @public */\nexport type ClientSessionEvents = {\n  ended(session: ClientSession): void;\n};\n\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n\n/** @public */\nexport interface EndSessionOptions {\n  /**\n   * An optional error which caused the call to end this session\n   * @internal\n   */\n  error?: AnyError;\n  force?: boolean;\n  forceClear?: boolean;\n}\n\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nexport class ClientSession extends TypedEventEmitter<ClientSessionEvents> {\n  /** @internal */\n  client: MongoClient;\n  /** @internal */\n  sessionPool: ServerSessionPool;\n  hasEnded: boolean;\n  clientOptions?: MongoOptions;\n  supports: { causalConsistency: boolean };\n  clusterTime?: ClusterTime;\n  operationTime?: Timestamp;\n  explicit: boolean;\n  /** @internal */\n  owner?: symbol | AbstractCursor;\n  defaultTransactionOptions: TransactionOptions;\n  transaction: Transaction;\n  /** @internal */\n  [kServerSession]: ServerSession | null;\n  /** @internal */\n  [kSnapshotTime]?: Timestamp;\n  /** @internal */\n  [kSnapshotEnabled] = false;\n  /** @internal */\n  [kPinnedConnection]?: Connection;\n  /** @internal */\n  [kTxnNumberIncrement]: number;\n\n  /**\n   * Create a client session.\n   * @internal\n   * @param client - The current client\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(\n    client: MongoClient,\n    sessionPool: ServerSessionPool,\n    options: ClientSessionOptions,\n    clientOptions?: MongoOptions\n  ) {\n    super();\n\n    if (client == null) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError('ClientSession requires a MongoClient');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options ?? {};\n\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n      if (options.causalConsistency === true) {\n        throw new MongoInvalidArgumentError(\n          'Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive'\n        );\n      }\n    }\n\n    this.client = client;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n\n    this.explicit = !!options.explicit;\n    this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n    this[kTxnNumberIncrement] = 0;\n\n    const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;\n    this.supports = {\n      // if we can enable causal consistency, do so by default\n      causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue\n    };\n\n    this.clusterTime = options.initialClusterTime;\n\n    this.operationTime = undefined;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new Transaction();\n  }\n\n  /** The server id associated with this session */\n  get id(): ServerSessionId | undefined {\n    return this[kServerSession]?.id;\n  }\n\n  get serverSession(): ServerSession {\n    let serverSession = this[kServerSession];\n    if (serverSession == null) {\n      if (this.explicit) {\n        throw new MongoRuntimeError('Unexpected null serverSession for an explicit session');\n      }\n      if (this.hasEnded) {\n        throw new MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n      }\n      serverSession = this.sessionPool.acquire();\n      this[kServerSession] = serverSession;\n    }\n    return serverSession;\n  }\n\n  /** Whether or not this session is configured for snapshot reads */\n  get snapshotEnabled(): boolean {\n    return this[kSnapshotEnabled];\n  }\n\n  get loadBalanced(): boolean {\n    return this.client.topology?.description.type === TopologyType.LoadBalanced;\n  }\n\n  /** @internal */\n  get pinnedConnection(): Connection | undefined {\n    return this[kPinnedConnection];\n  }\n\n  /** @internal */\n  pin(conn: Connection): void {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n\n    this[kPinnedConnection] = conn;\n    conn.emit(\n      PINNED,\n      this.inTransaction() ? ConnectionPoolMetrics.TXN : ConnectionPoolMetrics.CURSOR\n    );\n  }\n\n  /** @internal */\n  unpin(options?: { force?: boolean; forceClear?: boolean; error?: AnyError }): void {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n\n    this.transaction.unpinServer();\n  }\n\n  get isPinned(): boolean {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n\n  /**\n   * Ends this session on the server\n   *\n   * @param options - Optional settings. Currently reserved for future use\n   */\n  async endSession(options?: EndSessionOptions): Promise<void> {\n    try {\n      if (this.inTransaction()) {\n        await this.abortTransaction();\n      }\n      if (!this.hasEnded) {\n        const serverSession = this[kServerSession];\n        if (serverSession != null) {\n          // release the server session back to the pool\n          this.sessionPool.release(serverSession);\n          // Make sure a new serverSession never makes it onto this ClientSession\n          Object.defineProperty(this, kServerSession, {\n            value: ServerSession.clone(serverSession),\n            writable: false\n          });\n        }\n        // mark the session as ended, and emit a signal\n        this.hasEnded = true;\n        this.emit('ended', this);\n      }\n    } catch {\n      // spec indicates that we should ignore all errors for `endSessions`\n    } finally {\n      maybeClearPinnedConnection(this, { force: true, ...options });\n    }\n  }\n\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime: Timestamp): void {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n  advanceClusterTime(clusterTime: ClusterTime): void {\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new MongoInvalidArgumentError('input cluster time must be an object');\n    }\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new MongoInvalidArgumentError(\n        'input cluster time \"clusterTime\" property must be a valid BSON Timestamp'\n      );\n    }\n    if (\n      !clusterTime.signature ||\n      clusterTime.signature.hash?._bsontype !== 'Binary' ||\n      (typeof clusterTime.signature.keyId !== 'bigint' &&\n        typeof clusterTime.signature.keyId !== 'number' &&\n        clusterTime.signature.keyId?._bsontype !== 'Long') // apparently we decode the key to number?\n    ) {\n      throw new MongoInvalidArgumentError(\n        'input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId'\n      );\n    }\n\n    _advanceClusterTime(this, clusterTime);\n  }\n\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n  equals(session: ClientSession): boolean {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n\n    return ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);\n  }\n\n  /**\n   * Increment the transaction number on the internal ServerSession\n   *\n   * @privateRemarks\n   * This helper increments a value stored on the client session that will be\n   * added to the serverSession's txnNumber upon applying it to a command.\n   * This is because the serverSession is lazily acquired after a connection is obtained\n   */\n  incrementTransactionNumber(): void {\n    this[kTxnNumberIncrement] += 1;\n  }\n\n  /** @returns whether this session is currently in a transaction or not */\n  inTransaction(): boolean {\n    return this.transaction.isActive;\n  }\n\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param options - Options for the transaction\n   */\n  startTransaction(options?: TransactionOptions): void {\n    if (this[kSnapshotEnabled]) {\n      throw new MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n    }\n\n    if (this.inTransaction()) {\n      throw new MongoTransactionError('Transaction already in progress');\n    }\n\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n\n    const topologyMaxWireVersion = maxWireVersion(this.client.topology);\n    if (\n      isSharded(this.client.topology) &&\n      topologyMaxWireVersion != null &&\n      topologyMaxWireVersion < minWireVersionForShardedTransactions\n    ) {\n      throw new MongoCompatibilityError(\n        'Transactions are not supported on sharded clusters in MongoDB < 4.2.'\n      );\n    }\n\n    // increment txnNumber\n    this.incrementTransactionNumber();\n    // create transaction state\n    this.transaction = new Transaction({\n      readConcern:\n        options?.readConcern ??\n        this.defaultTransactionOptions.readConcern ??\n        this.clientOptions?.readConcern,\n      writeConcern:\n        options?.writeConcern ??\n        this.defaultTransactionOptions.writeConcern ??\n        this.clientOptions?.writeConcern,\n      readPreference:\n        options?.readPreference ??\n        this.defaultTransactionOptions.readPreference ??\n        this.clientOptions?.readPreference,\n      maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS\n    });\n\n    this.transaction.transition(TxnState.STARTING_TRANSACTION);\n  }\n\n  /**\n   * Commits the currently active transaction in this session.\n   */\n  async commitTransaction(): Promise<void> {\n    return endTransactionAsync(this, 'commitTransaction');\n  }\n\n  /**\n   * Aborts the currently active transaction in this session.\n   */\n  async abortTransaction(): Promise<void> {\n    return endTransactionAsync(this, 'abortTransaction');\n  }\n\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n  toBSON(): never {\n    throw new MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n\n  /**\n   * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.\n   *\n   * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.\n   *\n   * @remarks\n   * This function:\n   * - If all operations successfully complete and the `commitTransaction` operation is successful, then this function will return the result of the provided function.\n   * - If the transaction is unable to complete or an error is thrown from within the provided function, then this function will throw an error.\n   *   - If the transaction is manually aborted within the provided function it will not throw.\n   * - May be called multiple times if the driver needs to attempt to retry the operations.\n   *\n   * Checkout a descriptive example here:\n   * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions\n   *\n   * @param fn - callback to run within a transaction\n   * @param options - optional settings for the transaction\n   * @returns A raw command response or undefined\n   */\n  async withTransaction<T = any>(\n    fn: WithTransactionCallback<T>,\n    options?: TransactionOptions\n  ): Promise<T> {\n    const startTime = now();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n}\n\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\n  'CannotSatisfyWriteConcern',\n  'UnknownReplWriteConcern',\n  'UnsatisfiableWriteConcern'\n]);\n\nfunction hasNotTimedOut(startTime: number, max: number) {\n  return calculateDurationInMs(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err: MongoError) {\n  const isNonDeterministicWriteConcernError =\n    err instanceof MongoServerError &&\n    err.codeName &&\n    NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n\n  return (\n    isMaxTimeMSExpiredError(err) ||\n    (!isNonDeterministicWriteConcernError &&\n      err.code !== MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&\n      err.code !== MONGODB_ERROR_CODES.UnknownReplWriteConcern)\n  );\n}\n\nexport function maybeClearPinnedConnection(\n  session: ClientSession,\n  options?: EndSessionOptions\n): void {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options?.error;\n\n  if (\n    session.inTransaction() &&\n    error &&\n    error instanceof MongoError &&\n    error.hasErrorLabel(MongoErrorLabel.TransientTransactionError)\n  ) {\n    return;\n  }\n\n  const topology = session.client.topology;\n  // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n  if (conn && topology != null) {\n    const servers = Array.from(topology.s.servers.values());\n    const loadBalancer = servers[0];\n\n    if (options?.error == null || options?.force) {\n      loadBalancer.pool.checkIn(conn);\n      conn.emit(\n        UNPINNED,\n        session.transaction.state !== TxnState.NO_TRANSACTION\n          ? ConnectionPoolMetrics.TXN\n          : ConnectionPoolMetrics.CURSOR\n      );\n\n      if (options?.forceClear) {\n        loadBalancer.pool.clear({ serviceId: conn.serviceId });\n      }\n    }\n\n    session[kPinnedConnection] = undefined;\n  }\n}\n\nfunction isMaxTimeMSExpiredError(err: MongoError) {\n  if (err == null || !(err instanceof MongoServerError)) {\n    return false;\n  }\n\n  return (\n    err.code === MONGODB_ERROR_CODES.MaxTimeMSExpired ||\n    (err.writeConcernError && err.writeConcernError.code === MONGODB_ERROR_CODES.MaxTimeMSExpired)\n  );\n}\n\nfunction attemptTransactionCommit<T>(\n  session: ClientSession,\n  startTime: number,\n  fn: WithTransactionCallback<T>,\n  result: any,\n  options: TransactionOptions\n): Promise<T> {\n  return session.commitTransaction().then(\n    () => result,\n    (err: MongoError) => {\n      if (\n        err instanceof MongoError &&\n        hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&\n        !isMaxTimeMSExpiredError(err)\n      ) {\n        if (err.hasErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult)) {\n          return attemptTransactionCommit(session, startTime, fn, result, options);\n        }\n\n        if (err.hasErrorLabel(MongoErrorLabel.TransientTransactionError)) {\n          return attemptTransaction(session, startTime, fn, options);\n        }\n      }\n\n      throw err;\n    }\n  );\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set<TxnState>([\n  TxnState.NO_TRANSACTION,\n  TxnState.TRANSACTION_COMMITTED,\n  TxnState.TRANSACTION_ABORTED\n]);\n\nfunction userExplicitlyEndedTransaction(session: ClientSession) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction<T>(\n  session: ClientSession,\n  startTime: number,\n  fn: WithTransactionCallback<T>,\n  options: TransactionOptions = {}\n): Promise<any> {\n  session.startTransaction(options);\n\n  let promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!isPromiseLike(promise)) {\n    session.abortTransaction().catch(() => null);\n    return Promise.reject(\n      new MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise')\n    );\n  }\n\n  return promise.then(\n    result => {\n      if (userExplicitlyEndedTransaction(session)) {\n        return result;\n      }\n\n      return attemptTransactionCommit(session, startTime, fn, result, options);\n    },\n    err => {\n      function maybeRetryOrThrow(err: MongoError): Promise<any> {\n        if (\n          err instanceof MongoError &&\n          err.hasErrorLabel(MongoErrorLabel.TransientTransactionError) &&\n          hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)\n        ) {\n          return attemptTransaction(session, startTime, fn, options);\n        }\n\n        if (isMaxTimeMSExpiredError(err)) {\n          err.addErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult);\n        }\n\n        throw err;\n      }\n\n      if (session.inTransaction()) {\n        return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n      }\n\n      return maybeRetryOrThrow(err);\n    }\n  );\n}\n\nconst endTransactionAsync = promisify(\n  endTransaction as (\n    session: ClientSession,\n    commandName: 'abortTransaction' | 'commitTransaction',\n    callback: (error: Error) => void\n  ) => void\n);\n\nfunction endTransaction(\n  session: ClientSession,\n  commandName: 'abortTransaction' | 'commitTransaction',\n  callback: Callback<void>\n) {\n  // handle any initial problematic cases\n  const txnState = session.transaction.state;\n\n  if (txnState === TxnState.NO_TRANSACTION) {\n    callback(new MongoTransactionError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (\n      txnState === TxnState.STARTING_TRANSACTION ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(\n        new MongoTransactionError('Cannot call commitTransaction after calling abortTransaction')\n      );\n      return;\n    }\n  } else {\n    if (txnState === TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoTransactionError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (\n      txnState === TxnState.TRANSACTION_COMMITTED ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      callback(\n        new MongoTransactionError('Cannot call abortTransaction after calling commitTransaction')\n      );\n      return;\n    }\n  }\n\n  // construct and send the command\n  const command: Document = { [commandName]: 1 };\n\n  // apply a writeConcern if specified\n  let writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = { w: session.clientOptions.writeConcern.w };\n  }\n\n  if (txnState === TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({ wtimeoutMS: 10000 }, writeConcern, { w: 'majority' });\n  }\n\n  if (writeConcern) {\n    WriteConcern.apply(command, writeConcern);\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });\n  }\n\n  function commandHandler(error?: Error) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, { force: false });\n      }\n\n      // The spec indicates that we should ignore all errors on `abortTransaction`\n      return callback();\n    }\n\n    session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n    if (error instanceof MongoError) {\n      if (\n        error.hasErrorLabel(MongoErrorLabel.RetryableWriteError) ||\n        error instanceof MongoWriteConcernError ||\n        isMaxTimeMSExpiredError(error)\n      ) {\n        if (isUnknownTransactionCommitResult(error)) {\n          error.addErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult);\n\n          // per txns spec, must unpin session in this case\n          session.unpin({ error });\n        }\n      } else if (error.hasErrorLabel(MongoErrorLabel.TransientTransactionError)) {\n        session.unpin({ error });\n      }\n    }\n\n    callback(error);\n  }\n\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n\n  // send the command\n  executeOperation(\n    session.client,\n    new RunAdminCommandOperation(command, {\n      session,\n      readPreference: ReadPreference.primary,\n      bypassPinningCheck: true\n    }),\n    error => {\n      if (command.abortTransaction) {\n        // always unpin on abort regardless of command outcome\n        session.unpin();\n      }\n\n      if (error instanceof MongoError && error.hasErrorLabel(MongoErrorLabel.RetryableWriteError)) {\n        // SPEC-1185: apply majority write concern when retrying commitTransaction\n        if (command.commitTransaction) {\n          // per txns spec, must unpin session in this case\n          session.unpin({ force: true });\n\n          command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {\n            w: 'majority'\n          });\n        }\n\n        return executeOperation(\n          session.client,\n          new RunAdminCommandOperation(command, {\n            session,\n            readPreference: ReadPreference.primary,\n            bypassPinningCheck: true\n          }),\n          commandHandler\n        );\n      }\n\n      commandHandler(error);\n    }\n  );\n}\n\n/** @public */\nexport type ServerSessionId = { id: Binary };\n\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nexport class ServerSession {\n  id: ServerSessionId;\n  lastUse: number;\n  txnNumber: number;\n  isDirty: boolean;\n\n  /** @internal */\n  constructor() {\n    this.id = { id: new Binary(uuidV4(), Binary.SUBTYPE_UUID) };\n    this.lastUse = now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n  hasTimedOut(sessionTimeoutMinutes: number): boolean {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round(\n      ((calculateDurationInMs(this.lastUse) % 86400000) % 3600000) / 60000\n    );\n\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n\n  /**\n   * @internal\n   * Cloning meant to keep a readable reference to the server session data\n   * after ClientSession has ended\n   */\n  static clone(serverSession: ServerSession): Readonly<ServerSession> {\n    const arrayBuffer = new ArrayBuffer(16);\n    const idBytes = Buffer.from(arrayBuffer);\n    idBytes.set(serverSession.id.id.buffer);\n\n    const id = new Binary(idBytes, serverSession.id.id.sub_type);\n\n    // Manual prototype construction to avoid modifying the constructor of this class\n    return Object.setPrototypeOf(\n      {\n        id: { id },\n        lastUse: serverSession.lastUse,\n        txnNumber: serverSession.txnNumber,\n        isDirty: serverSession.isDirty\n      },\n      ServerSession.prototype\n    );\n  }\n}\n\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nexport class ServerSessionPool {\n  client: MongoClient;\n  sessions: List<ServerSession>;\n\n  constructor(client: MongoClient) {\n    if (client == null) {\n      throw new MongoRuntimeError('ServerSessionPool requires a MongoClient');\n    }\n\n    this.client = client;\n    this.sessions = new List<ServerSession>();\n  }\n\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n  acquire(): ServerSession {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n\n    let session: ServerSession | null = null;\n\n    // Try to obtain from session pool\n    while (this.sessions.length > 0) {\n      const potentialSession = this.sessions.shift();\n      if (\n        potentialSession != null &&\n        (!!this.client.topology?.loadBalanced ||\n          !potentialSession.hasTimedOut(sessionTimeoutMinutes))\n      ) {\n        session = potentialSession;\n        break;\n      }\n    }\n\n    // If nothing valid came from the pool make a new one\n    if (session == null) {\n      session = new ServerSession();\n    }\n\n    return session;\n  }\n\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n  release(session: ServerSession): void {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n\n    if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n\n    this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\n\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\nexport function applySession(\n  session: ClientSession,\n  command: Document,\n  options: CommandOptions\n): MongoDriverError | undefined {\n  if (session.hasEnded) {\n    return new MongoExpiredSessionError();\n  }\n\n  // May acquire serverSession here\n  const serverSession = session.serverSession;\n  if (serverSession == null) {\n    return new MongoRuntimeError('Unable to acquire server session');\n  }\n\n  if (options.writeConcern?.w === 0) {\n    if (session && session.explicit) {\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n      return new MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n    return;\n  }\n\n  // mark the last use of this session, and apply the `lsid`\n  serverSession.lastUse = now();\n  command.lsid = serverSession.id;\n\n  const inTxnOrTxnCommand = session.inTransaction() || isTransactionCommand(command);\n  const isRetryableWrite = !!options.willRetryWrite;\n\n  if (isRetryableWrite || inTxnOrTxnCommand) {\n    serverSession.txnNumber += session[kTxnNumberIncrement];\n    session[kTxnNumberIncrement] = 0;\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    command.txnNumber = Long.fromNumber(serverSession.txnNumber);\n  }\n\n  if (!inTxnOrTxnCommand) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    }\n\n    if (\n      session.supports.causalConsistency &&\n      session.operationTime &&\n      commandSupportsReadConcern(command)\n    ) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || { level: ReadConcernLevel.snapshot };\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });\n      }\n    }\n\n    return;\n  }\n\n  // now attempt to apply transaction-specific sessions data\n\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n\n    const readConcern =\n      session.transaction.options.readConcern || session?.clientOptions?.readConcern;\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    }\n  }\n  return;\n}\n\nexport function updateSessionFromResponse(session: ClientSession, document: Document): void {\n  if (document.$clusterTime) {\n    _advanceClusterTime(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n\n  if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = document.cursor?.atClusterTime || document.atClusterTime;\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}