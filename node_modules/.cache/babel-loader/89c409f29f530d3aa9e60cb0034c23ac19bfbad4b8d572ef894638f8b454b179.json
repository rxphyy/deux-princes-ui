{"ast":null,"code":"'use strict';\n\nconst {\n  signalsByName\n} = require('human-signals');\nconst getErrorPrefix = ({\n  timedOut,\n  timeout,\n  errorCode,\n  signal,\n  signalDescription,\n  exitCode,\n  isCanceled\n}) => {\n  if (timedOut) {\n    return `timed out after ${timeout} milliseconds`;\n  }\n  if (isCanceled) {\n    return 'was canceled';\n  }\n  if (errorCode !== undefined) {\n    return `failed with ${errorCode}`;\n  }\n  if (signal !== undefined) {\n    return `was killed with ${signal} (${signalDescription})`;\n  }\n  if (exitCode !== undefined) {\n    return `failed with exit code ${exitCode}`;\n  }\n  return 'failed';\n};\nconst makeError = ({\n  stdout,\n  stderr,\n  all,\n  error,\n  signal,\n  exitCode,\n  command,\n  escapedCommand,\n  timedOut,\n  isCanceled,\n  killed,\n  parsed: {\n    options: {\n      timeout\n    }\n  }\n}) => {\n  // `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n  // We normalize them to `undefined`\n  exitCode = exitCode === null ? undefined : exitCode;\n  signal = signal === null ? undefined : signal;\n  const signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n  const errorCode = error && error.code;\n  const prefix = getErrorPrefix({\n    timedOut,\n    timeout,\n    errorCode,\n    signal,\n    signalDescription,\n    exitCode,\n    isCanceled\n  });\n  const execaMessage = `Command ${prefix}: ${command}`;\n  const isError = Object.prototype.toString.call(error) === '[object Error]';\n  const shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n  const message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n  if (isError) {\n    error.originalMessage = error.message;\n    error.message = message;\n  } else {\n    error = new Error(message);\n  }\n  error.shortMessage = shortMessage;\n  error.command = command;\n  error.escapedCommand = escapedCommand;\n  error.exitCode = exitCode;\n  error.signal = signal;\n  error.signalDescription = signalDescription;\n  error.stdout = stdout;\n  error.stderr = stderr;\n  if (all !== undefined) {\n    error.all = all;\n  }\n  if ('bufferedData' in error) {\n    delete error.bufferedData;\n  }\n  error.failed = true;\n  error.timedOut = Boolean(timedOut);\n  error.isCanceled = isCanceled;\n  error.killed = killed && !timedOut;\n  return error;\n};\nmodule.exports = makeError;","map":{"version":3,"names":["signalsByName","require","getErrorPrefix","timedOut","timeout","errorCode","signal","signalDescription","exitCode","isCanceled","undefined","makeError","stdout","stderr","all","error","command","escapedCommand","killed","parsed","options","description","code","prefix","execaMessage","isError","Object","prototype","toString","call","shortMessage","message","filter","Boolean","join","originalMessage","Error","bufferedData","failed","module","exports"],"sources":["C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/execa/lib/error.js"],"sourcesContent":["'use strict';\nconst {signalsByName} = require('human-signals');\n\nconst getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {\n\tif (timedOut) {\n\t\treturn `timed out after ${timeout} milliseconds`;\n\t}\n\n\tif (isCanceled) {\n\t\treturn 'was canceled';\n\t}\n\n\tif (errorCode !== undefined) {\n\t\treturn `failed with ${errorCode}`;\n\t}\n\n\tif (signal !== undefined) {\n\t\treturn `was killed with ${signal} (${signalDescription})`;\n\t}\n\n\tif (exitCode !== undefined) {\n\t\treturn `failed with exit code ${exitCode}`;\n\t}\n\n\treturn 'failed';\n};\n\nconst makeError = ({\n\tstdout,\n\tstderr,\n\tall,\n\terror,\n\tsignal,\n\texitCode,\n\tcommand,\n\tescapedCommand,\n\ttimedOut,\n\tisCanceled,\n\tkilled,\n\tparsed: {options: {timeout}}\n}) => {\n\t// `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n\t// We normalize them to `undefined`\n\texitCode = exitCode === null ? undefined : exitCode;\n\tsignal = signal === null ? undefined : signal;\n\tconst signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n\n\tconst errorCode = error && error.code;\n\n\tconst prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});\n\tconst execaMessage = `Command ${prefix}: ${command}`;\n\tconst isError = Object.prototype.toString.call(error) === '[object Error]';\n\tconst shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n\tconst message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n\n\tif (isError) {\n\t\terror.originalMessage = error.message;\n\t\terror.message = message;\n\t} else {\n\t\terror = new Error(message);\n\t}\n\n\terror.shortMessage = shortMessage;\n\terror.command = command;\n\terror.escapedCommand = escapedCommand;\n\terror.exitCode = exitCode;\n\terror.signal = signal;\n\terror.signalDescription = signalDescription;\n\terror.stdout = stdout;\n\terror.stderr = stderr;\n\n\tif (all !== undefined) {\n\t\terror.all = all;\n\t}\n\n\tif ('bufferedData' in error) {\n\t\tdelete error.bufferedData;\n\t}\n\n\terror.failed = true;\n\terror.timedOut = Boolean(timedOut);\n\terror.isCanceled = isCanceled;\n\terror.killed = killed && !timedOut;\n\n\treturn error;\n};\n\nmodule.exports = makeError;\n"],"mappings":"AAAA,YAAY;;AACZ,MAAM;EAACA;AAAa,CAAC,GAAGC,OAAO,CAAC,eAAe,CAAC;AAEhD,MAAMC,cAAc,GAAGA,CAAC;EAACC,QAAQ;EAAEC,OAAO;EAAEC,SAAS;EAAEC,MAAM;EAAEC,iBAAiB;EAAEC,QAAQ;EAAEC;AAAU,CAAC,KAAK;EAC3G,IAAIN,QAAQ,EAAE;IACb,OAAQ,mBAAkBC,OAAQ,eAAc;EACjD;EAEA,IAAIK,UAAU,EAAE;IACf,OAAO,cAAc;EACtB;EAEA,IAAIJ,SAAS,KAAKK,SAAS,EAAE;IAC5B,OAAQ,eAAcL,SAAU,EAAC;EAClC;EAEA,IAAIC,MAAM,KAAKI,SAAS,EAAE;IACzB,OAAQ,mBAAkBJ,MAAO,KAAIC,iBAAkB,GAAE;EAC1D;EAEA,IAAIC,QAAQ,KAAKE,SAAS,EAAE;IAC3B,OAAQ,yBAAwBF,QAAS,EAAC;EAC3C;EAEA,OAAO,QAAQ;AAChB,CAAC;AAED,MAAMG,SAAS,GAAGA,CAAC;EAClBC,MAAM;EACNC,MAAM;EACNC,GAAG;EACHC,KAAK;EACLT,MAAM;EACNE,QAAQ;EACRQ,OAAO;EACPC,cAAc;EACdd,QAAQ;EACRM,UAAU;EACVS,MAAM;EACNC,MAAM,EAAE;IAACC,OAAO,EAAE;MAAChB;IAAO;EAAC;AAC5B,CAAC,KAAK;EACL;EACA;EACAI,QAAQ,GAAGA,QAAQ,KAAK,IAAI,GAAGE,SAAS,GAAGF,QAAQ;EACnDF,MAAM,GAAGA,MAAM,KAAK,IAAI,GAAGI,SAAS,GAAGJ,MAAM;EAC7C,MAAMC,iBAAiB,GAAGD,MAAM,KAAKI,SAAS,GAAGA,SAAS,GAAGV,aAAa,CAACM,MAAM,CAAC,CAACe,WAAW;EAE9F,MAAMhB,SAAS,GAAGU,KAAK,IAAIA,KAAK,CAACO,IAAI;EAErC,MAAMC,MAAM,GAAGrB,cAAc,CAAC;IAACC,QAAQ;IAAEC,OAAO;IAAEC,SAAS;IAAEC,MAAM;IAAEC,iBAAiB;IAAEC,QAAQ;IAAEC;EAAU,CAAC,CAAC;EAC9G,MAAMe,YAAY,GAAI,WAAUD,MAAO,KAAIP,OAAQ,EAAC;EACpD,MAAMS,OAAO,GAAGC,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACd,KAAK,CAAC,KAAK,gBAAgB;EAC1E,MAAMe,YAAY,GAAGL,OAAO,GAAI,GAAED,YAAa,KAAIT,KAAK,CAACgB,OAAQ,EAAC,GAAGP,YAAY;EACjF,MAAMO,OAAO,GAAG,CAACD,YAAY,EAAEjB,MAAM,EAAED,MAAM,CAAC,CAACoB,MAAM,CAACC,OAAO,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;EAEzE,IAAIT,OAAO,EAAE;IACZV,KAAK,CAACoB,eAAe,GAAGpB,KAAK,CAACgB,OAAO;IACrChB,KAAK,CAACgB,OAAO,GAAGA,OAAO;EACxB,CAAC,MAAM;IACNhB,KAAK,GAAG,IAAIqB,KAAK,CAACL,OAAO,CAAC;EAC3B;EAEAhB,KAAK,CAACe,YAAY,GAAGA,YAAY;EACjCf,KAAK,CAACC,OAAO,GAAGA,OAAO;EACvBD,KAAK,CAACE,cAAc,GAAGA,cAAc;EACrCF,KAAK,CAACP,QAAQ,GAAGA,QAAQ;EACzBO,KAAK,CAACT,MAAM,GAAGA,MAAM;EACrBS,KAAK,CAACR,iBAAiB,GAAGA,iBAAiB;EAC3CQ,KAAK,CAACH,MAAM,GAAGA,MAAM;EACrBG,KAAK,CAACF,MAAM,GAAGA,MAAM;EAErB,IAAIC,GAAG,KAAKJ,SAAS,EAAE;IACtBK,KAAK,CAACD,GAAG,GAAGA,GAAG;EAChB;EAEA,IAAI,cAAc,IAAIC,KAAK,EAAE;IAC5B,OAAOA,KAAK,CAACsB,YAAY;EAC1B;EAEAtB,KAAK,CAACuB,MAAM,GAAG,IAAI;EACnBvB,KAAK,CAACZ,QAAQ,GAAG8B,OAAO,CAAC9B,QAAQ,CAAC;EAClCY,KAAK,CAACN,UAAU,GAAGA,UAAU;EAC7BM,KAAK,CAACG,MAAM,GAAGA,MAAM,IAAI,CAACf,QAAQ;EAElC,OAAOY,KAAK;AACb,CAAC;AAEDwB,MAAM,CAACC,OAAO,GAAG7B,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}