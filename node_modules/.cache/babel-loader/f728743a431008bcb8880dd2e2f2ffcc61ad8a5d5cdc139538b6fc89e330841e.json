{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.prepareHandshakeDocument = exports.connect = exports.AUTH_PROVIDERS = void 0;\nconst net = require(\"net\");\nconst tls = require(\"tls\");\nconst constants_1 = require(\"../constants\");\nconst deps_1 = require(\"../deps\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst auth_provider_1 = require(\"./auth/auth_provider\");\nconst gssapi_1 = require(\"./auth/gssapi\");\nconst mongocr_1 = require(\"./auth/mongocr\");\nconst mongodb_aws_1 = require(\"./auth/mongodb_aws\");\nconst mongodb_oidc_1 = require(\"./auth/mongodb_oidc\");\nconst plain_1 = require(\"./auth/plain\");\nconst providers_1 = require(\"./auth/providers\");\nconst scram_1 = require(\"./auth/scram\");\nconst x509_1 = require(\"./auth/x509\");\nconst connection_1 = require(\"./connection\");\nconst constants_2 = require(\"./wire_protocol/constants\");\n/** @internal */\nexports.AUTH_PROVIDERS = new Map([[providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS()], [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR()], [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI()], [providers_1.AuthMechanism.MONGODB_OIDC, new mongodb_oidc_1.MongoDBOIDC()], [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256()], [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509()]]);\nfunction connect(options, callback) {\n  makeConnection({\n    ...options,\n    existingSocket: undefined\n  }, (err, socket) => {\n    if (err || !socket) {\n      return callback(err);\n    }\n    let ConnectionType = options.connectionType ?? connection_1.Connection;\n    if (options.autoEncrypter) {\n      ConnectionType = connection_1.CryptoConnection;\n    }\n    const connection = new ConnectionType(socket, options);\n    performInitialHandshake(connection, options).then(() => callback(undefined, connection), error => {\n      connection.destroy({\n        force: false\n      });\n      callback(error);\n    });\n  });\n}\nexports.connect = connect;\nfunction checkSupportedServer(hello, options) {\n  const maxWireVersion = Number(hello.maxWireVersion);\n  const minWireVersion = Number(hello.minWireVersion);\n  const serverVersionHighEnough = !Number.isNaN(maxWireVersion) && maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = !Number.isNaN(minWireVersion) && minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;\n    return new error_1.MongoCompatibilityError(message);\n  }\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${JSON.stringify(hello.maxWireVersion) ?? 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;\n  return new error_1.MongoCompatibilityError(message);\n}\nasync function performInitialHandshake(conn, options) {\n  const credentials = options.credentials;\n  if (credentials) {\n    if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !exports.AUTH_PROVIDERS.get(credentials.mechanism)) {\n      throw new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);\n    }\n  }\n  const authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n  conn.authContext = authContext;\n  const handshakeDoc = await prepareHandshakeDocument(authContext);\n  // @ts-expect-error: TODO(NODE-5141): The options need to be filtered properly, Connection options differ from Command options\n  const handshakeOptions = {\n    ...options\n  };\n  if (typeof options.connectTimeoutMS === 'number') {\n    // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n    handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n  }\n  const start = new Date().getTime();\n  const response = await conn.commandAsync((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions);\n  if (!('isWritablePrimary' in response)) {\n    // Provide hello-style response document.\n    response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];\n  }\n  if (response.helloOk) {\n    conn.helloOk = true;\n  }\n  const supportedServerErr = checkSupportedServer(response, options);\n  if (supportedServerErr) {\n    throw supportedServerErr;\n  }\n  if (options.loadBalanced) {\n    if (!response.serviceId) {\n      throw new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.');\n    }\n  }\n  // NOTE: This is metadata attached to the connection while porting away from\n  //       handshake being done in the `Server` class. Likely, it should be\n  //       relocated, or at very least restructured.\n  conn.hello = response;\n  conn.lastHelloMS = new Date().getTime() - start;\n  if (!response.arbiterOnly && credentials) {\n    // store the response on auth context\n    authContext.response = response;\n    const resolvedCredentials = credentials.resolveAuthMechanism(response);\n    const provider = exports.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n    if (!provider) {\n      throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`);\n    }\n    try {\n      await provider.auth(authContext);\n    } catch (error) {\n      if (error instanceof error_1.MongoError) {\n        error.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);\n        if ((0, error_1.needsRetryableWriteLabel)(error, response.maxWireVersion)) {\n          error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);\n        }\n      }\n      throw error;\n    }\n  }\n}\n/**\n * @internal\n *\n * This function is only exposed for testing purposes.\n */\nasync function prepareHandshakeDocument(authContext) {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const {\n    serverApi\n  } = authContext.connection;\n  const handshakeDoc = {\n    [serverApi?.version ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: 1,\n    helloOk: true,\n    client: options.metadata,\n    compression: compressors\n  };\n  if (options.loadBalanced === true) {\n    handshakeDoc.loadBalanced = true;\n  }\n  const credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n      const provider = exports.AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n      if (!provider) {\n        // This auth mechanism is always present.\n        throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`);\n      }\n      return provider.prepare(handshakeDoc, authContext);\n    }\n    const provider = exports.AUTH_PROVIDERS.get(credentials.mechanism);\n    if (!provider) {\n      throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);\n    }\n    return provider.prepare(handshakeDoc, authContext);\n  }\n  return handshakeDoc;\n}\nexports.prepareHandshakeDocument = prepareHandshakeDocument;\n/** @public */\nexports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];\n/** @public */\nexports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];\nfunction parseConnectOptions(options) {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n  const result = {};\n  for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\nfunction parseSslOptions(options) {\n  const result = parseConnectOptions(options);\n  // Merge in valid SSL options\n  for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n  if (options.existingSocket) {\n    result.socket = options.existingSocket;\n  }\n  // Set default sni servername to be the same as host\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n  return result;\n}\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\nfunction makeConnection(options, _callback) {\n  const useTLS = options.tls ?? false;\n  const noDelay = options.noDelay ?? true;\n  const connectTimeoutMS = options.connectTimeoutMS ?? 30000;\n  const rejectUnauthorized = options.rejectUnauthorized ?? true;\n  const existingSocket = options.existingSocket;\n  let socket;\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n    _callback(err, ret);\n  };\n  if (options.proxyHost != null) {\n    // Currently, only Socks5 is supported.\n    return makeSocks5Connection({\n      ...options,\n      connectTimeoutMS // Should always be present for Socks5\n    }, callback);\n  }\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n    socket = tlsSocket;\n  } else if (existingSocket) {\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n    // so we only need to handle the non-TLS case here (where existingSocket\n    // gives us all we need out of the box).\n    socket = existingSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n  socket.setKeepAlive(true, 300000);\n  socket.setTimeout(connectTimeoutMS);\n  socket.setNoDelay(noDelay);\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        // TODO(NODE-5192): wrap this with a MongoError subclass\n        return callback(socket.authorizationError);\n      }\n    }\n    socket.setTimeout(0);\n    callback(undefined, socket);\n  }\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n  if (existingSocket) {\n    process.nextTick(connectHandler);\n  } else {\n    socket.once(connectEvent, connectHandler);\n  }\n}\nlet socks = null;\nfunction loadSocks() {\n  if (socks == null) {\n    const socksImport = (0, deps_1.getSocks)();\n    if ('kModuleError' in socksImport) {\n      throw socksImport.kModuleError;\n    }\n    socks = socksImport;\n  }\n  return socks;\n}\nfunction makeSocks5Connection(options, callback) {\n  const hostAddress = utils_1.HostAddress.fromHostPort(options.proxyHost ?? '',\n  // proxyHost is guaranteed to set here\n  options.proxyPort ?? 1080);\n  // First, connect to the proxy server itself:\n  makeConnection({\n    ...options,\n    hostAddress,\n    tls: false,\n    proxyHost: undefined\n  }, (err, rawSocket) => {\n    if (err || !rawSocket) {\n      return callback(err);\n    }\n    const destination = parseConnectOptions(options);\n    if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n      return callback(new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts'));\n    }\n    try {\n      socks ??= loadSocks();\n    } catch (error) {\n      return callback(error);\n    }\n    // Then, establish the Socks5 proxy connection:\n    socks.SocksClient.createConnection({\n      existing_socket: rawSocket,\n      timeout: options.connectTimeoutMS,\n      command: 'connect',\n      destination: {\n        host: destination.host,\n        port: destination.port\n      },\n      proxy: {\n        // host and port are ignored because we pass existing_socket\n        host: 'iLoveJavaScript',\n        port: 0,\n        type: 5,\n        userId: options.proxyUsername || undefined,\n        password: options.proxyPassword || undefined\n      }\n    }).then(({\n      socket\n    }) => {\n      // Finally, now treat the resulting duplex stream as the\n      // socket over which we send and receive wire protocol messages:\n      makeConnection({\n        ...options,\n        existingSocket: socket,\n        proxyHost: undefined\n      }, callback);\n    }, error => callback(connectionFailureError('error', error)));\n  });\n}\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new error_1.MongoNetworkError(error_1.MongoError.buildErrorMessage(err), {\n        cause: err\n      });\n    case 'timeout':\n      return new error_1.MongoNetworkTimeoutError('connection timed out');\n    case 'close':\n      return new error_1.MongoNetworkError('connection closed');\n    case 'cancel':\n      return new error_1.MongoNetworkError('connection establishment was cancelled');\n    default:\n      return new error_1.MongoNetworkError('unknown network error');\n  }\n}","map":{"version":3,"names":["net","require","tls","constants_1","deps_1","error_1","utils_1","auth_provider_1","gssapi_1","mongocr_1","mongodb_aws_1","mongodb_oidc_1","plain_1","providers_1","scram_1","x509_1","connection_1","constants_2","exports","AUTH_PROVIDERS","Map","AuthMechanism","MONGODB_AWS","MongoDBAWS","MONGODB_CR","MongoCR","MONGODB_GSSAPI","GSSAPI","MONGODB_OIDC","MongoDBOIDC","MONGODB_PLAIN","Plain","MONGODB_SCRAM_SHA1","ScramSHA1","MONGODB_SCRAM_SHA256","ScramSHA256","MONGODB_X509","X509","connect","options","callback","makeConnection","existingSocket","undefined","err","socket","ConnectionType","connectionType","Connection","autoEncrypter","CryptoConnection","connection","performInitialHandshake","then","error","destroy","force","checkSupportedServer","hello","maxWireVersion","Number","minWireVersion","serverVersionHighEnough","isNaN","MIN_SUPPORTED_WIRE_VERSION","serverVersionLowEnough","MAX_SUPPORTED_WIRE_VERSION","message","hostAddress","JSON","stringify","MAX_SUPPORTED_SERVER_VERSION","MongoCompatibilityError","MIN_SUPPORTED_SERVER_VERSION","conn","credentials","mechanism","MONGODB_DEFAULT","get","MongoInvalidArgumentError","authContext","AuthContext","handshakeDoc","prepareHandshakeDocument","handshakeOptions","connectTimeoutMS","socketTimeoutMS","start","Date","getTime","response","commandAsync","ns","isWritablePrimary","LEGACY_HELLO_COMMAND","helloOk","supportedServerErr","loadBalanced","serviceId","lastHelloMS","arbiterOnly","resolvedCredentials","resolveAuthMechanism","provider","auth","MongoError","addErrorLabel","MongoErrorLabel","HandshakeError","needsRetryableWriteLabel","RetryableWriteError","compressors","serverApi","version","client","metadata","compression","username","saslSupportedMechs","source","prepare","LEGAL_TLS_SOCKET_OPTIONS","LEGAL_TCP_SOCKET_OPTIONS","parseConnectOptions","result","name","socketPath","path","host","port","MongoRuntimeError","parseSslOptions","servername","isIP","SOCKET_ERROR_EVENT_LIST","SOCKET_ERROR_EVENTS","Set","_callback","useTLS","noDelay","rejectUnauthorized","ret","proxyHost","makeSocks5Connection","tlsSocket","disableRenegotiation","createConnection","setKeepAlive","setTimeout","setNoDelay","connectEvent","cancellationHandler","errorHandler","eventName","forEach","event","removeAllListeners","cancellationToken","removeListener","connectHandler","connectionFailureError","authorizationError","once","process","nextTick","socks","loadSocks","socksImport","getSocks","kModuleError","HostAddress","fromHostPort","proxyPort","rawSocket","destination","SocksClient","existing_socket","timeout","command","proxy","type","userId","proxyUsername","password","proxyPassword","MongoNetworkError","buildErrorMessage","cause","MongoNetworkTimeoutError"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\cmap\\connect.ts"],"sourcesContent":["import type { Socket, SocketConnectOpts } from 'net';\nimport * as net from 'net';\nimport type { ConnectionOptions as TLSConnectionOpts, TLSSocket } from 'tls';\nimport * as tls from 'tls';\n\nimport type { Document } from '../bson';\nimport { LEGACY_HELLO_COMMAND } from '../constants';\nimport { getSocks, type SocksLib } from '../deps';\nimport {\n  MongoCompatibilityError,\n  MongoError,\n  MongoErrorLabel,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoRuntimeError,\n  needsRetryableWriteLabel\n} from '../error';\nimport { type Callback, HostAddress, ns } from '../utils';\nimport { AuthContext, type AuthProvider } from './auth/auth_provider';\nimport { GSSAPI } from './auth/gssapi';\nimport { MongoCR } from './auth/mongocr';\nimport { MongoDBAWS } from './auth/mongodb_aws';\nimport { MongoDBOIDC } from './auth/mongodb_oidc';\nimport { Plain } from './auth/plain';\nimport { AuthMechanism } from './auth/providers';\nimport { ScramSHA1, ScramSHA256 } from './auth/scram';\nimport { X509 } from './auth/x509';\nimport {\n  type CommandOptions,\n  Connection,\n  type ConnectionOptions,\n  CryptoConnection\n} from './connection';\nimport type { ClientMetadata } from './handshake/client_metadata';\nimport {\n  MAX_SUPPORTED_SERVER_VERSION,\n  MAX_SUPPORTED_WIRE_VERSION,\n  MIN_SUPPORTED_SERVER_VERSION,\n  MIN_SUPPORTED_WIRE_VERSION\n} from './wire_protocol/constants';\n\n/** @internal */\nexport const AUTH_PROVIDERS = new Map<AuthMechanism | string, AuthProvider>([\n  [AuthMechanism.MONGODB_AWS, new MongoDBAWS()],\n  [AuthMechanism.MONGODB_CR, new MongoCR()],\n  [AuthMechanism.MONGODB_GSSAPI, new GSSAPI()],\n  [AuthMechanism.MONGODB_OIDC, new MongoDBOIDC()],\n  [AuthMechanism.MONGODB_PLAIN, new Plain()],\n  [AuthMechanism.MONGODB_SCRAM_SHA1, new ScramSHA1()],\n  [AuthMechanism.MONGODB_SCRAM_SHA256, new ScramSHA256()],\n  [AuthMechanism.MONGODB_X509, new X509()]\n]);\n\n/** @public */\nexport type Stream = Socket | TLSSocket;\n\nexport function connect(options: ConnectionOptions, callback: Callback<Connection>): void {\n  makeConnection({ ...options, existingSocket: undefined }, (err, socket) => {\n    if (err || !socket) {\n      return callback(err);\n    }\n\n    let ConnectionType = options.connectionType ?? Connection;\n    if (options.autoEncrypter) {\n      ConnectionType = CryptoConnection;\n    }\n\n    const connection = new ConnectionType(socket, options);\n\n    performInitialHandshake(connection, options).then(\n      () => callback(undefined, connection),\n      error => {\n        connection.destroy({ force: false });\n        callback(error);\n      }\n    );\n  });\n}\n\nfunction checkSupportedServer(hello: Document, options: ConnectionOptions) {\n  const maxWireVersion = Number(hello.maxWireVersion);\n  const minWireVersion = Number(hello.minWireVersion);\n  const serverVersionHighEnough =\n    !Number.isNaN(maxWireVersion) && maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough =\n    !Number.isNaN(minWireVersion) && minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(\n      hello.minWireVersion\n    )}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoCompatibilityError(message);\n  }\n\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${\n    JSON.stringify(hello.maxWireVersion) ?? 0\n  }, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoCompatibilityError(message);\n}\n\nasync function performInitialHandshake(\n  conn: Connection,\n  options: ConnectionOptions\n): Promise<void> {\n  const credentials = options.credentials;\n\n  if (credentials) {\n    if (\n      !(credentials.mechanism === AuthMechanism.MONGODB_DEFAULT) &&\n      !AUTH_PROVIDERS.get(credentials.mechanism)\n    ) {\n      throw new MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);\n    }\n  }\n\n  const authContext = new AuthContext(conn, credentials, options);\n  conn.authContext = authContext;\n\n  const handshakeDoc = await prepareHandshakeDocument(authContext);\n\n  // @ts-expect-error: TODO(NODE-5141): The options need to be filtered properly, Connection options differ from Command options\n  const handshakeOptions: CommandOptions = { ...options };\n  if (typeof options.connectTimeoutMS === 'number') {\n    // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n    handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n  }\n\n  const start = new Date().getTime();\n  const response = await conn.commandAsync(ns('admin.$cmd'), handshakeDoc, handshakeOptions);\n\n  if (!('isWritablePrimary' in response)) {\n    // Provide hello-style response document.\n    response.isWritablePrimary = response[LEGACY_HELLO_COMMAND];\n  }\n\n  if (response.helloOk) {\n    conn.helloOk = true;\n  }\n\n  const supportedServerErr = checkSupportedServer(response, options);\n  if (supportedServerErr) {\n    throw supportedServerErr;\n  }\n\n  if (options.loadBalanced) {\n    if (!response.serviceId) {\n      throw new MongoCompatibilityError(\n        'Driver attempted to initialize in load balancing mode, ' +\n          'but the server does not support this mode.'\n      );\n    }\n  }\n\n  // NOTE: This is metadata attached to the connection while porting away from\n  //       handshake being done in the `Server` class. Likely, it should be\n  //       relocated, or at very least restructured.\n  conn.hello = response;\n  conn.lastHelloMS = new Date().getTime() - start;\n\n  if (!response.arbiterOnly && credentials) {\n    // store the response on auth context\n    authContext.response = response;\n\n    const resolvedCredentials = credentials.resolveAuthMechanism(response);\n    const provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n    if (!provider) {\n      throw new MongoInvalidArgumentError(\n        `No AuthProvider for ${resolvedCredentials.mechanism} defined.`\n      );\n    }\n\n    try {\n      await provider.auth(authContext);\n    } catch (error) {\n      if (error instanceof MongoError) {\n        error.addErrorLabel(MongoErrorLabel.HandshakeError);\n        if (needsRetryableWriteLabel(error, response.maxWireVersion)) {\n          error.addErrorLabel(MongoErrorLabel.RetryableWriteError);\n        }\n      }\n      throw error;\n    }\n  }\n}\n\nexport interface HandshakeDocument extends Document {\n  /**\n   * @deprecated Use hello instead\n   */\n  ismaster?: boolean;\n  hello?: boolean;\n  helloOk?: boolean;\n  client: ClientMetadata;\n  compression: string[];\n  saslSupportedMechs?: string;\n  loadBalanced?: boolean;\n}\n\n/**\n * @internal\n *\n * This function is only exposed for testing purposes.\n */\nexport async function prepareHandshakeDocument(\n  authContext: AuthContext\n): Promise<HandshakeDocument> {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const { serverApi } = authContext.connection;\n\n  const handshakeDoc: HandshakeDocument = {\n    [serverApi?.version ? 'hello' : LEGACY_HELLO_COMMAND]: 1,\n    helloOk: true,\n    client: options.metadata,\n    compression: compressors\n  };\n\n  if (options.loadBalanced === true) {\n    handshakeDoc.loadBalanced = true;\n  }\n\n  const credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism === AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n\n      const provider = AUTH_PROVIDERS.get(AuthMechanism.MONGODB_SCRAM_SHA256);\n      if (!provider) {\n        // This auth mechanism is always present.\n        throw new MongoInvalidArgumentError(\n          `No AuthProvider for ${AuthMechanism.MONGODB_SCRAM_SHA256} defined.`\n        );\n      }\n      return provider.prepare(handshakeDoc, authContext);\n    }\n    const provider = AUTH_PROVIDERS.get(credentials.mechanism);\n    if (!provider) {\n      throw new MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);\n    }\n    return provider.prepare(handshakeDoc, authContext);\n  }\n  return handshakeDoc;\n}\n\n/** @public */\nexport const LEGAL_TLS_SOCKET_OPTIONS = [\n  'ALPNProtocols',\n  'ca',\n  'cert',\n  'checkServerIdentity',\n  'ciphers',\n  'crl',\n  'ecdhCurve',\n  'key',\n  'minDHSize',\n  'passphrase',\n  'pfx',\n  'rejectUnauthorized',\n  'secureContext',\n  'secureProtocol',\n  'servername',\n  'session'\n] as const;\n\n/** @public */\nexport const LEGAL_TCP_SOCKET_OPTIONS = [\n  'family',\n  'hints',\n  'localAddress',\n  'localPort',\n  'lookup'\n] as const;\n\nfunction parseConnectOptions(options: ConnectionOptions): SocketConnectOpts {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new MongoInvalidArgumentError('Option \"hostAddress\" is required');\n\n  const result: Partial<net.TcpNetConnectOpts & net.IpcNetConnectOpts> = {};\n  for (const name of LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      (result as Document)[name] = options[name];\n    }\n  }\n\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result as net.IpcNetConnectOpts;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result as net.TcpNetConnectOpts;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\n\ntype MakeConnectionOptions = ConnectionOptions & { existingSocket?: Stream };\n\nfunction parseSslOptions(options: MakeConnectionOptions): TLSConnectionOpts {\n  const result: TLSConnectionOpts = parseConnectOptions(options);\n  // Merge in valid SSL options\n  for (const name of LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      (result as Document)[name] = options[name];\n    }\n  }\n\n  if (options.existingSocket) {\n    result.socket = options.existingSocket;\n  }\n\n  // Set default sni servername to be the same as host\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'] as const;\ntype ErrorHandlerEventName = (typeof SOCKET_ERROR_EVENT_LIST)[number] | 'cancel';\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\n\nfunction makeConnection(options: MakeConnectionOptions, _callback: Callback<Stream>) {\n  const useTLS = options.tls ?? false;\n  const noDelay = options.noDelay ?? true;\n  const connectTimeoutMS = options.connectTimeoutMS ?? 30000;\n  const rejectUnauthorized = options.rejectUnauthorized ?? true;\n  const existingSocket = options.existingSocket;\n\n  let socket: Stream;\n  const callback: Callback<Stream> = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  if (options.proxyHost != null) {\n    // Currently, only Socks5 is supported.\n    return makeSocks5Connection(\n      {\n        ...options,\n        connectTimeoutMS // Should always be present for Socks5\n      },\n      callback\n    );\n  }\n\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n    socket = tlsSocket;\n  } else if (existingSocket) {\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n    // so we only need to handle the non-TLS case here (where existingSocket\n    // gives us all we need out of the box).\n    socket = existingSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n\n  socket.setKeepAlive(true, 300000);\n  socket.setTimeout(connectTimeoutMS);\n  socket.setNoDelay(noDelay);\n\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\n  let cancellationHandler: (err: Error) => void;\n  function errorHandler(eventName: ErrorHandlerEventName) {\n    return (err: Error) => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        // TODO(NODE-5192): wrap this with a MongoError subclass\n        return callback(socket.authorizationError);\n      }\n    }\n\n    socket.setTimeout(0);\n    callback(undefined, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  if (existingSocket) {\n    process.nextTick(connectHandler);\n  } else {\n    socket.once(connectEvent, connectHandler);\n  }\n}\n\nlet socks: SocksLib | null = null;\nfunction loadSocks() {\n  if (socks == null) {\n    const socksImport = getSocks();\n    if ('kModuleError' in socksImport) {\n      throw socksImport.kModuleError;\n    }\n    socks = socksImport;\n  }\n  return socks;\n}\n\nfunction makeSocks5Connection(options: MakeConnectionOptions, callback: Callback<Stream>) {\n  const hostAddress = HostAddress.fromHostPort(\n    options.proxyHost ?? '', // proxyHost is guaranteed to set here\n    options.proxyPort ?? 1080\n  );\n\n  // First, connect to the proxy server itself:\n  makeConnection(\n    {\n      ...options,\n      hostAddress,\n      tls: false,\n      proxyHost: undefined\n    },\n    (err, rawSocket) => {\n      if (err || !rawSocket) {\n        return callback(err);\n      }\n\n      const destination = parseConnectOptions(options) as net.TcpNetConnectOpts;\n      if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n        return callback(\n          new MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts')\n        );\n      }\n\n      try {\n        socks ??= loadSocks();\n      } catch (error) {\n        return callback(error);\n      }\n\n      // Then, establish the Socks5 proxy connection:\n      socks.SocksClient.createConnection({\n        existing_socket: rawSocket,\n        timeout: options.connectTimeoutMS,\n        command: 'connect',\n        destination: {\n          host: destination.host,\n          port: destination.port\n        },\n        proxy: {\n          // host and port are ignored because we pass existing_socket\n          host: 'iLoveJavaScript',\n          port: 0,\n          type: 5,\n          userId: options.proxyUsername || undefined,\n          password: options.proxyPassword || undefined\n        }\n      }).then(\n        ({ socket }) => {\n          // Finally, now treat the resulting duplex stream as the\n          // socket over which we send and receive wire protocol messages:\n          makeConnection(\n            {\n              ...options,\n              existingSocket: socket,\n              proxyHost: undefined\n            },\n            callback\n          );\n        },\n        error => callback(connectionFailureError('error', error))\n      );\n    }\n  );\n}\n\nfunction connectionFailureError(type: ErrorHandlerEventName, err: Error) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(MongoError.buildErrorMessage(err), { cause: err });\n    case 'timeout':\n      return new MongoNetworkTimeoutError('connection timed out');\n    case 'close':\n      return new MongoNetworkError('connection closed');\n    case 'cancel':\n      return new MongoNetworkError('connection establishment was cancelled');\n    default:\n      return new MongoNetworkError('unknown network error');\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}