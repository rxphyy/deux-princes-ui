{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Cache = exports.ExpiringCacheEntry = void 0;\n/* 5 minutes in milliseconds */\nconst EXPIRATION_BUFFER_MS = 300000;\n/**\n * An entry in a cache that can expire in a certain amount of time.\n */\nclass ExpiringCacheEntry {\n  /**\n   * Create a new expiring token entry.\n   */\n  constructor(expiration) {\n    this.expiration = this.expirationTime(expiration);\n  }\n  /**\n   * The entry is still valid if the expiration is more than\n   * 5 minutes from the expiration time.\n   */\n  isValid() {\n    return this.expiration - Date.now() > EXPIRATION_BUFFER_MS;\n  }\n  /**\n   * Get an expiration time in milliseconds past epoch.\n   */\n  expirationTime(expiresInSeconds) {\n    return Date.now() + expiresInSeconds * 1000;\n  }\n}\nexports.ExpiringCacheEntry = ExpiringCacheEntry;\n/**\n * Base class for OIDC caches.\n */\nclass Cache {\n  /**\n   * Create a new cache.\n   */\n  constructor() {\n    this.entries = new Map();\n  }\n  /**\n   * Clear the cache.\n   */\n  clear() {\n    this.entries.clear();\n  }\n  /**\n   * Create a cache key from the address and username.\n   */\n  hashedCacheKey(address, username, callbackHash) {\n    return JSON.stringify([address, username, callbackHash]);\n  }\n}\nexports.Cache = Cache;","map":{"version":3,"names":["EXPIRATION_BUFFER_MS","ExpiringCacheEntry","constructor","expiration","expirationTime","isValid","Date","now","expiresInSeconds","exports","Cache","entries","Map","clear","hashedCacheKey","address","username","callbackHash","JSON","stringify"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\cmap\\auth\\mongodb_oidc\\cache.ts"],"sourcesContent":["/* 5 minutes in milliseconds */\nconst EXPIRATION_BUFFER_MS = 300000;\n\n/**\n * An entry in a cache that can expire in a certain amount of time.\n */\nexport abstract class ExpiringCacheEntry {\n  expiration: number;\n\n  /**\n   * Create a new expiring token entry.\n   */\n  constructor(expiration: number) {\n    this.expiration = this.expirationTime(expiration);\n  }\n  /**\n   * The entry is still valid if the expiration is more than\n   * 5 minutes from the expiration time.\n   */\n  isValid() {\n    return this.expiration - Date.now() > EXPIRATION_BUFFER_MS;\n  }\n\n  /**\n   * Get an expiration time in milliseconds past epoch.\n   */\n  private expirationTime(expiresInSeconds: number): number {\n    return Date.now() + expiresInSeconds * 1000;\n  }\n}\n\n/**\n * Base class for OIDC caches.\n */\nexport abstract class Cache<T> {\n  entries: Map<string, T>;\n\n  /**\n   * Create a new cache.\n   */\n  constructor() {\n    this.entries = new Map<string, T>();\n  }\n\n  /**\n   * Clear the cache.\n   */\n  clear() {\n    this.entries.clear();\n  }\n\n  /**\n   * Implement the cache key for the token.\n   */\n  abstract cacheKey(address: string, username: string, callbackHash: string): string;\n\n  /**\n   * Create a cache key from the address and username.\n   */\n  hashedCacheKey(address: string, username: string, callbackHash: string): string {\n    return JSON.stringify([address, username, callbackHash]);\n  }\n}\n"],"mappings":";;;;;;AAAA;AACA,MAAMA,oBAAoB,GAAG,MAAM;AAEnC;;;AAGA,MAAsBC,kBAAkB;EAGtC;;;EAGAC,YAAYC,UAAkB;IAC5B,IAAI,CAACA,UAAU,GAAG,IAAI,CAACC,cAAc,CAACD,UAAU,CAAC;EACnD;EACA;;;;EAIAE,OAAOA,CAAA;IACL,OAAO,IAAI,CAACF,UAAU,GAAGG,IAAI,CAACC,GAAG,EAAE,GAAGP,oBAAoB;EAC5D;EAEA;;;EAGQI,cAAcA,CAACI,gBAAwB;IAC7C,OAAOF,IAAI,CAACC,GAAG,EAAE,GAAGC,gBAAgB,GAAG,IAAI;EAC7C;;AAtBFC,OAAA,CAAAR,kBAAA,GAAAA,kBAAA;AAyBA;;;AAGA,MAAsBS,KAAK;EAGzB;;;EAGAR,YAAA;IACE,IAAI,CAACS,OAAO,GAAG,IAAIC,GAAG,EAAa;EACrC;EAEA;;;EAGAC,KAAKA,CAAA;IACH,IAAI,CAACF,OAAO,CAACE,KAAK,EAAE;EACtB;EAOA;;;EAGAC,cAAcA,CAACC,OAAe,EAAEC,QAAgB,EAAEC,YAAoB;IACpE,OAAOC,IAAI,CAACC,SAAS,CAAC,CAACJ,OAAO,EAAEC,QAAQ,EAAEC,YAAY,CAAC,CAAC;EAC1D;;AA3BFR,OAAA,CAAAC,KAAA,GAAAA,KAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}