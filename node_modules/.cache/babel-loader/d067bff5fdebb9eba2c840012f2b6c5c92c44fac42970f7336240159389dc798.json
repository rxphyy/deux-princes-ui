{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallbackLockCache = void 0;\nconst error_1 = require(\"../../../error\");\nconst cache_1 = require(\"./cache\");\n/** Error message for when request callback is missing. */\nconst REQUEST_CALLBACK_REQUIRED_ERROR = 'Auth mechanism property REQUEST_TOKEN_CALLBACK is required.';\n/* Counter for function \"hashes\".*/\nlet FN_HASH_COUNTER = 0;\n/* No function present function */\nconst NO_FUNCTION = async () => ({\n  accessToken: 'test'\n});\n/* The map of function hashes */\nconst FN_HASHES = new WeakMap();\n/* Put the no function hash in the map. */\nFN_HASHES.set(NO_FUNCTION, FN_HASH_COUNTER);\n/**\n * A cache of request and refresh callbacks per server/user.\n */\nclass CallbackLockCache extends cache_1.Cache {\n  /**\n   * Get the callbacks for the connection and credentials. If an entry does not\n   * exist a new one will get set.\n   */\n  getEntry(connection, credentials) {\n    const requestCallback = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n    const refreshCallback = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n    if (!requestCallback) {\n      throw new error_1.MongoInvalidArgumentError(REQUEST_CALLBACK_REQUIRED_ERROR);\n    }\n    const callbackHash = hashFunctions(requestCallback, refreshCallback);\n    const key = this.cacheKey(connection.address, credentials.username, callbackHash);\n    const entry = this.entries.get(key);\n    if (entry) {\n      return entry;\n    }\n    return this.addEntry(key, callbackHash, requestCallback, refreshCallback);\n  }\n  /**\n   * Set locked callbacks on for connection and credentials.\n   */\n  addEntry(key, callbackHash, requestCallback, refreshCallback) {\n    const entry = {\n      requestCallback: withLock(requestCallback),\n      refreshCallback: refreshCallback ? withLock(refreshCallback) : undefined,\n      callbackHash: callbackHash\n    };\n    this.entries.set(key, entry);\n    return entry;\n  }\n  /**\n   * Create a cache key from the address and username.\n   */\n  cacheKey(address, username, callbackHash) {\n    return this.hashedCacheKey(address, username, callbackHash);\n  }\n}\nexports.CallbackLockCache = CallbackLockCache;\n/**\n * Ensure the callback is only executed one at a time.\n */\nfunction withLock(callback) {\n  let lock = Promise.resolve();\n  return async (info, context) => {\n    await lock;\n    lock = lock.then(() => callback(info, context));\n    return lock;\n  };\n}\n/**\n * Get the hash string for the request and refresh functions.\n */\nfunction hashFunctions(requestFn, refreshFn) {\n  let requestHash = FN_HASHES.get(requestFn);\n  let refreshHash = FN_HASHES.get(refreshFn ?? NO_FUNCTION);\n  if (requestHash == null) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    requestHash = FN_HASH_COUNTER;\n    FN_HASHES.set(requestFn, FN_HASH_COUNTER);\n  }\n  if (refreshHash == null && refreshFn) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    refreshHash = FN_HASH_COUNTER;\n    FN_HASHES.set(refreshFn, FN_HASH_COUNTER);\n  }\n  return `${requestHash}-${refreshHash}`;\n}","map":{"version":3,"names":["error_1","require","cache_1","REQUEST_CALLBACK_REQUIRED_ERROR","FN_HASH_COUNTER","NO_FUNCTION","accessToken","FN_HASHES","WeakMap","set","CallbackLockCache","Cache","getEntry","connection","credentials","requestCallback","mechanismProperties","REQUEST_TOKEN_CALLBACK","refreshCallback","REFRESH_TOKEN_CALLBACK","MongoInvalidArgumentError","callbackHash","hashFunctions","key","cacheKey","address","username","entry","entries","get","addEntry","withLock","undefined","hashedCacheKey","exports","callback","lock","Promise","resolve","info","context","then","requestFn","refreshFn","requestHash","refreshHash"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\cmap\\auth\\mongodb_oidc\\callback_lock_cache.ts"],"sourcesContent":["import { MongoInvalidArgumentError } from '../../../error';\nimport type { Connection } from '../../connection';\nimport type { MongoCredentials } from '../mongo_credentials';\nimport type {\n  IdPServerInfo,\n  IdPServerResponse,\n  OIDCCallbackContext,\n  OIDCRefreshFunction,\n  OIDCRequestFunction\n} from '../mongodb_oidc';\nimport { Cache } from './cache';\n\n/** Error message for when request callback is missing. */\nconst REQUEST_CALLBACK_REQUIRED_ERROR =\n  'Auth mechanism property REQUEST_TOKEN_CALLBACK is required.';\n/* Counter for function \"hashes\".*/\nlet FN_HASH_COUNTER = 0;\n/* No function present function */\nconst NO_FUNCTION: OIDCRequestFunction = async () => ({ accessToken: 'test' });\n/* The map of function hashes */\nconst FN_HASHES = new WeakMap<OIDCRequestFunction | OIDCRefreshFunction, number>();\n/* Put the no function hash in the map. */\nFN_HASHES.set(NO_FUNCTION, FN_HASH_COUNTER);\n\n/**\n * An entry of callbacks in the cache.\n */\ninterface CallbacksEntry {\n  requestCallback: OIDCRequestFunction;\n  refreshCallback?: OIDCRefreshFunction;\n  callbackHash: string;\n}\n\n/**\n * A cache of request and refresh callbacks per server/user.\n */\nexport class CallbackLockCache extends Cache<CallbacksEntry> {\n  /**\n   * Get the callbacks for the connection and credentials. If an entry does not\n   * exist a new one will get set.\n   */\n  getEntry(connection: Connection, credentials: MongoCredentials): CallbacksEntry {\n    const requestCallback = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n    const refreshCallback = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n    if (!requestCallback) {\n      throw new MongoInvalidArgumentError(REQUEST_CALLBACK_REQUIRED_ERROR);\n    }\n    const callbackHash = hashFunctions(requestCallback, refreshCallback);\n    const key = this.cacheKey(connection.address, credentials.username, callbackHash);\n    const entry = this.entries.get(key);\n    if (entry) {\n      return entry;\n    }\n    return this.addEntry(key, callbackHash, requestCallback, refreshCallback);\n  }\n\n  /**\n   * Set locked callbacks on for connection and credentials.\n   */\n  private addEntry(\n    key: string,\n    callbackHash: string,\n    requestCallback: OIDCRequestFunction,\n    refreshCallback?: OIDCRefreshFunction\n  ): CallbacksEntry {\n    const entry = {\n      requestCallback: withLock(requestCallback),\n      refreshCallback: refreshCallback ? withLock(refreshCallback) : undefined,\n      callbackHash: callbackHash\n    };\n    this.entries.set(key, entry);\n    return entry;\n  }\n\n  /**\n   * Create a cache key from the address and username.\n   */\n  cacheKey(address: string, username: string, callbackHash: string): string {\n    return this.hashedCacheKey(address, username, callbackHash);\n  }\n}\n\n/**\n * Ensure the callback is only executed one at a time.\n */\nfunction withLock(callback: OIDCRequestFunction | OIDCRefreshFunction) {\n  let lock: Promise<any> = Promise.resolve();\n  return async (info: IdPServerInfo, context: OIDCCallbackContext): Promise<IdPServerResponse> => {\n    await lock;\n    lock = lock.then(() => callback(info, context));\n    return lock;\n  };\n}\n\n/**\n * Get the hash string for the request and refresh functions.\n */\nfunction hashFunctions(requestFn: OIDCRequestFunction, refreshFn?: OIDCRefreshFunction): string {\n  let requestHash = FN_HASHES.get(requestFn);\n  let refreshHash = FN_HASHES.get(refreshFn ?? NO_FUNCTION);\n  if (requestHash == null) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    requestHash = FN_HASH_COUNTER;\n    FN_HASHES.set(requestFn, FN_HASH_COUNTER);\n  }\n  if (refreshHash == null && refreshFn) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    refreshHash = FN_HASH_COUNTER;\n    FN_HASHES.set(refreshFn, FN_HASH_COUNTER);\n  }\n  return `${requestHash}-${refreshHash}`;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}