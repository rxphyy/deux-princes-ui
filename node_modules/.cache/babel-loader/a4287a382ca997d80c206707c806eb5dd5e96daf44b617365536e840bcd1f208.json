{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.refreshKMSCredentials = exports.isEmptyCredentials = void 0;\nconst aws_1 = require(\"./aws\");\nconst azure_1 = require(\"./azure\");\nconst gcp_1 = require(\"./gcp\");\n/**\n * Auto credential fetching should only occur when the provider is defined on the kmsProviders map\n * and the settings are an empty object.\n *\n * This is distinct from a nullish provider key.\n *\n * @internal - exposed for testing purposes only\n */\nfunction isEmptyCredentials(providerName, kmsProviders) {\n  const provider = kmsProviders[providerName];\n  if (provider == null) {\n    return false;\n  }\n  return typeof provider === 'object' && Object.keys(provider).length === 0;\n}\nexports.isEmptyCredentials = isEmptyCredentials;\n/**\n * Load cloud provider credentials for the user provided KMS providers.\n * Credentials will only attempt to get loaded if they do not exist\n * and no existing credentials will get overwritten.\n *\n * @internal\n */\nasync function refreshKMSCredentials(kmsProviders) {\n  let finalKMSProviders = kmsProviders;\n  if (isEmptyCredentials('aws', kmsProviders)) {\n    finalKMSProviders = await (0, aws_1.loadAWSCredentials)(finalKMSProviders);\n  }\n  if (isEmptyCredentials('gcp', kmsProviders)) {\n    finalKMSProviders = await (0, gcp_1.loadGCPCredentials)(finalKMSProviders);\n  }\n  if (isEmptyCredentials('azure', kmsProviders)) {\n    finalKMSProviders = await (0, azure_1.loadAzureCredentials)(finalKMSProviders);\n  }\n  return finalKMSProviders;\n}\nexports.refreshKMSCredentials = refreshKMSCredentials;","map":{"version":3,"names":["aws_1","require","azure_1","gcp_1","isEmptyCredentials","providerName","kmsProviders","provider","Object","keys","length","exports","refreshKMSCredentials","finalKMSProviders","loadAWSCredentials","loadGCPCredentials","loadAzureCredentials"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\client-side-encryption\\providers\\index.ts"],"sourcesContent":["import { loadAWSCredentials } from './aws';\nimport { loadAzureCredentials } from './azure';\nimport { loadGCPCredentials } from './gcp';\n\n/**\n * @public\n */\nexport type ClientEncryptionDataKeyProvider = 'aws' | 'azure' | 'gcp' | 'local' | 'kmip';\n\n/**\n * @public\n * Configuration options that are used by specific KMS providers during key generation, encryption, and decryption.\n */\nexport interface KMSProviders {\n  /**\n   * Configuration options for using 'aws' as your KMS provider\n   */\n  aws?:\n    | {\n        /**\n         * The access key used for the AWS KMS provider\n         */\n        accessKeyId: string;\n\n        /**\n         * The secret access key used for the AWS KMS provider\n         */\n        secretAccessKey: string;\n\n        /**\n         * An optional AWS session token that will be used as the\n         * X-Amz-Security-Token header for AWS requests.\n         */\n        sessionToken?: string;\n      }\n    | Record<string, never>;\n\n  /**\n   * Configuration options for using 'local' as your KMS provider\n   */\n  local?: {\n    /**\n     * The master key used to encrypt/decrypt data keys.\n     * A 96-byte long Buffer or base64 encoded string.\n     */\n    key: Buffer | string;\n  };\n\n  /**\n   * Configuration options for using 'kmip' as your KMS provider\n   */\n  kmip?: {\n    /**\n     * The output endpoint string.\n     * The endpoint consists of a hostname and port separated by a colon.\n     * E.g. \"example.com:123\". A port is always present.\n     */\n    endpoint?: string;\n  };\n\n  /**\n   * Configuration options for using 'azure' as your KMS provider\n   */\n  azure?:\n    | {\n        /**\n         * The tenant ID identifies the organization for the account\n         */\n        tenantId: string;\n\n        /**\n         * The client ID to authenticate a registered application\n         */\n        clientId: string;\n\n        /**\n         * The client secret to authenticate a registered application\n         */\n        clientSecret: string;\n\n        /**\n         * If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\".\n         * This is optional, and only needed if customer is using a non-commercial Azure instance\n         * (e.g. a government or China account, which use different URLs).\n         * Defaults to \"login.microsoftonline.com\"\n         */\n        identityPlatformEndpoint?: string | undefined;\n      }\n    | {\n        /**\n         * If present, an access token to authenticate with Azure.\n         */\n        accessToken: string;\n      }\n    | Record<string, never>;\n\n  /**\n   * Configuration options for using 'gcp' as your KMS provider\n   */\n  gcp?:\n    | {\n        /**\n         * The service account email to authenticate\n         */\n        email: string;\n\n        /**\n         * A PKCS#8 encrypted key. This can either be a base64 string or a binary representation\n         */\n        privateKey: string | Buffer;\n\n        /**\n         * If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\".\n         * Defaults to \"oauth2.googleapis.com\"\n         */\n        endpoint?: string | undefined;\n      }\n    | {\n        /**\n         * If present, an access token to authenticate with GCP.\n         */\n        accessToken: string;\n      }\n    | Record<string, never>;\n}\n\n/**\n * Auto credential fetching should only occur when the provider is defined on the kmsProviders map\n * and the settings are an empty object.\n *\n * This is distinct from a nullish provider key.\n *\n * @internal - exposed for testing purposes only\n */\nexport function isEmptyCredentials(\n  providerName: ClientEncryptionDataKeyProvider,\n  kmsProviders: KMSProviders\n): boolean {\n  const provider = kmsProviders[providerName];\n  if (provider == null) {\n    return false;\n  }\n  return typeof provider === 'object' && Object.keys(provider).length === 0;\n}\n\n/**\n * Load cloud provider credentials for the user provided KMS providers.\n * Credentials will only attempt to get loaded if they do not exist\n * and no existing credentials will get overwritten.\n *\n * @internal\n */\nexport async function refreshKMSCredentials(kmsProviders: KMSProviders): Promise<KMSProviders> {\n  let finalKMSProviders = kmsProviders;\n\n  if (isEmptyCredentials('aws', kmsProviders)) {\n    finalKMSProviders = await loadAWSCredentials(finalKMSProviders);\n  }\n\n  if (isEmptyCredentials('gcp', kmsProviders)) {\n    finalKMSProviders = await loadGCPCredentials(finalKMSProviders);\n  }\n\n  if (isEmptyCredentials('azure', kmsProviders)) {\n    finalKMSProviders = await loadAzureCredentials(finalKMSProviders);\n  }\n  return finalKMSProviders;\n}\n"],"mappings":";;;;;;AAAA,MAAAA,KAAA,GAAAC,OAAA;AACA,MAAAC,OAAA,GAAAD,OAAA;AACA,MAAAE,KAAA,GAAAF,OAAA;AA4HA;;;;;;;;AAQA,SAAgBG,kBAAkBA,CAChCC,YAA6C,EAC7CC,YAA0B;EAE1B,MAAMC,QAAQ,GAAGD,YAAY,CAACD,YAAY,CAAC;EAC3C,IAAIE,QAAQ,IAAI,IAAI,EAAE;IACpB,OAAO,KAAK;;EAEd,OAAO,OAAOA,QAAQ,KAAK,QAAQ,IAAIC,MAAM,CAACC,IAAI,CAACF,QAAQ,CAAC,CAACG,MAAM,KAAK,CAAC;AAC3E;AATAC,OAAA,CAAAP,kBAAA,GAAAA,kBAAA;AAWA;;;;;;;AAOO,eAAeQ,qBAAqBA,CAACN,YAA0B;EACpE,IAAIO,iBAAiB,GAAGP,YAAY;EAEpC,IAAIF,kBAAkB,CAAC,KAAK,EAAEE,YAAY,CAAC,EAAE;IAC3CO,iBAAiB,GAAG,MAAM,IAAAb,KAAA,CAAAc,kBAAkB,EAACD,iBAAiB,CAAC;;EAGjE,IAAIT,kBAAkB,CAAC,KAAK,EAAEE,YAAY,CAAC,EAAE;IAC3CO,iBAAiB,GAAG,MAAM,IAAAV,KAAA,CAAAY,kBAAkB,EAACF,iBAAiB,CAAC;;EAGjE,IAAIT,kBAAkB,CAAC,OAAO,EAAEE,YAAY,CAAC,EAAE;IAC7CO,iBAAiB,GAAG,MAAM,IAAAX,OAAA,CAAAc,oBAAoB,EAACH,iBAAiB,CAAC;;EAEnE,OAAOA,iBAAiB;AAC1B;AAfAF,OAAA,CAAAC,qBAAA,GAAAA,qBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}