{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadAzureCredentials = exports.fetchAzureKMSToken = exports.prepareRequest = exports.tokenCache = exports.AzureCredentialCache = void 0;\nconst errors_1 = require(\"../errors\");\nconst utils_1 = require(\"./utils\");\nconst MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS = 6000;\n/**\n * @internal\n */\nclass AzureCredentialCache {\n  constructor() {\n    this.cachedToken = null;\n  }\n  async getToken() {\n    if (this.cachedToken == null || this.needsRefresh(this.cachedToken)) {\n      this.cachedToken = await this._getToken();\n    }\n    return {\n      accessToken: this.cachedToken.accessToken\n    };\n  }\n  needsRefresh(token) {\n    const timeUntilExpirationMS = token.expiresOnTimestamp - Date.now();\n    return timeUntilExpirationMS <= MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS;\n  }\n  /**\n   * exposed for testing\n   */\n  resetCache() {\n    this.cachedToken = null;\n  }\n  /**\n   * exposed for testing\n   */\n  _getToken() {\n    return fetchAzureKMSToken();\n  }\n}\nexports.AzureCredentialCache = AzureCredentialCache;\n/** @internal */\nexports.tokenCache = new AzureCredentialCache();\n/** @internal */\nasync function parseResponse(response) {\n  const {\n    status,\n    body: rawBody\n  } = response;\n  const body = (() => {\n    try {\n      return JSON.parse(rawBody);\n    } catch {\n      throw new errors_1.MongoCryptAzureKMSRequestError('Malformed JSON body in GET request.');\n    }\n  })();\n  if (status !== 200) {\n    throw new errors_1.MongoCryptAzureKMSRequestError('Unable to complete request.', body);\n  }\n  if (!body.access_token) {\n    throw new errors_1.MongoCryptAzureKMSRequestError('Malformed response body - missing field `access_token`.');\n  }\n  if (!body.expires_in) {\n    throw new errors_1.MongoCryptAzureKMSRequestError('Malformed response body - missing field `expires_in`.');\n  }\n  const expiresInMS = Number(body.expires_in) * 1000;\n  if (Number.isNaN(expiresInMS)) {\n    throw new errors_1.MongoCryptAzureKMSRequestError('Malformed response body - unable to parse int from `expires_in` field.');\n  }\n  return {\n    accessToken: body.access_token,\n    expiresOnTimestamp: Date.now() + expiresInMS\n  };\n}\n/**\n * @internal\n *\n * parses any options provided by prose tests to `fetchAzureKMSToken` and merges them with\n * the default values for headers and the request url.\n */\nfunction prepareRequest(options) {\n  const url = new URL(options.url?.toString() ?? 'http://169.254.169.254/metadata/identity/oauth2/token');\n  url.searchParams.append('api-version', '2018-02-01');\n  url.searchParams.append('resource', 'https://vault.azure.net');\n  const headers = {\n    ...options.headers,\n    'Content-Type': 'application/json',\n    Metadata: true\n  };\n  return {\n    headers,\n    url\n  };\n}\nexports.prepareRequest = prepareRequest;\n/**\n * @internal\n *\n * `AzureKMSRequestOptions` allows prose tests to modify the http request sent to the idms\n * servers.  This is required to simulate different server conditions.  No options are expected to\n * be set outside of tests.\n *\n * exposed for CSFLE\n * [prose test 18](https://github.com/mongodb/specifications/tree/master/source/client-side-encryption/tests#azure-imds-credentials)\n */\nasync function fetchAzureKMSToken(options = {}) {\n  const {\n    headers,\n    url\n  } = prepareRequest(options);\n  const response = await (0, utils_1.get)(url, {\n    headers\n  }).catch(error => {\n    if (error instanceof errors_1.MongoCryptKMSRequestNetworkTimeoutError) {\n      throw new errors_1.MongoCryptAzureKMSRequestError(`[Azure KMS] ${error.message}`);\n    }\n    throw error;\n  });\n  return parseResponse(response);\n}\nexports.fetchAzureKMSToken = fetchAzureKMSToken;\n/**\n * @internal\n *\n * @throws Will reject with a `MongoCryptError` if the http request fails or the http response is malformed.\n */\nasync function loadAzureCredentials(kmsProviders) {\n  const azure = await exports.tokenCache.getToken();\n  return {\n    ...kmsProviders,\n    azure\n  };\n}\nexports.loadAzureCredentials = loadAzureCredentials;","map":{"version":3,"names":["errors_1","require","utils_1","MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS","AzureCredentialCache","constructor","cachedToken","getToken","needsRefresh","_getToken","accessToken","token","timeUntilExpirationMS","expiresOnTimestamp","Date","now","resetCache","fetchAzureKMSToken","exports","tokenCache","parseResponse","response","status","body","rawBody","JSON","parse","MongoCryptAzureKMSRequestError","access_token","expires_in","expiresInMS","Number","isNaN","prepareRequest","options","url","URL","toString","searchParams","append","headers","Metadata","get","catch","error","MongoCryptKMSRequestNetworkTimeoutError","message","loadAzureCredentials","kmsProviders","azure"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\client-side-encryption\\providers\\azure.ts"],"sourcesContent":["import { type Document } from '../../bson';\nimport { MongoCryptAzureKMSRequestError, MongoCryptKMSRequestNetworkTimeoutError } from '../errors';\nimport { type KMSProviders } from './index';\nimport { get } from './utils';\n\nconst MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS = 6000;\n\n/**\n * The access token that libmongocrypt expects for Azure kms.\n */\ninterface AccessToken {\n  accessToken: string;\n}\n\n/**\n * The response from the azure idms endpoint, including the `expiresOnTimestamp`.\n * `expiresOnTimestamp` is needed for caching.\n */\ninterface AzureTokenCacheEntry extends AccessToken {\n  accessToken: string;\n  expiresOnTimestamp: number;\n}\n\n/**\n * @internal\n */\nexport class AzureCredentialCache {\n  cachedToken: AzureTokenCacheEntry | null = null;\n\n  async getToken(): Promise<AccessToken> {\n    if (this.cachedToken == null || this.needsRefresh(this.cachedToken)) {\n      this.cachedToken = await this._getToken();\n    }\n\n    return { accessToken: this.cachedToken.accessToken };\n  }\n\n  needsRefresh(token: AzureTokenCacheEntry): boolean {\n    const timeUntilExpirationMS = token.expiresOnTimestamp - Date.now();\n    return timeUntilExpirationMS <= MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS;\n  }\n\n  /**\n   * exposed for testing\n   */\n  resetCache() {\n    this.cachedToken = null;\n  }\n\n  /**\n   * exposed for testing\n   */\n  _getToken(): Promise<AzureTokenCacheEntry> {\n    return fetchAzureKMSToken();\n  }\n}\n\n/** @internal */\nexport const tokenCache = new AzureCredentialCache();\n\n/** @internal */\nasync function parseResponse(response: {\n  body: string;\n  status?: number;\n}): Promise<AzureTokenCacheEntry> {\n  const { status, body: rawBody } = response;\n\n  const body: { expires_in?: number; access_token?: string } = (() => {\n    try {\n      return JSON.parse(rawBody);\n    } catch {\n      throw new MongoCryptAzureKMSRequestError('Malformed JSON body in GET request.');\n    }\n  })();\n\n  if (status !== 200) {\n    throw new MongoCryptAzureKMSRequestError('Unable to complete request.', body);\n  }\n\n  if (!body.access_token) {\n    throw new MongoCryptAzureKMSRequestError(\n      'Malformed response body - missing field `access_token`.'\n    );\n  }\n\n  if (!body.expires_in) {\n    throw new MongoCryptAzureKMSRequestError(\n      'Malformed response body - missing field `expires_in`.'\n    );\n  }\n\n  const expiresInMS = Number(body.expires_in) * 1000;\n  if (Number.isNaN(expiresInMS)) {\n    throw new MongoCryptAzureKMSRequestError(\n      'Malformed response body - unable to parse int from `expires_in` field.'\n    );\n  }\n\n  return {\n    accessToken: body.access_token,\n    expiresOnTimestamp: Date.now() + expiresInMS\n  };\n}\n\n/**\n * @internal\n *\n * exposed for CSFLE\n * [prose test 18](https://github.com/mongodb/specifications/tree/master/source/client-side-encryption/tests#azure-imds-credentials)\n */\nexport interface AzureKMSRequestOptions {\n  headers?: Document;\n  url?: URL | string;\n}\n\n/**\n * @internal\n *\n * parses any options provided by prose tests to `fetchAzureKMSToken` and merges them with\n * the default values for headers and the request url.\n */\nexport function prepareRequest(options: AzureKMSRequestOptions): {\n  headers: Document;\n  url: URL;\n} {\n  const url = new URL(\n    options.url?.toString() ?? 'http://169.254.169.254/metadata/identity/oauth2/token'\n  );\n\n  url.searchParams.append('api-version', '2018-02-01');\n  url.searchParams.append('resource', 'https://vault.azure.net');\n\n  const headers = { ...options.headers, 'Content-Type': 'application/json', Metadata: true };\n  return { headers, url };\n}\n\n/**\n * @internal\n *\n * `AzureKMSRequestOptions` allows prose tests to modify the http request sent to the idms\n * servers.  This is required to simulate different server conditions.  No options are expected to\n * be set outside of tests.\n *\n * exposed for CSFLE\n * [prose test 18](https://github.com/mongodb/specifications/tree/master/source/client-side-encryption/tests#azure-imds-credentials)\n */\nexport async function fetchAzureKMSToken(\n  options: AzureKMSRequestOptions = {}\n): Promise<AzureTokenCacheEntry> {\n  const { headers, url } = prepareRequest(options);\n  const response = await get(url, { headers }).catch(error => {\n    if (error instanceof MongoCryptKMSRequestNetworkTimeoutError) {\n      throw new MongoCryptAzureKMSRequestError(`[Azure KMS] ${error.message}`);\n    }\n    throw error;\n  });\n  return parseResponse(response);\n}\n\n/**\n * @internal\n *\n * @throws Will reject with a `MongoCryptError` if the http request fails or the http response is malformed.\n */\nexport async function loadAzureCredentials(kmsProviders: KMSProviders): Promise<KMSProviders> {\n  const azure = await tokenCache.getToken();\n  return { ...kmsProviders, azure };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}