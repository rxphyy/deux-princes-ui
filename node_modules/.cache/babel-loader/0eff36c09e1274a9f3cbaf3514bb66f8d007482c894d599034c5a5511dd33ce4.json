{"ast":null,"code":"class Parser {\n  seperator = \",\";\n  timestampToSeconds(srtTimestamp) {\n    const [rest, millisecondsString] = srtTimestamp.split(\",\");\n    const milliseconds = parseInt(millisecondsString);\n    const [hours, minutes, seconds] = rest.split(\":\").map(x => parseInt(x));\n    const result = milliseconds * 0.001 + seconds + 60 * minutes + 3600 * hours;\n    // fix odd JS roundings, e.g. timestamp '00:01:20,460' result is 80.46000000000001\n    return Math.round(result * 1000) / 1000;\n  }\n  correctFormat(time) {\n    // Fix the format if the format is wrong\n    // 00:00:28.9670 Become 00:00:28,967\n    // 00:00:28.967  Become 00:00:28,967\n    // 00:00:28.96   Become 00:00:28,960\n    // 00:00:28.9    Become 00:00:28,900\n    // 00:00:28,96   Become 00:00:28,960\n    // 00:00:28,9    Become 00:00:28,900\n    // 00:00:28,0    Become 00:00:28,000\n    // 00:00:28,01   Become 00:00:28,010\n    // 0:00:10,500   Become 00:00:10,500\n    let str = time.replace(\".\", \",\");\n    var hour = null;\n    var minute = null;\n    var second = null;\n    var millisecond = null;\n    // Handle millisecond\n    var [front, ms] = str.split(\",\");\n    millisecond = this.fixed_str_digit(3, ms);\n    // Handle hour\n    var [a_hour, a_minute, a_second] = front.split(\":\");\n    hour = this.fixed_str_digit(2, a_hour, false);\n    minute = this.fixed_str_digit(2, a_minute, false);\n    second = this.fixed_str_digit(2, a_second, false);\n    return `${hour}:${minute}:${second},${millisecond}`;\n  }\n  /*\n  // make sure string is 'how_many_digit' long\n  // if str is shorter than how_many_digit, pad with 0\n  // if str is longer than how_many_digit, slice from the beginning\n  // Example:\n     Input: fixed_str_digit(3, '100')\n  Output: 100\n  Explain: unchanged, because \"100\" is 3 digit\n     Input: fixed_str_digit(3, '50')\n  Output: 500\n  Explain: pad end with 0\n     Input: fixed_str_digit(3, '50', false)\n  Output: 050\n  Explain: pad start with 0\n     Input: fixed_str_digit(3, '7771')\n  Output: 777\n  Explain: slice from beginning\n  */\n  fixed_str_digit(how_many_digit, str, padEnd = true) {\n    if (str.length == how_many_digit) {\n      return str;\n    }\n    if (str.length > how_many_digit) {\n      return str.slice(0, how_many_digit);\n    }\n    if (str.length < how_many_digit) {\n      if (padEnd) {\n        return str.padEnd(how_many_digit, \"0\");\n      } else {\n        return str.padStart(how_many_digit, \"0\");\n      }\n    }\n  }\n  tryComma(data) {\n    data = data.replace(/\\r/g, \"\");\n    var regex = /(\\d+)\\n(\\d{1,2}:\\d{2}:\\d{2},\\d{1,3}) --> (\\d{1,2}:\\d{2}:\\d{2},\\d{1,3})/g;\n    let data_array = data.split(regex);\n    data_array.shift(); // remove first '' in array\n    return data_array;\n  }\n  tryDot(data) {\n    data = data.replace(/\\r/g, \"\");\n    var regex = /(\\d+)\\n(\\d{1,2}:\\d{2}:\\d{2}\\.\\d{1,3}) --> (\\d{1,2}:\\d{2}:\\d{2}\\.\\d{1,3})/g;\n    let data_array = data.split(regex);\n    data_array.shift(); // remove first '' in array\n    this.seperator = \".\";\n    return data_array;\n  }\n  fromSrt(data) {\n    var originalData = data;\n    var data_array = this.tryComma(originalData);\n    if (data_array.length == 0) {\n      data_array = this.tryDot(originalData);\n    }\n    var items = [];\n    for (var i = 0; i < data_array.length; i += 4) {\n      const startTime = this.correctFormat(data_array[i + 1].trim());\n      const endTime = this.correctFormat(data_array[i + 2].trim());\n      var new_line = {\n        id: data_array[i].trim(),\n        startTime,\n        startSeconds: this.timestampToSeconds(startTime),\n        endTime,\n        endSeconds: this.timestampToSeconds(endTime),\n        text: data_array[i + 3].trim()\n      };\n      items.push(new_line);\n    }\n    return items;\n  }\n  toSrt(data) {\n    var res = \"\";\n    const end_of_line = \"\\r\\n\";\n    for (var i = 0; i < data.length; i++) {\n      var s = data[i];\n      res += s.id + end_of_line;\n      res += s.startTime + \" --> \" + s.endTime + end_of_line;\n      res += s.text.replace(\"\\n\", end_of_line) + end_of_line + end_of_line;\n    }\n    return res;\n  }\n}\nexport default Parser;","map":{"version":3,"names":["Parser","seperator","timestampToSeconds","srtTimestamp","rest","millisecondsString","split","milliseconds","parseInt","hours","minutes","seconds","map","x","result","Math","round","correctFormat","time","str","replace","hour","minute","second","millisecond","front","ms","fixed_str_digit","a_hour","a_minute","a_second","how_many_digit","padEnd","length","slice","padStart","tryComma","data","regex","data_array","shift","tryDot","fromSrt","originalData","items","i","startTime","trim","endTime","new_line","id","startSeconds","endSeconds","text","push","toSrt","res","end_of_line","s"],"sources":["C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/srt-parser-2/dist/index.js"],"sourcesContent":["class Parser {\n    seperator = \",\";\n    timestampToSeconds(srtTimestamp) {\n        const [rest, millisecondsString] = srtTimestamp.split(\",\");\n        const milliseconds = parseInt(millisecondsString);\n        const [hours, minutes, seconds] = rest.split(\":\").map((x) => parseInt(x));\n        const result = milliseconds * 0.001 + seconds + 60 * minutes + 3600 * hours;\n        // fix odd JS roundings, e.g. timestamp '00:01:20,460' result is 80.46000000000001\n        return Math.round(result * 1000) / 1000;\n    }\n    ;\n    correctFormat(time) {\n        // Fix the format if the format is wrong\n        // 00:00:28.9670 Become 00:00:28,967\n        // 00:00:28.967  Become 00:00:28,967\n        // 00:00:28.96   Become 00:00:28,960\n        // 00:00:28.9    Become 00:00:28,900\n        // 00:00:28,96   Become 00:00:28,960\n        // 00:00:28,9    Become 00:00:28,900\n        // 00:00:28,0    Become 00:00:28,000\n        // 00:00:28,01   Become 00:00:28,010\n        // 0:00:10,500   Become 00:00:10,500\n        let str = time.replace(\".\", \",\");\n        var hour = null;\n        var minute = null;\n        var second = null;\n        var millisecond = null;\n        // Handle millisecond\n        var [front, ms] = str.split(\",\");\n        millisecond = this.fixed_str_digit(3, ms);\n        // Handle hour\n        var [a_hour, a_minute, a_second] = front.split(\":\");\n        hour = this.fixed_str_digit(2, a_hour, false);\n        minute = this.fixed_str_digit(2, a_minute, false);\n        second = this.fixed_str_digit(2, a_second, false);\n        return `${hour}:${minute}:${second},${millisecond}`;\n    }\n    /*\n    // make sure string is 'how_many_digit' long\n    // if str is shorter than how_many_digit, pad with 0\n    // if str is longer than how_many_digit, slice from the beginning\n    // Example:\n  \n    Input: fixed_str_digit(3, '100')\n    Output: 100\n    Explain: unchanged, because \"100\" is 3 digit\n  \n    Input: fixed_str_digit(3, '50')\n    Output: 500\n    Explain: pad end with 0\n  \n    Input: fixed_str_digit(3, '50', false)\n    Output: 050\n    Explain: pad start with 0\n  \n    Input: fixed_str_digit(3, '7771')\n    Output: 777\n    Explain: slice from beginning\n    */\n    fixed_str_digit(how_many_digit, str, padEnd = true) {\n        if (str.length == how_many_digit) {\n            return str;\n        }\n        if (str.length > how_many_digit) {\n            return str.slice(0, how_many_digit);\n        }\n        if (str.length < how_many_digit) {\n            if (padEnd) {\n                return str.padEnd(how_many_digit, \"0\");\n            }\n            else {\n                return str.padStart(how_many_digit, \"0\");\n            }\n        }\n    }\n    tryComma(data) {\n        data = data.replace(/\\r/g, \"\");\n        var regex = /(\\d+)\\n(\\d{1,2}:\\d{2}:\\d{2},\\d{1,3}) --> (\\d{1,2}:\\d{2}:\\d{2},\\d{1,3})/g;\n        let data_array = data.split(regex);\n        data_array.shift(); // remove first '' in array\n        return data_array;\n    }\n    tryDot(data) {\n        data = data.replace(/\\r/g, \"\");\n        var regex = /(\\d+)\\n(\\d{1,2}:\\d{2}:\\d{2}\\.\\d{1,3}) --> (\\d{1,2}:\\d{2}:\\d{2}\\.\\d{1,3})/g;\n        let data_array = data.split(regex);\n        data_array.shift(); // remove first '' in array\n        this.seperator = \".\";\n        return data_array;\n    }\n    fromSrt(data) {\n        var originalData = data;\n        var data_array = this.tryComma(originalData);\n        if (data_array.length == 0) {\n            data_array = this.tryDot(originalData);\n        }\n        var items = [];\n        for (var i = 0; i < data_array.length; i += 4) {\n            const startTime = this.correctFormat(data_array[i + 1].trim());\n            const endTime = this.correctFormat(data_array[i + 2].trim());\n            var new_line = {\n                id: data_array[i].trim(),\n                startTime,\n                startSeconds: this.timestampToSeconds(startTime),\n                endTime,\n                endSeconds: this.timestampToSeconds(endTime),\n                text: data_array[i + 3].trim(),\n            };\n            items.push(new_line);\n        }\n        return items;\n    }\n    toSrt(data) {\n        var res = \"\";\n        const end_of_line = \"\\r\\n\";\n        for (var i = 0; i < data.length; i++) {\n            var s = data[i];\n            res += s.id + end_of_line;\n            res += s.startTime + \" --> \" + s.endTime + end_of_line;\n            res += s.text.replace(\"\\n\", end_of_line) + end_of_line + end_of_line;\n        }\n        return res;\n    }\n}\nexport default Parser;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}