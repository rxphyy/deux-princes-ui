{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenEntryCache = exports.TokenEntry = void 0;\nconst cache_1 = require(\"./cache\");\n/* Default expiration is now for when no expiration provided */\nconst DEFAULT_EXPIRATION_SECS = 0;\n/** @internal */\nclass TokenEntry extends cache_1.ExpiringCacheEntry {\n  /**\n   * Instantiate the entry.\n   */\n  constructor(tokenResult, serverInfo, expiration) {\n    super(expiration);\n    this.tokenResult = tokenResult;\n    this.serverInfo = serverInfo;\n  }\n}\nexports.TokenEntry = TokenEntry;\n/**\n * Cache of OIDC token entries.\n * @internal\n */\nclass TokenEntryCache extends cache_1.Cache {\n  /**\n   * Set an entry in the token cache.\n   */\n  addEntry(address, username, callbackHash, tokenResult, serverInfo) {\n    const entry = new TokenEntry(tokenResult, serverInfo, tokenResult.expiresInSeconds ?? DEFAULT_EXPIRATION_SECS);\n    this.entries.set(this.cacheKey(address, username, callbackHash), entry);\n    return entry;\n  }\n  /**\n   * Delete an entry from the cache.\n   */\n  deleteEntry(address, username, callbackHash) {\n    this.entries.delete(this.cacheKey(address, username, callbackHash));\n  }\n  /**\n   * Get an entry from the cache.\n   */\n  getEntry(address, username, callbackHash) {\n    return this.entries.get(this.cacheKey(address, username, callbackHash));\n  }\n  /**\n   * Delete all expired entries from the cache.\n   */\n  deleteExpiredEntries() {\n    for (const [key, entry] of this.entries) {\n      if (!entry.isValid()) {\n        this.entries.delete(key);\n      }\n    }\n  }\n  /**\n   * Create a cache key from the address and username.\n   */\n  cacheKey(address, username, callbackHash) {\n    return this.hashedCacheKey(address, username, callbackHash);\n  }\n}\nexports.TokenEntryCache = TokenEntryCache;","map":{"version":3,"names":["cache_1","require","DEFAULT_EXPIRATION_SECS","TokenEntry","ExpiringCacheEntry","constructor","tokenResult","serverInfo","expiration","exports","TokenEntryCache","Cache","addEntry","address","username","callbackHash","entry","expiresInSeconds","entries","set","cacheKey","deleteEntry","delete","getEntry","get","deleteExpiredEntries","key","isValid","hashedCacheKey"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\cmap\\auth\\mongodb_oidc\\token_entry_cache.ts"],"sourcesContent":["import type { IdPServerInfo, IdPServerResponse } from '../mongodb_oidc';\nimport { Cache, ExpiringCacheEntry } from './cache';\n\n/* Default expiration is now for when no expiration provided */\nconst DEFAULT_EXPIRATION_SECS = 0;\n\n/** @internal */\nexport class TokenEntry extends ExpiringCacheEntry {\n  tokenResult: IdPServerResponse;\n  serverInfo: IdPServerInfo;\n\n  /**\n   * Instantiate the entry.\n   */\n  constructor(tokenResult: IdPServerResponse, serverInfo: IdPServerInfo, expiration: number) {\n    super(expiration);\n    this.tokenResult = tokenResult;\n    this.serverInfo = serverInfo;\n  }\n}\n\n/**\n * Cache of OIDC token entries.\n * @internal\n */\nexport class TokenEntryCache extends Cache<TokenEntry> {\n  /**\n   * Set an entry in the token cache.\n   */\n  addEntry(\n    address: string,\n    username: string,\n    callbackHash: string,\n    tokenResult: IdPServerResponse,\n    serverInfo: IdPServerInfo\n  ): TokenEntry {\n    const entry = new TokenEntry(\n      tokenResult,\n      serverInfo,\n      tokenResult.expiresInSeconds ?? DEFAULT_EXPIRATION_SECS\n    );\n    this.entries.set(this.cacheKey(address, username, callbackHash), entry);\n    return entry;\n  }\n\n  /**\n   * Delete an entry from the cache.\n   */\n  deleteEntry(address: string, username: string, callbackHash: string): void {\n    this.entries.delete(this.cacheKey(address, username, callbackHash));\n  }\n\n  /**\n   * Get an entry from the cache.\n   */\n  getEntry(address: string, username: string, callbackHash: string): TokenEntry | undefined {\n    return this.entries.get(this.cacheKey(address, username, callbackHash));\n  }\n\n  /**\n   * Delete all expired entries from the cache.\n   */\n  deleteExpiredEntries(): void {\n    for (const [key, entry] of this.entries) {\n      if (!entry.isValid()) {\n        this.entries.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Create a cache key from the address and username.\n   */\n  cacheKey(address: string, username: string, callbackHash: string): string {\n    return this.hashedCacheKey(address, username, callbackHash);\n  }\n}\n"],"mappings":";;;;;;AACA,MAAAA,OAAA,GAAAC,OAAA;AAEA;AACA,MAAMC,uBAAuB,GAAG,CAAC;AAEjC;AACA,MAAaC,UAAW,SAAQH,OAAA,CAAAI,kBAAkB;EAIhD;;;EAGAC,YAAYC,WAA8B,EAAEC,UAAyB,EAAEC,UAAkB;IACvF,KAAK,CAACA,UAAU,CAAC;IACjB,IAAI,CAACF,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,UAAU,GAAGA,UAAU;EAC9B;;AAXFE,OAAA,CAAAN,UAAA,GAAAA,UAAA;AAcA;;;;AAIA,MAAaO,eAAgB,SAAQV,OAAA,CAAAW,KAAiB;EACpD;;;EAGAC,QAAQA,CACNC,OAAe,EACfC,QAAgB,EAChBC,YAAoB,EACpBT,WAA8B,EAC9BC,UAAyB;IAEzB,MAAMS,KAAK,GAAG,IAAIb,UAAU,CAC1BG,WAAW,EACXC,UAAU,EACVD,WAAW,CAACW,gBAAgB,IAAIf,uBAAuB,CACxD;IACD,IAAI,CAACgB,OAAO,CAACC,GAAG,CAAC,IAAI,CAACC,QAAQ,CAACP,OAAO,EAAEC,QAAQ,EAAEC,YAAY,CAAC,EAAEC,KAAK,CAAC;IACvE,OAAOA,KAAK;EACd;EAEA;;;EAGAK,WAAWA,CAACR,OAAe,EAAEC,QAAgB,EAAEC,YAAoB;IACjE,IAAI,CAACG,OAAO,CAACI,MAAM,CAAC,IAAI,CAACF,QAAQ,CAACP,OAAO,EAAEC,QAAQ,EAAEC,YAAY,CAAC,CAAC;EACrE;EAEA;;;EAGAQ,QAAQA,CAACV,OAAe,EAAEC,QAAgB,EAAEC,YAAoB;IAC9D,OAAO,IAAI,CAACG,OAAO,CAACM,GAAG,CAAC,IAAI,CAACJ,QAAQ,CAACP,OAAO,EAAEC,QAAQ,EAAEC,YAAY,CAAC,CAAC;EACzE;EAEA;;;EAGAU,oBAAoBA,CAAA;IAClB,KAAK,MAAM,CAACC,GAAG,EAAEV,KAAK,CAAC,IAAI,IAAI,CAACE,OAAO,EAAE;MACvC,IAAI,CAACF,KAAK,CAACW,OAAO,EAAE,EAAE;QACpB,IAAI,CAACT,OAAO,CAACI,MAAM,CAACI,GAAG,CAAC;;;EAG9B;EAEA;;;EAGAN,QAAQA,CAACP,OAAe,EAAEC,QAAgB,EAAEC,YAAoB;IAC9D,OAAO,IAAI,CAACa,cAAc,CAACf,OAAO,EAAEC,QAAQ,EAAEC,YAAY,CAAC;EAC7D;;AAlDFN,OAAA,CAAAC,eAAA,GAAAA,eAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}