{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _regeneratorRuntime = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AutoEncrypter = exports.AutoEncryptionLoggerLevel = void 0;\nvar bson_1 = require(\"../bson\");\nvar deps_1 = require(\"../deps\");\nvar error_1 = require(\"../error\");\nvar mongo_client_1 = require(\"../mongo_client\");\nvar utils_1 = require(\"../utils\");\nvar cryptoCallbacks = require(\"./crypto_callbacks\");\nvar errors_1 = require(\"./errors\");\nvar mongocryptd_manager_1 = require(\"./mongocryptd_manager\");\nvar providers_1 = require(\"./providers\");\nvar state_machine_1 = require(\"./state_machine\");\n/** @public */\nexports.AutoEncryptionLoggerLevel = Object.freeze({\n  FatalError: 0,\n  Error: 1,\n  Warning: 2,\n  Info: 3,\n  Trace: 4\n});\n// Typescript errors if we index objects with `Symbol.for(...)`, so\n// to avoid TS errors we pull them out into variables.  Then we can type\n// the objects (and class) that we expect to see them on and prevent TS\n// errors.\n/** @internal */\nvar kDecorateResult = Symbol.for('@@mdb.decorateDecryptionResult');\n/** @internal */\nvar kDecoratedKeys = Symbol.for('@@mdb.decryptedKeys');\n/**\n * @internal An internal class to be used by the driver for auto encryption\n * **NOTE**: Not meant to be instantiated directly, this is for internal use only.\n */\nvar AutoEncrypter = /*#__PURE__*/function () {\n  /**\n   * Create an AutoEncrypter\n   *\n   * **Note**: Do not instantiate this class directly. Rather, supply the relevant options to a MongoClient\n   *\n   * **Note**: Supplying `options.schemaMap` provides more security than relying on JSON Schemas obtained from the server.\n   * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.\n   * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.\n   * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.\n   *\n   * @example <caption>Create an AutoEncrypter that makes use of mongocryptd</caption>\n   * ```ts\n   * // Enabling autoEncryption via a MongoClient using mongocryptd\n   * const { MongoClient } = require('mongodb');\n   * const client = new MongoClient(URL, {\n   *   autoEncryption: {\n   *     kmsProviders: {\n   *       aws: {\n   *         accessKeyId: AWS_ACCESS_KEY,\n   *         secretAccessKey: AWS_SECRET_KEY\n   *       }\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * await client.connect();\n   * // From here on, the client will be encrypting / decrypting automatically\n   * @example <caption>Create an AutoEncrypter that makes use of libmongocrypt's CSFLE shared library</caption>\n   * ```ts\n   * // Enabling autoEncryption via a MongoClient using CSFLE shared library\n   * const { MongoClient } = require('mongodb');\n   * const client = new MongoClient(URL, {\n   *   autoEncryption: {\n   *     kmsProviders: {\n   *       aws: {}\n   *     },\n   *     extraOptions: {\n   *       cryptSharedLibPath: '/path/to/local/crypt/shared/lib',\n   *       cryptSharedLibRequired: true\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * await client.connect();\n   * // From here on, the client will be encrypting / decrypting automatically\n   */\n  function AutoEncrypter(client, options) {\n    var _options$options;\n    _classCallCheck(this, AutoEncrypter);\n    /**\n     * Used by devtools to enable decorating decryption results.\n     *\n     * When set and enabled, `decrypt` will automatically recursively\n     * traverse a decrypted document and if a field has been decrypted,\n     * it will mark it as decrypted.  Compass uses this to determine which\n     * fields were decrypted.\n     */\n    this[_a] = false;\n    this._client = client;\n    this._bypassEncryption = options.bypassAutoEncryption === true;\n    this._keyVaultNamespace = options.keyVaultNamespace || 'admin.datakeys';\n    this._keyVaultClient = options.keyVaultClient || client;\n    this._metaDataClient = options.metadataClient || client;\n    this._proxyOptions = options.proxyOptions || {};\n    this._tlsOptions = options.tlsOptions || {};\n    this._kmsProviders = options.kmsProviders || {};\n    var mongoCryptOptions = {\n      cryptoCallbacks: cryptoCallbacks\n    };\n    if (options.schemaMap) {\n      mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap) ? options.schemaMap : (0, bson_1.serialize)(options.schemaMap);\n    }\n    if (options.encryptedFieldsMap) {\n      mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options.encryptedFieldsMap) ? options.encryptedFieldsMap : (0, bson_1.serialize)(options.encryptedFieldsMap);\n    }\n    mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders;\n    if ((_options$options = options.options) !== null && _options$options !== void 0 && _options$options.logger) {\n      mongoCryptOptions.logger = options.options.logger;\n    }\n    if (options.extraOptions && options.extraOptions.cryptSharedLibPath) {\n      mongoCryptOptions.cryptSharedLibPath = options.extraOptions.cryptSharedLibPath;\n    }\n    if (options.bypassQueryAnalysis) {\n      mongoCryptOptions.bypassQueryAnalysis = options.bypassQueryAnalysis;\n    }\n    this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options.bypassQueryAnalysis;\n    if (options.extraOptions && options.extraOptions.cryptSharedLibSearchPaths) {\n      // Only for driver testing\n      mongoCryptOptions.cryptSharedLibSearchPaths = options.extraOptions.cryptSharedLibSearchPaths;\n    } else if (!this._bypassMongocryptdAndCryptShared) {\n      mongoCryptOptions.cryptSharedLibSearchPaths = ['$SYSTEM'];\n    }\n    var MongoCrypt = AutoEncrypter.getMongoCrypt();\n    this._mongocrypt = new MongoCrypt(mongoCryptOptions);\n    this._contextCounter = 0;\n    if (options.extraOptions && options.extraOptions.cryptSharedLibRequired && !this.cryptSharedLibVersionInfo) {\n      throw new errors_1.MongoCryptInvalidArgumentError('`cryptSharedLibRequired` set but no crypt_shared library loaded');\n    }\n    // Only instantiate mongocryptd manager/client once we know for sure\n    // that we are not using the CSFLE shared library.\n    if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {\n      this._mongocryptdManager = new mongocryptd_manager_1.MongocryptdManager(options.extraOptions);\n      var clientOptions = {\n        serverSelectionTimeoutMS: 10000\n      };\n      if (options.extraOptions == null || typeof options.extraOptions.mongocryptdURI !== 'string') {\n        clientOptions.family = 4;\n      }\n      this._mongocryptdClient = new mongo_client_1.MongoClient(this._mongocryptdManager.uri, clientOptions);\n    }\n  }\n  /**\n   * Initializes the auto encrypter by spawning a mongocryptd and connecting to it.\n   *\n   * This function is a no-op when bypassSpawn is set or the crypt shared library is used.\n   */\n  _createClass(AutoEncrypter, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var client, message;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 2:\n              if (this._mongocryptdManager) {\n                _context.next = 4;\n                break;\n              }\n              throw new error_1.MongoRuntimeError('Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.');\n            case 4:\n              if (this._mongocryptdClient) {\n                _context.next = 6;\n                break;\n              }\n              throw new error_1.MongoRuntimeError('Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.');\n            case 6:\n              if (this._mongocryptdManager.bypassSpawn) {\n                _context.next = 9;\n                break;\n              }\n              _context.next = 9;\n              return this._mongocryptdManager.spawn();\n            case 9:\n              _context.prev = 9;\n              _context.next = 12;\n              return this._mongocryptdClient.connect();\n            case 12:\n              client = _context.sent;\n              return _context.abrupt(\"return\", client);\n            case 16:\n              _context.prev = 16;\n              _context.t0 = _context[\"catch\"](9);\n              message = _context.t0.message;\n              if (!(message && (message.match(/timed out after/) || message.match(/ENOTFOUND/)))) {\n                _context.next = 21;\n                break;\n              }\n              throw new error_1.MongoRuntimeError('Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn', {\n                cause: _context.t0\n              });\n            case 21:\n              throw _context.t0;\n            case 22:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[9, 16]]);\n      }));\n      function init() {\n        return _init.apply(this, arguments);\n      }\n      return init;\n    }()\n    /**\n     * Cleans up the `_mongocryptdClient`, if present.\n     */\n  }, {\n    key: \"teardown\",\n    value: function () {\n      var _teardown = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(force) {\n        var _this$_mongocryptdCli;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return (_this$_mongocryptdCli = this._mongocryptdClient) === null || _this$_mongocryptdCli === void 0 ? void 0 : _this$_mongocryptdCli.close(force);\n            case 2:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function teardown(_x) {\n        return _teardown.apply(this, arguments);\n      }\n      return teardown;\n    }()\n    /**\n     * Encrypt a command for a given namespace.\n     */\n  }, {\n    key: \"encrypt\",\n    value: function () {\n      var _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(ns, cmd) {\n        var options,\n          commandBuffer,\n          context,\n          stateMachine,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};\n              if (!this._bypassEncryption) {\n                _context3.next = 3;\n                break;\n              }\n              return _context3.abrupt(\"return\", cmd);\n            case 3:\n              commandBuffer = Buffer.isBuffer(cmd) ? cmd : (0, bson_1.serialize)(cmd, options);\n              context = this._mongocrypt.makeEncryptionContext(utils_1.MongoDBCollectionNamespace.fromString(ns).db, commandBuffer);\n              context.id = this._contextCounter++;\n              context.ns = ns;\n              context.document = cmd;\n              stateMachine = new state_machine_1.StateMachine({\n                promoteValues: false,\n                promoteLongs: false,\n                proxyOptions: this._proxyOptions,\n                tlsOptions: this._tlsOptions\n              });\n              return _context3.abrupt(\"return\", stateMachine.execute(this, context));\n            case 10:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function encrypt(_x2, _x3) {\n        return _encrypt.apply(this, arguments);\n      }\n      return encrypt;\n    }()\n    /**\n     * Decrypt a command response\n     */\n  }, {\n    key: \"decrypt\",\n    value: function () {\n      var _decrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(response) {\n        var options,\n          buffer,\n          context,\n          stateMachine,\n          decorateResult,\n          result,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n              buffer = Buffer.isBuffer(response) ? response : (0, bson_1.serialize)(response, options);\n              context = this._mongocrypt.makeDecryptionContext(buffer);\n              context.id = this._contextCounter++;\n              stateMachine = new state_machine_1.StateMachine(_objectSpread(_objectSpread({}, options), {}, {\n                proxyOptions: this._proxyOptions,\n                tlsOptions: this._tlsOptions\n              }));\n              decorateResult = this[kDecorateResult];\n              _context4.next = 8;\n              return stateMachine.execute(this, context);\n            case 8:\n              result = _context4.sent;\n              if (decorateResult) {\n                decorateDecryptionResult(result, response);\n              }\n              return _context4.abrupt(\"return\", result);\n            case 11:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function decrypt(_x4) {\n        return _decrypt.apply(this, arguments);\n      }\n      return decrypt;\n    }()\n    /**\n     * Ask the user for KMS credentials.\n     *\n     * This returns anything that looks like the kmsProviders original input\n     * option. It can be empty, and any provider specified here will override\n     * the original ones.\n     */\n  }, {\n    key: \"askForKMSCredentials\",\n    value: function () {\n      var _askForKMSCredentials = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt(\"return\", (0, providers_1.refreshKMSCredentials)(this._kmsProviders));\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function askForKMSCredentials() {\n        return _askForKMSCredentials.apply(this, arguments);\n      }\n      return askForKMSCredentials;\n    }()\n    /**\n     * Return the current libmongocrypt's CSFLE shared library version\n     * as `{ version: bigint, versionStr: string }`, or `null` if no CSFLE\n     * shared library was loaded.\n     */\n  }, {\n    key: \"cryptSharedLibVersionInfo\",\n    get: function get() {\n      return this._mongocrypt.cryptSharedLibVersionInfo;\n    }\n  }], [{\n    key: \"getMongoCrypt\",\n    value: /** @internal */\n    function getMongoCrypt() {\n      var encryption = (0, deps_1.getMongoDBClientEncryption)();\n      if ('kModuleError' in encryption) {\n        throw encryption.kModuleError;\n      }\n      return encryption.MongoCrypt;\n    }\n  }, {\n    key: \"libmongocryptVersion\",\n    get: function get() {\n      return AutoEncrypter.getMongoCrypt().libmongocryptVersion;\n    }\n  }]);\n  return AutoEncrypter;\n}();\nexports.AutoEncrypter = AutoEncrypter;\n_a = kDecorateResult;\n/**\n * Recurse through the (identically-shaped) `decrypted` and `original`\n * objects and attach a `decryptedKeys` property on each sub-object that\n * contained encrypted fields. Because we only call this on BSON responses,\n * we do not need to worry about circular references.\n *\n * @internal\n */\nfunction decorateDecryptionResult(decrypted, original) {\n  var isTopLevelDecorateCall = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (isTopLevelDecorateCall) {\n    // The original value could have been either a JS object or a BSON buffer\n    if (Buffer.isBuffer(original)) {\n      original = (0, bson_1.deserialize)(original);\n    }\n    if (Buffer.isBuffer(decrypted)) {\n      throw new error_1.MongoRuntimeError('Expected result of decryption to be deserialized BSON object');\n    }\n  }\n  if (!decrypted || typeof decrypted !== 'object') return;\n  for (var _i = 0, _Object$keys = Object.keys(decrypted); _i < _Object$keys.length; _i++) {\n    var k = _Object$keys[_i];\n    var originalValue = original[k];\n    // An object was decrypted by libmongocrypt if and only if it was\n    // a BSON Binary object with subtype 6.\n    if (originalValue && originalValue._bsontype === 'Binary' && originalValue.sub_type === 6) {\n      if (!decrypted[kDecoratedKeys]) {\n        Object.defineProperty(decrypted, kDecoratedKeys, {\n          value: [],\n          configurable: true,\n          enumerable: false,\n          writable: false\n        });\n      }\n      // this is defined in the preceding if-statement\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      decrypted[kDecoratedKeys].push(k);\n      // Do not recurse into this decrypted value. It could be a sub-document/array,\n      // in which case there is no original value associated with its subfields.\n      continue;\n    }\n    decorateDecryptionResult(decrypted[k], originalValue, false);\n  }\n}","map":{"version":3,"names":["bson_1","require","deps_1","error_1","mongo_client_1","utils_1","cryptoCallbacks","errors_1","mongocryptd_manager_1","providers_1","state_machine_1","exports","AutoEncryptionLoggerLevel","Object","freeze","FatalError","Error","Warning","Info","Trace","kDecorateResult","Symbol","for","kDecoratedKeys","AutoEncrypter","client","options","_options$options","_classCallCheck","_a","_client","_bypassEncryption","bypassAutoEncryption","_keyVaultNamespace","keyVaultNamespace","_keyVaultClient","keyVaultClient","_metaDataClient","metadataClient","_proxyOptions","proxyOptions","_tlsOptions","tlsOptions","_kmsProviders","kmsProviders","mongoCryptOptions","schemaMap","Buffer","isBuffer","serialize","encryptedFieldsMap","logger","extraOptions","cryptSharedLibPath","bypassQueryAnalysis","_bypassMongocryptdAndCryptShared","cryptSharedLibSearchPaths","MongoCrypt","getMongoCrypt","_mongocrypt","_contextCounter","cryptSharedLibRequired","cryptSharedLibVersionInfo","MongoCryptInvalidArgumentError","_mongocryptdManager","MongocryptdManager","clientOptions","serverSelectionTimeoutMS","mongocryptdURI","family","_mongocryptdClient","MongoClient","uri","_createClass","key","value","_init","_asyncToGenerator","_regeneratorRuntime","mark","_callee","message","wrap","_callee$","_context","prev","next","abrupt","MongoRuntimeError","bypassSpawn","spawn","connect","sent","t0","match","cause","stop","init","apply","arguments","_teardown","_callee2","force","_this$_mongocryptdCli","_callee2$","_context2","close","teardown","_x","_encrypt","_callee3","ns","cmd","commandBuffer","context","stateMachine","_args3","_callee3$","_context3","length","undefined","makeEncryptionContext","MongoDBCollectionNamespace","fromString","db","id","document","StateMachine","promoteValues","promoteLongs","execute","encrypt","_x2","_x3","_decrypt","_callee4","response","buffer","decorateResult","result","_args4","_callee4$","_context4","makeDecryptionContext","_objectSpread","decorateDecryptionResult","decrypt","_x4","_askForKMSCredentials","_callee5","_callee5$","_context5","refreshKMSCredentials","askForKMSCredentials","get","encryption","getMongoDBClientEncryption","kModuleError","libmongocryptVersion","decrypted","original","isTopLevelDecorateCall","deserialize","_i","_Object$keys","keys","k","originalValue","_bsontype","sub_type","defineProperty","configurable","enumerable","writable","push"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\client-side-encryption\\auto_encrypter.ts"],"sourcesContent":["import {\n  type MongoCrypt,\n  type MongoCryptConstructor,\n  type MongoCryptOptions\n} from 'mongodb-client-encryption';\n\nimport { deserialize, type Document, serialize } from '../bson';\nimport { type CommandOptions, type ProxyOptions } from '../cmap/connection';\nimport { getMongoDBClientEncryption } from '../deps';\nimport { MongoRuntimeError } from '../error';\nimport { MongoClient, type MongoClientOptions } from '../mongo_client';\nimport { MongoDBCollectionNamespace } from '../utils';\nimport * as cryptoCallbacks from './crypto_callbacks';\nimport { MongoCryptInvalidArgumentError } from './errors';\nimport { MongocryptdManager } from './mongocryptd_manager';\nimport { type KMSProviders, refreshKMSCredentials } from './providers';\nimport { type CSFLEKMSTlsOptions, StateMachine } from './state_machine';\n\n/** @public */\nexport interface AutoEncryptionOptions {\n  /** @internal client for metadata lookups */\n  metadataClient?: MongoClient;\n  /** A `MongoClient` used to fetch keys from a key vault */\n  keyVaultClient?: MongoClient;\n  /** The namespace where keys are stored in the key vault */\n  keyVaultNamespace?: string;\n  /** Configuration options that are used by specific KMS providers during key generation, encryption, and decryption. */\n  kmsProviders?: {\n    /** Configuration options for using 'aws' as your KMS provider */\n    aws?:\n      | {\n          /** The access key used for the AWS KMS provider */\n          accessKeyId: string;\n          /** The secret access key used for the AWS KMS provider */\n          secretAccessKey: string;\n          /**\n           * An optional AWS session token that will be used as the\n           * X-Amz-Security-Token header for AWS requests.\n           */\n          sessionToken?: string;\n        }\n      | Record<string, never>;\n    /** Configuration options for using 'local' as your KMS provider */\n    local?: {\n      /**\n       * The master key used to encrypt/decrypt data keys.\n       * A 96-byte long Buffer or base64 encoded string.\n       */\n      key: Buffer | string;\n    };\n    /** Configuration options for using 'azure' as your KMS provider */\n    azure?:\n      | {\n          /** The tenant ID identifies the organization for the account */\n          tenantId: string;\n          /** The client ID to authenticate a registered application */\n          clientId: string;\n          /** The client secret to authenticate a registered application */\n          clientSecret: string;\n          /**\n           * If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\".\n           * This is optional, and only needed if customer is using a non-commercial Azure instance\n           * (e.g. a government or China account, which use different URLs).\n           * Defaults to \"login.microsoftonline.com\"\n           */\n          identityPlatformEndpoint?: string | undefined;\n        }\n      | {\n          /**\n           * If present, an access token to authenticate with Azure.\n           */\n          accessToken: string;\n        }\n      | Record<string, never>;\n    /** Configuration options for using 'gcp' as your KMS provider */\n    gcp?:\n      | {\n          /** The service account email to authenticate */\n          email: string;\n          /** A PKCS#8 encrypted key. This can either be a base64 string or a binary representation */\n          privateKey: string | Buffer;\n          /**\n           * If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\".\n           * Defaults to \"oauth2.googleapis.com\"\n           */\n          endpoint?: string | undefined;\n        }\n      | {\n          /**\n           * If present, an access token to authenticate with GCP.\n           */\n          accessToken: string;\n        }\n      | Record<string, never>;\n    /**\n     * Configuration options for using 'kmip' as your KMS provider\n     */\n    kmip?: {\n      /**\n       * The output endpoint string.\n       * The endpoint consists of a hostname and port separated by a colon.\n       * E.g. \"example.com:123\". A port is always present.\n       */\n      endpoint?: string;\n    };\n  };\n  /**\n   * A map of namespaces to a local JSON schema for encryption\n   *\n   * **NOTE**: Supplying options.schemaMap provides more security than relying on JSON Schemas obtained from the server.\n   * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending decrypted data that should be encrypted.\n   * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.\n   * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.\n   */\n  schemaMap?: Document;\n  /** Supply a schema for the encrypted fields in the document  */\n  encryptedFieldsMap?: Document;\n  /** Allows the user to bypass auto encryption, maintaining implicit decryption */\n  bypassAutoEncryption?: boolean;\n  /** Allows users to bypass query analysis */\n  bypassQueryAnalysis?: boolean;\n  options?: {\n    /** An optional hook to catch logging messages from the underlying encryption engine */\n    logger?: (level: AutoEncryptionLoggerLevel, message: string) => void;\n  };\n  extraOptions?: {\n    /**\n     * A local process the driver communicates with to determine how to encrypt values in a command.\n     * Defaults to \"mongodb://%2Fvar%2Fmongocryptd.sock\" if domain sockets are available or \"mongodb://localhost:27020\" otherwise\n     */\n    mongocryptdURI?: string;\n    /** If true, autoEncryption will not attempt to spawn a mongocryptd before connecting  */\n    mongocryptdBypassSpawn?: boolean;\n    /** The path to the mongocryptd executable on the system */\n    mongocryptdSpawnPath?: string;\n    /** Command line arguments to use when auto-spawning a mongocryptd */\n    mongocryptdSpawnArgs?: string[];\n    /**\n     * Full path to a MongoDB Crypt shared library to be used (instead of mongocryptd).\n     *\n     * This needs to be the path to the file itself, not a directory.\n     * It can be an absolute or relative path. If the path is relative and\n     * its first component is `$ORIGIN`, it will be replaced by the directory\n     * containing the mongodb-client-encryption native addon file. Otherwise,\n     * the path will be interpreted relative to the current working directory.\n     *\n     * Currently, loading different MongoDB Crypt shared library files from different\n     * MongoClients in the same process is not supported.\n     *\n     * If this option is provided and no MongoDB Crypt shared library could be loaded\n     * from the specified location, creating the MongoClient will fail.\n     *\n     * If this option is not provided and `cryptSharedLibRequired` is not specified,\n     * the AutoEncrypter will attempt to spawn and/or use mongocryptd according\n     * to the mongocryptd-specific `extraOptions` options.\n     *\n     * Specifying a path prevents mongocryptd from being used as a fallback.\n     *\n     * Requires the MongoDB Crypt shared library, available in MongoDB 6.0 or higher.\n     */\n    cryptSharedLibPath?: string;\n    /**\n     * If specified, never use mongocryptd and instead fail when the MongoDB Crypt\n     * shared library could not be loaded.\n     *\n     * This is always true when `cryptSharedLibPath` is specified.\n     *\n     * Requires the MongoDB Crypt shared library, available in MongoDB 6.0 or higher.\n     */\n    cryptSharedLibRequired?: boolean;\n    /**\n     * Search paths for a MongoDB Crypt shared library to be used (instead of mongocryptd)\n     * Only for driver testing!\n     * @internal\n     */\n    cryptSharedLibSearchPaths?: string[];\n  };\n  proxyOptions?: ProxyOptions;\n  /** The TLS options to use connecting to the KMS provider */\n  tlsOptions?: CSFLEKMSTlsOptions;\n}\n\n/**\n * @public\n *\n * Extra options related to the mongocryptd process\n * \\* _Available in MongoDB 6.0 or higher._\n */\nexport type AutoEncryptionExtraOptions = NonNullable<AutoEncryptionOptions['extraOptions']>;\n\n/** @public */\nexport const AutoEncryptionLoggerLevel = Object.freeze({\n  FatalError: 0,\n  Error: 1,\n  Warning: 2,\n  Info: 3,\n  Trace: 4\n} as const);\n\n/**\n * @public\n * The level of severity of the log message\n *\n * | Value | Level |\n * |-------|-------|\n * | 0 | Fatal Error |\n * | 1 | Error |\n * | 2 | Warning |\n * | 3 | Info |\n * | 4 | Trace |\n */\nexport type AutoEncryptionLoggerLevel =\n  (typeof AutoEncryptionLoggerLevel)[keyof typeof AutoEncryptionLoggerLevel];\n\n// Typescript errors if we index objects with `Symbol.for(...)`, so\n// to avoid TS errors we pull them out into variables.  Then we can type\n// the objects (and class) that we expect to see them on and prevent TS\n// errors.\n/** @internal */\nconst kDecorateResult = Symbol.for('@@mdb.decorateDecryptionResult');\n/** @internal */\nconst kDecoratedKeys = Symbol.for('@@mdb.decryptedKeys');\n\n/**\n * @internal An internal class to be used by the driver for auto encryption\n * **NOTE**: Not meant to be instantiated directly, this is for internal use only.\n */\nexport class AutoEncrypter {\n  _client: MongoClient;\n  _bypassEncryption: boolean;\n  _keyVaultNamespace: string;\n  _keyVaultClient: MongoClient;\n  _metaDataClient: MongoClient;\n  _proxyOptions: ProxyOptions;\n  _tlsOptions: CSFLEKMSTlsOptions;\n  _kmsProviders: KMSProviders;\n  _bypassMongocryptdAndCryptShared: boolean;\n  _contextCounter: number;\n\n  _mongocryptdManager?: MongocryptdManager;\n  _mongocryptdClient?: MongoClient;\n\n  /** @internal */\n  _mongocrypt: MongoCrypt;\n\n  /**\n   * Used by devtools to enable decorating decryption results.\n   *\n   * When set and enabled, `decrypt` will automatically recursively\n   * traverse a decrypted document and if a field has been decrypted,\n   * it will mark it as decrypted.  Compass uses this to determine which\n   * fields were decrypted.\n   */\n  [kDecorateResult] = false;\n\n  /** @internal */\n  static getMongoCrypt(): MongoCryptConstructor {\n    const encryption = getMongoDBClientEncryption();\n    if ('kModuleError' in encryption) {\n      throw encryption.kModuleError;\n    }\n    return encryption.MongoCrypt;\n  }\n\n  /**\n   * Create an AutoEncrypter\n   *\n   * **Note**: Do not instantiate this class directly. Rather, supply the relevant options to a MongoClient\n   *\n   * **Note**: Supplying `options.schemaMap` provides more security than relying on JSON Schemas obtained from the server.\n   * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.\n   * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.\n   * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.\n   *\n   * @example <caption>Create an AutoEncrypter that makes use of mongocryptd</caption>\n   * ```ts\n   * // Enabling autoEncryption via a MongoClient using mongocryptd\n   * const { MongoClient } = require('mongodb');\n   * const client = new MongoClient(URL, {\n   *   autoEncryption: {\n   *     kmsProviders: {\n   *       aws: {\n   *         accessKeyId: AWS_ACCESS_KEY,\n   *         secretAccessKey: AWS_SECRET_KEY\n   *       }\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * await client.connect();\n   * // From here on, the client will be encrypting / decrypting automatically\n   * @example <caption>Create an AutoEncrypter that makes use of libmongocrypt's CSFLE shared library</caption>\n   * ```ts\n   * // Enabling autoEncryption via a MongoClient using CSFLE shared library\n   * const { MongoClient } = require('mongodb');\n   * const client = new MongoClient(URL, {\n   *   autoEncryption: {\n   *     kmsProviders: {\n   *       aws: {}\n   *     },\n   *     extraOptions: {\n   *       cryptSharedLibPath: '/path/to/local/crypt/shared/lib',\n   *       cryptSharedLibRequired: true\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * await client.connect();\n   * // From here on, the client will be encrypting / decrypting automatically\n   */\n  constructor(client: MongoClient, options: AutoEncryptionOptions) {\n    this._client = client;\n    this._bypassEncryption = options.bypassAutoEncryption === true;\n\n    this._keyVaultNamespace = options.keyVaultNamespace || 'admin.datakeys';\n    this._keyVaultClient = options.keyVaultClient || client;\n    this._metaDataClient = options.metadataClient || client;\n    this._proxyOptions = options.proxyOptions || {};\n    this._tlsOptions = options.tlsOptions || {};\n    this._kmsProviders = options.kmsProviders || {};\n\n    const mongoCryptOptions: MongoCryptOptions = {\n      cryptoCallbacks\n    };\n    if (options.schemaMap) {\n      mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap)\n        ? options.schemaMap\n        : (serialize(options.schemaMap) as Buffer);\n    }\n\n    if (options.encryptedFieldsMap) {\n      mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options.encryptedFieldsMap)\n        ? options.encryptedFieldsMap\n        : (serialize(options.encryptedFieldsMap) as Buffer);\n    }\n\n    mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders)\n      ? (serialize(this._kmsProviders) as Buffer)\n      : this._kmsProviders;\n\n    if (options.options?.logger) {\n      mongoCryptOptions.logger = options.options.logger;\n    }\n\n    if (options.extraOptions && options.extraOptions.cryptSharedLibPath) {\n      mongoCryptOptions.cryptSharedLibPath = options.extraOptions.cryptSharedLibPath;\n    }\n\n    if (options.bypassQueryAnalysis) {\n      mongoCryptOptions.bypassQueryAnalysis = options.bypassQueryAnalysis;\n    }\n\n    this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options.bypassQueryAnalysis;\n\n    if (options.extraOptions && options.extraOptions.cryptSharedLibSearchPaths) {\n      // Only for driver testing\n      mongoCryptOptions.cryptSharedLibSearchPaths = options.extraOptions.cryptSharedLibSearchPaths;\n    } else if (!this._bypassMongocryptdAndCryptShared) {\n      mongoCryptOptions.cryptSharedLibSearchPaths = ['$SYSTEM'];\n    }\n\n    const MongoCrypt = AutoEncrypter.getMongoCrypt();\n    this._mongocrypt = new MongoCrypt(mongoCryptOptions);\n    this._contextCounter = 0;\n\n    if (\n      options.extraOptions &&\n      options.extraOptions.cryptSharedLibRequired &&\n      !this.cryptSharedLibVersionInfo\n    ) {\n      throw new MongoCryptInvalidArgumentError(\n        '`cryptSharedLibRequired` set but no crypt_shared library loaded'\n      );\n    }\n\n    // Only instantiate mongocryptd manager/client once we know for sure\n    // that we are not using the CSFLE shared library.\n    if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {\n      this._mongocryptdManager = new MongocryptdManager(options.extraOptions);\n      const clientOptions: MongoClientOptions = {\n        serverSelectionTimeoutMS: 10000\n      };\n\n      if (options.extraOptions == null || typeof options.extraOptions.mongocryptdURI !== 'string') {\n        clientOptions.family = 4;\n      }\n\n      this._mongocryptdClient = new MongoClient(this._mongocryptdManager.uri, clientOptions);\n    }\n  }\n\n  /**\n   * Initializes the auto encrypter by spawning a mongocryptd and connecting to it.\n   *\n   * This function is a no-op when bypassSpawn is set or the crypt shared library is used.\n   */\n  async init(): Promise<MongoClient | void> {\n    if (this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo) {\n      return;\n    }\n    if (!this._mongocryptdManager) {\n      throw new MongoRuntimeError(\n        'Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.'\n      );\n    }\n    if (!this._mongocryptdClient) {\n      throw new MongoRuntimeError(\n        'Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.'\n      );\n    }\n\n    if (!this._mongocryptdManager.bypassSpawn) {\n      await this._mongocryptdManager.spawn();\n    }\n\n    try {\n      const client = await this._mongocryptdClient.connect();\n      return client;\n    } catch (error) {\n      const { message } = error;\n      if (message && (message.match(/timed out after/) || message.match(/ENOTFOUND/))) {\n        throw new MongoRuntimeError(\n          'Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn',\n          { cause: error }\n        );\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Cleans up the `_mongocryptdClient`, if present.\n   */\n  async teardown(force: boolean): Promise<void> {\n    await this._mongocryptdClient?.close(force);\n  }\n\n  /**\n   * Encrypt a command for a given namespace.\n   */\n  async encrypt(\n    ns: string,\n    cmd: Document,\n    options: CommandOptions = {}\n  ): Promise<Document | Uint8Array> {\n    if (this._bypassEncryption) {\n      // If `bypassAutoEncryption` has been specified, don't encrypt\n      return cmd;\n    }\n\n    const commandBuffer = Buffer.isBuffer(cmd) ? cmd : serialize(cmd, options);\n\n    const context = this._mongocrypt.makeEncryptionContext(\n      MongoDBCollectionNamespace.fromString(ns).db,\n      commandBuffer\n    );\n\n    context.id = this._contextCounter++;\n    context.ns = ns;\n    context.document = cmd;\n\n    const stateMachine = new StateMachine({\n      promoteValues: false,\n      promoteLongs: false,\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n    return stateMachine.execute<Document>(this, context);\n  }\n\n  /**\n   * Decrypt a command response\n   */\n  async decrypt(response: Uint8Array | Document, options: CommandOptions = {}): Promise<Document> {\n    const buffer = Buffer.isBuffer(response) ? response : serialize(response, options);\n\n    const context = this._mongocrypt.makeDecryptionContext(buffer);\n\n    context.id = this._contextCounter++;\n\n    const stateMachine = new StateMachine({\n      ...options,\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n\n    const decorateResult = this[kDecorateResult];\n    const result = await stateMachine.execute<Document>(this, context);\n    if (decorateResult) {\n      decorateDecryptionResult(result, response);\n    }\n    return result;\n  }\n\n  /**\n   * Ask the user for KMS credentials.\n   *\n   * This returns anything that looks like the kmsProviders original input\n   * option. It can be empty, and any provider specified here will override\n   * the original ones.\n   */\n  async askForKMSCredentials(): Promise<KMSProviders> {\n    return refreshKMSCredentials(this._kmsProviders);\n  }\n\n  /**\n   * Return the current libmongocrypt's CSFLE shared library version\n   * as `{ version: bigint, versionStr: string }`, or `null` if no CSFLE\n   * shared library was loaded.\n   */\n  get cryptSharedLibVersionInfo(): { version: bigint; versionStr: string } | null {\n    return this._mongocrypt.cryptSharedLibVersionInfo;\n  }\n\n  static get libmongocryptVersion(): string {\n    return AutoEncrypter.getMongoCrypt().libmongocryptVersion;\n  }\n}\n\n/**\n * Recurse through the (identically-shaped) `decrypted` and `original`\n * objects and attach a `decryptedKeys` property on each sub-object that\n * contained encrypted fields. Because we only call this on BSON responses,\n * we do not need to worry about circular references.\n *\n * @internal\n */\nfunction decorateDecryptionResult(\n  decrypted: Document & { [kDecoratedKeys]?: Array<string> },\n  original: Document,\n  isTopLevelDecorateCall = true\n): void {\n  if (isTopLevelDecorateCall) {\n    // The original value could have been either a JS object or a BSON buffer\n    if (Buffer.isBuffer(original)) {\n      original = deserialize(original);\n    }\n    if (Buffer.isBuffer(decrypted)) {\n      throw new MongoRuntimeError('Expected result of decryption to be deserialized BSON object');\n    }\n  }\n\n  if (!decrypted || typeof decrypted !== 'object') return;\n  for (const k of Object.keys(decrypted)) {\n    const originalValue = original[k];\n\n    // An object was decrypted by libmongocrypt if and only if it was\n    // a BSON Binary object with subtype 6.\n    if (originalValue && originalValue._bsontype === 'Binary' && originalValue.sub_type === 6) {\n      if (!decrypted[kDecoratedKeys]) {\n        Object.defineProperty(decrypted, kDecoratedKeys, {\n          value: [],\n          configurable: true,\n          enumerable: false,\n          writable: false\n        });\n      }\n      // this is defined in the preceding if-statement\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      decrypted[kDecoratedKeys]!.push(k);\n      // Do not recurse into this decrypted value. It could be a sub-document/array,\n      // in which case there is no original value associated with its subfields.\n      continue;\n    }\n\n    decorateDecryptionResult(decrypted[k], originalValue, false);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}