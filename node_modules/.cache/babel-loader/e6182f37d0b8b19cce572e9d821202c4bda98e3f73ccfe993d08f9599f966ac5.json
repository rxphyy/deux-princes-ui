{"ast":null,"code":"\"use strict\";\n\nconst {\n  utf8Encode,\n  utf8DecodeWithoutBOM\n} = require(\"./encoding\");\nconst {\n  percentDecodeBytes,\n  utf8PercentEncodeString,\n  isURLEncodedPercentEncode\n} = require(\"./percent-encoding\");\nfunction p(char) {\n  return char.codePointAt(0);\n}\n\n// https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseUrlencoded(input) {\n  const sequences = strictlySplitByteSequence(input, p(\"&\"));\n  const output = [];\n  for (const bytes of sequences) {\n    if (bytes.length === 0) {\n      continue;\n    }\n    let name, value;\n    const indexOfEqual = bytes.indexOf(p(\"=\"));\n    if (indexOfEqual >= 0) {\n      name = bytes.slice(0, indexOfEqual);\n      value = bytes.slice(indexOfEqual + 1);\n    } else {\n      name = bytes;\n      value = new Uint8Array(0);\n    }\n    name = replaceByteInByteSequence(name, 0x2B, 0x20);\n    value = replaceByteInByteSequence(value, 0x2B, 0x20);\n    const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));\n    const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));\n    output.push([nameString, valueString]);\n  }\n  return output;\n}\n\n// https://url.spec.whatwg.org/#concept-urlencoded-string-parser\nfunction parseUrlencodedString(input) {\n  return parseUrlencoded(utf8Encode(input));\n}\n\n// https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeUrlencoded(tuples, encodingOverride = undefined) {\n  let encoding = \"utf-8\";\n  if (encodingOverride !== undefined) {\n    // TODO \"get the output encoding\", i.e. handle encoding labels vs. names.\n    encoding = encodingOverride;\n  }\n  let output = \"\";\n  for (const [i, tuple] of tuples.entries()) {\n    // TODO: handle encoding override\n\n    const name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);\n    let value = tuple[1];\n    if (tuple.length > 2 && tuple[2] !== undefined) {\n      if (tuple[2] === \"hidden\" && name === \"_charset_\") {\n        value = encoding;\n      } else if (tuple[2] === \"file\") {\n        // value is a File object\n        value = value.name;\n      }\n    }\n    value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);\n    if (i !== 0) {\n      output += \"&\";\n    }\n    output += `${name}=${value}`;\n  }\n  return output;\n}\nfunction strictlySplitByteSequence(buf, cp) {\n  const list = [];\n  let last = 0;\n  let i = buf.indexOf(cp);\n  while (i >= 0) {\n    list.push(buf.slice(last, i));\n    last = i + 1;\n    i = buf.indexOf(cp, last);\n  }\n  if (last !== buf.length) {\n    list.push(buf.slice(last));\n  }\n  return list;\n}\nfunction replaceByteInByteSequence(buf, from, to) {\n  let i = buf.indexOf(from);\n  while (i >= 0) {\n    buf[i] = to;\n    i = buf.indexOf(from, i + 1);\n  }\n  return buf;\n}\nmodule.exports = {\n  parseUrlencodedString,\n  serializeUrlencoded\n};","map":{"version":3,"names":["utf8Encode","utf8DecodeWithoutBOM","require","percentDecodeBytes","utf8PercentEncodeString","isURLEncodedPercentEncode","p","char","codePointAt","parseUrlencoded","input","sequences","strictlySplitByteSequence","output","bytes","length","name","value","indexOfEqual","indexOf","slice","Uint8Array","replaceByteInByteSequence","nameString","valueString","push","parseUrlencodedString","serializeUrlencoded","tuples","encodingOverride","undefined","encoding","i","tuple","entries","buf","cp","list","last","from","to","module","exports"],"sources":["C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/urlencoded.js"],"sourcesContent":["\"use strict\";\nconst { utf8Encode, utf8DecodeWithoutBOM } = require(\"./encoding\");\nconst { percentDecodeBytes, utf8PercentEncodeString, isURLEncodedPercentEncode } = require(\"./percent-encoding\");\n\nfunction p(char) {\n  return char.codePointAt(0);\n}\n\n// https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseUrlencoded(input) {\n  const sequences = strictlySplitByteSequence(input, p(\"&\"));\n  const output = [];\n  for (const bytes of sequences) {\n    if (bytes.length === 0) {\n      continue;\n    }\n\n    let name, value;\n    const indexOfEqual = bytes.indexOf(p(\"=\"));\n\n    if (indexOfEqual >= 0) {\n      name = bytes.slice(0, indexOfEqual);\n      value = bytes.slice(indexOfEqual + 1);\n    } else {\n      name = bytes;\n      value = new Uint8Array(0);\n    }\n\n    name = replaceByteInByteSequence(name, 0x2B, 0x20);\n    value = replaceByteInByteSequence(value, 0x2B, 0x20);\n\n    const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));\n    const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));\n\n    output.push([nameString, valueString]);\n  }\n  return output;\n}\n\n// https://url.spec.whatwg.org/#concept-urlencoded-string-parser\nfunction parseUrlencodedString(input) {\n  return parseUrlencoded(utf8Encode(input));\n}\n\n// https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeUrlencoded(tuples, encodingOverride = undefined) {\n  let encoding = \"utf-8\";\n  if (encodingOverride !== undefined) {\n    // TODO \"get the output encoding\", i.e. handle encoding labels vs. names.\n    encoding = encodingOverride;\n  }\n\n  let output = \"\";\n  for (const [i, tuple] of tuples.entries()) {\n    // TODO: handle encoding override\n\n    const name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);\n\n    let value = tuple[1];\n    if (tuple.length > 2 && tuple[2] !== undefined) {\n      if (tuple[2] === \"hidden\" && name === \"_charset_\") {\n        value = encoding;\n      } else if (tuple[2] === \"file\") {\n        // value is a File object\n        value = value.name;\n      }\n    }\n\n    value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);\n\n    if (i !== 0) {\n      output += \"&\";\n    }\n    output += `${name}=${value}`;\n  }\n  return output;\n}\n\nfunction strictlySplitByteSequence(buf, cp) {\n  const list = [];\n  let last = 0;\n  let i = buf.indexOf(cp);\n  while (i >= 0) {\n    list.push(buf.slice(last, i));\n    last = i + 1;\n    i = buf.indexOf(cp, last);\n  }\n  if (last !== buf.length) {\n    list.push(buf.slice(last));\n  }\n  return list;\n}\n\nfunction replaceByteInByteSequence(buf, from, to) {\n  let i = buf.indexOf(from);\n  while (i >= 0) {\n    buf[i] = to;\n    i = buf.indexOf(from, i + 1);\n  }\n  return buf;\n}\n\nmodule.exports = {\n  parseUrlencodedString,\n  serializeUrlencoded\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}