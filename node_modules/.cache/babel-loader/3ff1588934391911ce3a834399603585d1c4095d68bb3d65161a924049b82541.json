{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StateMachine = void 0;\nconst fs = require(\"fs/promises\");\nconst net = require(\"net\");\nconst tls = require(\"tls\");\nconst bson_1 = require(\"../bson\");\nconst deps_1 = require(\"../deps\");\nconst utils_1 = require(\"../utils\");\nconst errors_1 = require(\"./errors\");\nlet socks = null;\nfunction loadSocks() {\n  if (socks == null) {\n    const socksImport = (0, deps_1.getSocks)();\n    if ('kModuleError' in socksImport) {\n      throw socksImport.kModuleError;\n    }\n    socks = socksImport;\n  }\n  return socks;\n}\n// libmongocrypt states\nconst MONGOCRYPT_CTX_ERROR = 0;\nconst MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;\nconst MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;\nconst MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;\nconst MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS = 7;\nconst MONGOCRYPT_CTX_NEED_KMS = 4;\nconst MONGOCRYPT_CTX_READY = 5;\nconst MONGOCRYPT_CTX_DONE = 6;\nconst HTTPS_PORT = 443;\nconst stateToString = new Map([[MONGOCRYPT_CTX_ERROR, 'MONGOCRYPT_CTX_ERROR'], [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, 'MONGOCRYPT_CTX_NEED_MONGO_COLLINFO'], [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, 'MONGOCRYPT_CTX_NEED_MONGO_MARKINGS'], [MONGOCRYPT_CTX_NEED_MONGO_KEYS, 'MONGOCRYPT_CTX_NEED_MONGO_KEYS'], [MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS, 'MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS'], [MONGOCRYPT_CTX_NEED_KMS, 'MONGOCRYPT_CTX_NEED_KMS'], [MONGOCRYPT_CTX_READY, 'MONGOCRYPT_CTX_READY'], [MONGOCRYPT_CTX_DONE, 'MONGOCRYPT_CTX_DONE']]);\nconst INSECURE_TLS_OPTIONS = ['tlsInsecure', 'tlsAllowInvalidCertificates', 'tlsAllowInvalidHostnames',\n// These options are disallowed by the spec, so we explicitly filter them out if provided, even\n// though the StateMachine does not declare support for these options.\n'tlsDisableOCSPEndpointCheck', 'tlsDisableCertificateRevocationCheck'];\n/**\n * Helper function for logging. Enabled by setting the environment flag MONGODB_CRYPT_DEBUG.\n * @param msg - Anything you want to be logged.\n */\nfunction debug(msg) {\n  if (process.env.MONGODB_CRYPT_DEBUG) {\n    // eslint-disable-next-line no-console\n    console.error(msg);\n  }\n}\n/**\n * @internal\n * An internal class that executes across a MongoCryptContext until either\n * a finishing state or an error is reached. Do not instantiate directly.\n */\nclass StateMachine {\n  constructor(options, bsonOptions = (0, bson_1.pluckBSONSerializeOptions)(options)) {\n    this.options = options;\n    this.bsonOptions = bsonOptions;\n  }\n  /**\n   * Executes the state machine according to the specification\n   */\n  async execute(executor, context) {\n    const keyVaultNamespace = executor._keyVaultNamespace;\n    const keyVaultClient = executor._keyVaultClient;\n    const metaDataClient = executor._metaDataClient;\n    const mongocryptdClient = executor._mongocryptdClient;\n    const mongocryptdManager = executor._mongocryptdManager;\n    let result = null;\n    while (context.state !== MONGOCRYPT_CTX_DONE && context.state !== MONGOCRYPT_CTX_ERROR) {\n      debug(`[context#${context.id}] ${stateToString.get(context.state) || context.state}`);\n      switch (context.state) {\n        case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO:\n          {\n            const filter = (0, bson_1.deserialize)(context.nextMongoOperation());\n            if (!metaDataClient) {\n              throw new errors_1.MongoCryptError('unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_COLLINFO but metadata client is undefined');\n            }\n            const collInfo = await this.fetchCollectionInfo(metaDataClient, context.ns, filter);\n            if (collInfo) {\n              context.addMongoOperationResponse(collInfo);\n            }\n            context.finishMongoOperation();\n            break;\n          }\n        case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS:\n          {\n            const command = context.nextMongoOperation();\n            if (!mongocryptdClient) {\n              throw new errors_1.MongoCryptError('unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_MARKINGS but mongocryptdClient is undefined');\n            }\n            // When we are using the shared library, we don't have a mongocryptd manager.\n            const markedCommand = mongocryptdManager ? await mongocryptdManager.withRespawn(this.markCommand.bind(this, mongocryptdClient, context.ns, command)) : await this.markCommand(mongocryptdClient, context.ns, command);\n            context.addMongoOperationResponse(markedCommand);\n            context.finishMongoOperation();\n            break;\n          }\n        case MONGOCRYPT_CTX_NEED_MONGO_KEYS:\n          {\n            const filter = context.nextMongoOperation();\n            const keys = await this.fetchKeys(keyVaultClient, keyVaultNamespace, filter);\n            if (keys.length === 0) {\n              // This is kind of a hack.  For `rewrapManyDataKey`, we have tests that\n              // guarantee that when there are no matching keys, `rewrapManyDataKey` returns\n              // nothing.  We also have tests for auto encryption that guarantee for `encrypt`\n              // we return an error when there are no matching keys.  This error is generated in\n              // subsequent iterations of the state machine.\n              // Some apis (`encrypt`) throw if there are no filter matches and others (`rewrapManyDataKey`)\n              // do not.  We set the result manually here, and let the state machine continue.  `libmongocrypt`\n              // will inform us if we need to error by setting the state to `MONGOCRYPT_CTX_ERROR` but\n              // otherwise we'll return `{ v: [] }`.\n              result = {\n                v: []\n              };\n            }\n            for await (const key of keys) {\n              context.addMongoOperationResponse((0, bson_1.serialize)(key));\n            }\n            context.finishMongoOperation();\n            break;\n          }\n        case MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS:\n          {\n            const kmsProviders = await executor.askForKMSCredentials();\n            context.provideKMSProviders((0, bson_1.serialize)(kmsProviders));\n            break;\n          }\n        case MONGOCRYPT_CTX_NEED_KMS:\n          {\n            const requests = Array.from(this.requests(context));\n            await Promise.all(requests);\n            context.finishKMSRequests();\n            break;\n          }\n        case MONGOCRYPT_CTX_READY:\n          {\n            const finalizedContext = context.finalize();\n            // @ts-expect-error finalize can change the state, check for error\n            if (context.state === MONGOCRYPT_CTX_ERROR) {\n              const message = context.status.message || 'Finalization error';\n              throw new errors_1.MongoCryptError(message);\n            }\n            result = (0, bson_1.deserialize)(finalizedContext, this.options);\n            break;\n          }\n        default:\n          throw new errors_1.MongoCryptError(`Unknown state: ${context.state}`);\n      }\n    }\n    if (context.state === MONGOCRYPT_CTX_ERROR || result == null) {\n      const message = context.status.message;\n      if (!message) {\n        debug(`unidentifiable error in MongoCrypt - received an error status from \\`libmongocrypt\\` but received no error message.`);\n      }\n      throw new errors_1.MongoCryptError(message ?? 'unidentifiable error in MongoCrypt - received an error status from `libmongocrypt` but received no error message.');\n    }\n    return result;\n  }\n  /**\n   * Handles the request to the KMS service. Exposed for testing purposes. Do not directly invoke.\n   * @param kmsContext - A C++ KMS context returned from the bindings\n   * @returns A promise that resolves when the KMS reply has be fully parsed\n   */\n  kmsRequest(request) {\n    const parsedUrl = request.endpoint.split(':');\n    const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;\n    const options = {\n      host: parsedUrl[0],\n      servername: parsedUrl[0],\n      port\n    };\n    const message = request.message;\n    // TODO(NODE-3959): We can adopt `for-await on(socket, 'data')` with logic to control abort\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      const buffer = new utils_1.BufferPool();\n      // eslint-disable-next-line prefer-const\n      let socket;\n      let rawSocket;\n      function destroySockets() {\n        for (const sock of [socket, rawSocket]) {\n          if (sock) {\n            sock.removeAllListeners();\n            sock.destroy();\n          }\n        }\n      }\n      function ontimeout() {\n        destroySockets();\n        reject(new errors_1.MongoCryptError('KMS request timed out'));\n      }\n      function onerror(err) {\n        destroySockets();\n        const mcError = new errors_1.MongoCryptError('KMS request failed', {\n          cause: err\n        });\n        reject(mcError);\n      }\n      if (this.options.proxyOptions && this.options.proxyOptions.proxyHost) {\n        rawSocket = net.connect({\n          host: this.options.proxyOptions.proxyHost,\n          port: this.options.proxyOptions.proxyPort || 1080\n        });\n        rawSocket.on('timeout', ontimeout);\n        rawSocket.on('error', onerror);\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-var-requires\n          const events = require('events');\n          await events.once(rawSocket, 'connect');\n          socks ??= loadSocks();\n          options.socket = (await socks.SocksClient.createConnection({\n            existing_socket: rawSocket,\n            command: 'connect',\n            destination: {\n              host: options.host,\n              port: options.port\n            },\n            proxy: {\n              // host and port are ignored because we pass existing_socket\n              host: 'iLoveJavaScript',\n              port: 0,\n              type: 5,\n              userId: this.options.proxyOptions.proxyUsername,\n              password: this.options.proxyOptions.proxyPassword\n            }\n          })).socket;\n        } catch (err) {\n          return onerror(err);\n        }\n      }\n      const tlsOptions = this.options.tlsOptions;\n      if (tlsOptions) {\n        const kmsProvider = request.kmsProvider;\n        const providerTlsOptions = tlsOptions[kmsProvider];\n        if (providerTlsOptions) {\n          const error = this.validateTlsOptions(kmsProvider, providerTlsOptions);\n          if (error) reject(error);\n          try {\n            await this.setTlsOptions(providerTlsOptions, options);\n          } catch (error) {\n            return onerror(error);\n          }\n        }\n      }\n      socket = tls.connect(options, () => {\n        socket.write(message);\n      });\n      socket.once('timeout', ontimeout);\n      socket.once('error', onerror);\n      socket.on('data', data => {\n        buffer.append(data);\n        while (request.bytesNeeded > 0 && buffer.length) {\n          const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);\n          request.addResponse(buffer.read(bytesNeeded));\n        }\n        if (request.bytesNeeded <= 0) {\n          // There's no need for any more activity on this socket at this point.\n          destroySockets();\n          resolve();\n        }\n      });\n    });\n  }\n  *requests(context) {\n    for (let request = context.nextKMSRequest(); request != null; request = context.nextKMSRequest()) {\n      yield this.kmsRequest(request);\n    }\n  }\n  /**\n   * Validates the provided TLS options are secure.\n   *\n   * @param kmsProvider - The KMS provider name.\n   * @param tlsOptions - The client TLS options for the provider.\n   *\n   * @returns An error if any option is invalid.\n   */\n  validateTlsOptions(kmsProvider, tlsOptions) {\n    const tlsOptionNames = Object.keys(tlsOptions);\n    for (const option of INSECURE_TLS_OPTIONS) {\n      if (tlsOptionNames.includes(option)) {\n        return new errors_1.MongoCryptError(`Insecure TLS options prohibited for ${kmsProvider}: ${option}`);\n      }\n    }\n  }\n  /**\n   * Sets only the valid secure TLS options.\n   *\n   * @param tlsOptions - The client TLS options for the provider.\n   * @param options - The existing connection options.\n   */\n  async setTlsOptions(tlsOptions, options) {\n    if (tlsOptions.tlsCertificateKeyFile) {\n      const cert = await fs.readFile(tlsOptions.tlsCertificateKeyFile);\n      options.cert = options.key = cert;\n    }\n    if (tlsOptions.tlsCAFile) {\n      options.ca = await fs.readFile(tlsOptions.tlsCAFile);\n    }\n    if (tlsOptions.tlsCertificateKeyFilePassword) {\n      options.passphrase = tlsOptions.tlsCertificateKeyFilePassword;\n    }\n  }\n  /**\n   * Fetches collection info for a provided namespace, when libmongocrypt\n   * enters the `MONGOCRYPT_CTX_NEED_MONGO_COLLINFO` state. The result is\n   * used to inform libmongocrypt of the schema associated with this\n   * namespace. Exposed for testing purposes. Do not directly invoke.\n   *\n   * @param client - A MongoClient connected to the topology\n   * @param ns - The namespace to list collections from\n   * @param filter - A filter for the listCollections command\n   * @param callback - Invoked with the info of the requested collection, or with an error\n   */\n  async fetchCollectionInfo(client, ns, filter) {\n    const {\n      db\n    } = utils_1.MongoDBCollectionNamespace.fromString(ns);\n    const collections = await client.db(db).listCollections(filter, {\n      promoteLongs: false,\n      promoteValues: false\n    }).toArray();\n    const info = collections.length > 0 ? (0, bson_1.serialize)(collections[0]) : null;\n    return info;\n  }\n  /**\n   * Calls to the mongocryptd to provide markings for a command.\n   * Exposed for testing purposes. Do not directly invoke.\n   * @param client - A MongoClient connected to a mongocryptd\n   * @param ns - The namespace (database.collection) the command is being executed on\n   * @param command - The command to execute.\n   * @param callback - Invoked with the serialized and marked bson command, or with an error\n   */\n  async markCommand(client, ns, command) {\n    const options = {\n      promoteLongs: false,\n      promoteValues: false\n    };\n    const {\n      db\n    } = utils_1.MongoDBCollectionNamespace.fromString(ns);\n    const rawCommand = (0, bson_1.deserialize)(command, options);\n    const response = await client.db(db).command(rawCommand, options);\n    return (0, bson_1.serialize)(response, this.bsonOptions);\n  }\n  /**\n   * Requests keys from the keyVault collection on the topology.\n   * Exposed for testing purposes. Do not directly invoke.\n   * @param client - A MongoClient connected to the topology\n   * @param keyVaultNamespace - The namespace (database.collection) of the keyVault Collection\n   * @param filter - The filter for the find query against the keyVault Collection\n   * @param callback - Invoked with the found keys, or with an error\n   */\n  fetchKeys(client, keyVaultNamespace, filter) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(keyVaultNamespace);\n    return client.db(dbName).collection(collectionName, {\n      readConcern: {\n        level: 'majority'\n      }\n    }).find((0, bson_1.deserialize)(filter)).toArray();\n  }\n}\nexports.StateMachine = StateMachine;","map":{"version":3,"names":["fs","require","net","tls","bson_1","deps_1","utils_1","errors_1","socks","loadSocks","socksImport","getSocks","kModuleError","MONGOCRYPT_CTX_ERROR","MONGOCRYPT_CTX_NEED_MONGO_COLLINFO","MONGOCRYPT_CTX_NEED_MONGO_MARKINGS","MONGOCRYPT_CTX_NEED_MONGO_KEYS","MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS","MONGOCRYPT_CTX_NEED_KMS","MONGOCRYPT_CTX_READY","MONGOCRYPT_CTX_DONE","HTTPS_PORT","stateToString","Map","INSECURE_TLS_OPTIONS","debug","msg","process","env","MONGODB_CRYPT_DEBUG","console","error","StateMachine","constructor","options","bsonOptions","pluckBSONSerializeOptions","execute","executor","context","keyVaultNamespace","_keyVaultNamespace","keyVaultClient","_keyVaultClient","metaDataClient","_metaDataClient","mongocryptdClient","_mongocryptdClient","mongocryptdManager","_mongocryptdManager","result","state","id","get","filter","deserialize","nextMongoOperation","MongoCryptError","collInfo","fetchCollectionInfo","ns","addMongoOperationResponse","finishMongoOperation","command","markedCommand","withRespawn","markCommand","bind","keys","fetchKeys","length","v","key","serialize","kmsProviders","askForKMSCredentials","provideKMSProviders","requests","Array","from","Promise","all","finishKMSRequests","finalizedContext","finalize","message","status","kmsRequest","request","parsedUrl","endpoint","split","port","Number","parseInt","host","servername","resolve","reject","buffer","BufferPool","socket","rawSocket","destroySockets","sock","removeAllListeners","destroy","ontimeout","onerror","err","mcError","cause","proxyOptions","proxyHost","connect","proxyPort","on","events","once","SocksClient","createConnection","existing_socket","destination","proxy","type","userId","proxyUsername","password","proxyPassword","tlsOptions","kmsProvider","providerTlsOptions","validateTlsOptions","setTlsOptions","write","data","append","bytesNeeded","Math","min","addResponse","read","nextKMSRequest","tlsOptionNames","Object","option","includes","tlsCertificateKeyFile","cert","readFile","tlsCAFile","ca","tlsCertificateKeyFilePassword","passphrase","client","db","MongoDBCollectionNamespace","fromString","collections","listCollections","promoteLongs","promoteValues","toArray","info","rawCommand","response","dbName","collection","collectionName","readConcern","level","find","exports"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\client-side-encryption\\state_machine.ts"],"sourcesContent":["import * as fs from 'fs/promises';\nimport { type MongoCryptContext, type MongoCryptKMSRequest } from 'mongodb-client-encryption';\nimport * as net from 'net';\nimport * as tls from 'tls';\n\nimport {\n  type BSONSerializeOptions,\n  deserialize,\n  type Document,\n  pluckBSONSerializeOptions,\n  serialize\n} from '../bson';\nimport { type ProxyOptions } from '../cmap/connection';\nimport { getSocks, type SocksLib } from '../deps';\nimport { type MongoClient, type MongoClientOptions } from '../mongo_client';\nimport { BufferPool, MongoDBCollectionNamespace } from '../utils';\nimport { type DataKey } from './client_encryption';\nimport { MongoCryptError } from './errors';\nimport { type MongocryptdManager } from './mongocryptd_manager';\nimport { type ClientEncryptionDataKeyProvider, type KMSProviders } from './providers';\n\nlet socks: SocksLib | null = null;\nfunction loadSocks(): SocksLib {\n  if (socks == null) {\n    const socksImport = getSocks();\n    if ('kModuleError' in socksImport) {\n      throw socksImport.kModuleError;\n    }\n    socks = socksImport;\n  }\n  return socks;\n}\n\n// libmongocrypt states\nconst MONGOCRYPT_CTX_ERROR = 0;\nconst MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;\nconst MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;\nconst MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;\nconst MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS = 7;\nconst MONGOCRYPT_CTX_NEED_KMS = 4;\nconst MONGOCRYPT_CTX_READY = 5;\nconst MONGOCRYPT_CTX_DONE = 6;\n\nconst HTTPS_PORT = 443;\n\nconst stateToString = new Map([\n  [MONGOCRYPT_CTX_ERROR, 'MONGOCRYPT_CTX_ERROR'],\n  [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, 'MONGOCRYPT_CTX_NEED_MONGO_COLLINFO'],\n  [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, 'MONGOCRYPT_CTX_NEED_MONGO_MARKINGS'],\n  [MONGOCRYPT_CTX_NEED_MONGO_KEYS, 'MONGOCRYPT_CTX_NEED_MONGO_KEYS'],\n  [MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS, 'MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS'],\n  [MONGOCRYPT_CTX_NEED_KMS, 'MONGOCRYPT_CTX_NEED_KMS'],\n  [MONGOCRYPT_CTX_READY, 'MONGOCRYPT_CTX_READY'],\n  [MONGOCRYPT_CTX_DONE, 'MONGOCRYPT_CTX_DONE']\n]);\n\nconst INSECURE_TLS_OPTIONS = [\n  'tlsInsecure',\n  'tlsAllowInvalidCertificates',\n  'tlsAllowInvalidHostnames',\n\n  // These options are disallowed by the spec, so we explicitly filter them out if provided, even\n  // though the StateMachine does not declare support for these options.\n  'tlsDisableOCSPEndpointCheck',\n  'tlsDisableCertificateRevocationCheck'\n];\n\n/**\n * Helper function for logging. Enabled by setting the environment flag MONGODB_CRYPT_DEBUG.\n * @param msg - Anything you want to be logged.\n */\nfunction debug(msg: unknown) {\n  if (process.env.MONGODB_CRYPT_DEBUG) {\n    // eslint-disable-next-line no-console\n    console.error(msg);\n  }\n}\n\ndeclare module 'mongodb-client-encryption' {\n  // the properties added to `MongoCryptContext` here are only used for the `StateMachine`'s\n  // execute method and are not part of the C++ bindings.\n  interface MongoCryptContext {\n    id: number;\n    document: Document;\n    ns: string;\n  }\n}\n\n/**\n * @public\n *\n * TLS options to use when connecting. The spec specifically calls out which insecure\n * tls options are not allowed:\n *\n *  - tlsAllowInvalidCertificates\n *  - tlsAllowInvalidHostnames\n *  - tlsInsecure\n *\n * These options are not included in the type, and are ignored if provided.\n */\nexport type ClientEncryptionTlsOptions = Pick<\n  MongoClientOptions,\n  'tlsCAFile' | 'tlsCertificateKeyFile' | 'tlsCertificateKeyFilePassword'\n>;\n\n/** @public */\nexport type CSFLEKMSTlsOptions = {\n  aws?: ClientEncryptionTlsOptions;\n  gcp?: ClientEncryptionTlsOptions;\n  kmip?: ClientEncryptionTlsOptions;\n  local?: ClientEncryptionTlsOptions;\n  azure?: ClientEncryptionTlsOptions;\n};\n\n/**\n * @internal\n *\n * An interface representing an object that can be passed to the `StateMachine.execute` method.\n *\n * Not all properties are required for all operations.\n */\nexport interface StateMachineExecutable {\n  _keyVaultNamespace: string;\n  _keyVaultClient: MongoClient;\n  askForKMSCredentials: () => Promise<KMSProviders>;\n\n  /** only used for auto encryption */\n  _metaDataClient?: MongoClient;\n  /** only used for auto encryption */\n  _mongocryptdClient?: MongoClient;\n  /** only used for auto encryption */\n  _mongocryptdManager?: MongocryptdManager;\n}\n\nexport type StateMachineOptions = {\n  /** socks5 proxy options, if set. */\n  proxyOptions: ProxyOptions;\n\n  /** TLS options for KMS requests, if set. */\n  tlsOptions: CSFLEKMSTlsOptions;\n} & Pick<BSONSerializeOptions, 'promoteLongs' | 'promoteValues'>;\n\n/**\n * @internal\n * An internal class that executes across a MongoCryptContext until either\n * a finishing state or an error is reached. Do not instantiate directly.\n */\nexport class StateMachine {\n  constructor(\n    private options: StateMachineOptions,\n    private bsonOptions = pluckBSONSerializeOptions(options)\n  ) {}\n\n  /**\n   * Executes the state machine according to the specification\n   */\n  async execute<T extends Document>(\n    executor: StateMachineExecutable,\n    context: MongoCryptContext\n  ): Promise<T> {\n    const keyVaultNamespace = executor._keyVaultNamespace;\n    const keyVaultClient = executor._keyVaultClient;\n    const metaDataClient = executor._metaDataClient;\n    const mongocryptdClient = executor._mongocryptdClient;\n    const mongocryptdManager = executor._mongocryptdManager;\n    let result: T | null = null;\n\n    while (context.state !== MONGOCRYPT_CTX_DONE && context.state !== MONGOCRYPT_CTX_ERROR) {\n      debug(`[context#${context.id}] ${stateToString.get(context.state) || context.state}`);\n\n      switch (context.state) {\n        case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {\n          const filter = deserialize(context.nextMongoOperation());\n          if (!metaDataClient) {\n            throw new MongoCryptError(\n              'unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_COLLINFO but metadata client is undefined'\n            );\n          }\n          const collInfo = await this.fetchCollectionInfo(metaDataClient, context.ns, filter);\n\n          if (collInfo) {\n            context.addMongoOperationResponse(collInfo);\n          }\n\n          context.finishMongoOperation();\n          break;\n        }\n\n        case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {\n          const command = context.nextMongoOperation();\n          if (!mongocryptdClient) {\n            throw new MongoCryptError(\n              'unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_MARKINGS but mongocryptdClient is undefined'\n            );\n          }\n\n          // When we are using the shared library, we don't have a mongocryptd manager.\n          const markedCommand: Uint8Array = mongocryptdManager\n            ? await mongocryptdManager.withRespawn(\n                this.markCommand.bind(this, mongocryptdClient, context.ns, command)\n              )\n            : await this.markCommand(mongocryptdClient, context.ns, command);\n\n          context.addMongoOperationResponse(markedCommand);\n          context.finishMongoOperation();\n          break;\n        }\n\n        case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {\n          const filter = context.nextMongoOperation();\n          const keys = await this.fetchKeys(keyVaultClient, keyVaultNamespace, filter);\n\n          if (keys.length === 0) {\n            // This is kind of a hack.  For `rewrapManyDataKey`, we have tests that\n            // guarantee that when there are no matching keys, `rewrapManyDataKey` returns\n            // nothing.  We also have tests for auto encryption that guarantee for `encrypt`\n            // we return an error when there are no matching keys.  This error is generated in\n            // subsequent iterations of the state machine.\n            // Some apis (`encrypt`) throw if there are no filter matches and others (`rewrapManyDataKey`)\n            // do not.  We set the result manually here, and let the state machine continue.  `libmongocrypt`\n            // will inform us if we need to error by setting the state to `MONGOCRYPT_CTX_ERROR` but\n            // otherwise we'll return `{ v: [] }`.\n            result = { v: [] } as any as T;\n          }\n          for await (const key of keys) {\n            context.addMongoOperationResponse(serialize(key));\n          }\n\n          context.finishMongoOperation();\n\n          break;\n        }\n\n        case MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS: {\n          const kmsProviders = await executor.askForKMSCredentials();\n          context.provideKMSProviders(serialize(kmsProviders));\n          break;\n        }\n\n        case MONGOCRYPT_CTX_NEED_KMS: {\n          const requests = Array.from(this.requests(context));\n          await Promise.all(requests);\n\n          context.finishKMSRequests();\n          break;\n        }\n\n        case MONGOCRYPT_CTX_READY: {\n          const finalizedContext = context.finalize();\n          // @ts-expect-error finalize can change the state, check for error\n          if (context.state === MONGOCRYPT_CTX_ERROR) {\n            const message = context.status.message || 'Finalization error';\n            throw new MongoCryptError(message);\n          }\n          result = deserialize(finalizedContext, this.options) as T;\n          break;\n        }\n\n        default:\n          throw new MongoCryptError(`Unknown state: ${context.state}`);\n      }\n    }\n\n    if (context.state === MONGOCRYPT_CTX_ERROR || result == null) {\n      const message = context.status.message;\n      if (!message) {\n        debug(\n          `unidentifiable error in MongoCrypt - received an error status from \\`libmongocrypt\\` but received no error message.`\n        );\n      }\n      throw new MongoCryptError(\n        message ??\n          'unidentifiable error in MongoCrypt - received an error status from `libmongocrypt` but received no error message.'\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Handles the request to the KMS service. Exposed for testing purposes. Do not directly invoke.\n   * @param kmsContext - A C++ KMS context returned from the bindings\n   * @returns A promise that resolves when the KMS reply has be fully parsed\n   */\n  kmsRequest(request: MongoCryptKMSRequest): Promise<void> {\n    const parsedUrl = request.endpoint.split(':');\n    const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;\n    const options: tls.ConnectionOptions & { host: string; port: number } = {\n      host: parsedUrl[0],\n      servername: parsedUrl[0],\n      port\n    };\n    const message = request.message;\n\n    // TODO(NODE-3959): We can adopt `for-await on(socket, 'data')` with logic to control abort\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      const buffer = new BufferPool();\n\n      // eslint-disable-next-line prefer-const\n      let socket: net.Socket;\n      let rawSocket: net.Socket;\n\n      function destroySockets() {\n        for (const sock of [socket, rawSocket]) {\n          if (sock) {\n            sock.removeAllListeners();\n            sock.destroy();\n          }\n        }\n      }\n\n      function ontimeout() {\n        destroySockets();\n        reject(new MongoCryptError('KMS request timed out'));\n      }\n\n      function onerror(err: Error) {\n        destroySockets();\n        const mcError = new MongoCryptError('KMS request failed', { cause: err });\n        reject(mcError);\n      }\n\n      if (this.options.proxyOptions && this.options.proxyOptions.proxyHost) {\n        rawSocket = net.connect({\n          host: this.options.proxyOptions.proxyHost,\n          port: this.options.proxyOptions.proxyPort || 1080\n        });\n\n        rawSocket.on('timeout', ontimeout);\n        rawSocket.on('error', onerror);\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-var-requires\n          const events = require('events') as typeof import('events');\n          await events.once(rawSocket, 'connect');\n          socks ??= loadSocks();\n          options.socket = (\n            await socks.SocksClient.createConnection({\n              existing_socket: rawSocket,\n              command: 'connect',\n              destination: { host: options.host, port: options.port },\n              proxy: {\n                // host and port are ignored because we pass existing_socket\n                host: 'iLoveJavaScript',\n                port: 0,\n                type: 5,\n                userId: this.options.proxyOptions.proxyUsername,\n                password: this.options.proxyOptions.proxyPassword\n              }\n            })\n          ).socket;\n        } catch (err) {\n          return onerror(err);\n        }\n      }\n\n      const tlsOptions = this.options.tlsOptions;\n      if (tlsOptions) {\n        const kmsProvider = request.kmsProvider as ClientEncryptionDataKeyProvider;\n        const providerTlsOptions = tlsOptions[kmsProvider];\n        if (providerTlsOptions) {\n          const error = this.validateTlsOptions(kmsProvider, providerTlsOptions);\n          if (error) reject(error);\n          try {\n            await this.setTlsOptions(providerTlsOptions, options);\n          } catch (error) {\n            return onerror(error);\n          }\n        }\n      }\n      socket = tls.connect(options, () => {\n        socket.write(message);\n      });\n\n      socket.once('timeout', ontimeout);\n      socket.once('error', onerror);\n\n      socket.on('data', data => {\n        buffer.append(data);\n        while (request.bytesNeeded > 0 && buffer.length) {\n          const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);\n          request.addResponse(buffer.read(bytesNeeded));\n        }\n\n        if (request.bytesNeeded <= 0) {\n          // There's no need for any more activity on this socket at this point.\n          destroySockets();\n          resolve();\n        }\n      });\n    });\n  }\n\n  *requests(context: MongoCryptContext) {\n    for (\n      let request = context.nextKMSRequest();\n      request != null;\n      request = context.nextKMSRequest()\n    ) {\n      yield this.kmsRequest(request);\n    }\n  }\n\n  /**\n   * Validates the provided TLS options are secure.\n   *\n   * @param kmsProvider - The KMS provider name.\n   * @param tlsOptions - The client TLS options for the provider.\n   *\n   * @returns An error if any option is invalid.\n   */\n  validateTlsOptions(\n    kmsProvider: string,\n    tlsOptions: ClientEncryptionTlsOptions\n  ): MongoCryptError | void {\n    const tlsOptionNames = Object.keys(tlsOptions);\n    for (const option of INSECURE_TLS_OPTIONS) {\n      if (tlsOptionNames.includes(option)) {\n        return new MongoCryptError(`Insecure TLS options prohibited for ${kmsProvider}: ${option}`);\n      }\n    }\n  }\n\n  /**\n   * Sets only the valid secure TLS options.\n   *\n   * @param tlsOptions - The client TLS options for the provider.\n   * @param options - The existing connection options.\n   */\n  async setTlsOptions(\n    tlsOptions: ClientEncryptionTlsOptions,\n    options: tls.ConnectionOptions\n  ): Promise<void> {\n    if (tlsOptions.tlsCertificateKeyFile) {\n      const cert = await fs.readFile(tlsOptions.tlsCertificateKeyFile);\n      options.cert = options.key = cert;\n    }\n    if (tlsOptions.tlsCAFile) {\n      options.ca = await fs.readFile(tlsOptions.tlsCAFile);\n    }\n    if (tlsOptions.tlsCertificateKeyFilePassword) {\n      options.passphrase = tlsOptions.tlsCertificateKeyFilePassword;\n    }\n  }\n\n  /**\n   * Fetches collection info for a provided namespace, when libmongocrypt\n   * enters the `MONGOCRYPT_CTX_NEED_MONGO_COLLINFO` state. The result is\n   * used to inform libmongocrypt of the schema associated with this\n   * namespace. Exposed for testing purposes. Do not directly invoke.\n   *\n   * @param client - A MongoClient connected to the topology\n   * @param ns - The namespace to list collections from\n   * @param filter - A filter for the listCollections command\n   * @param callback - Invoked with the info of the requested collection, or with an error\n   */\n  async fetchCollectionInfo(\n    client: MongoClient,\n    ns: string,\n    filter: Document\n  ): Promise<Uint8Array | null> {\n    const { db } = MongoDBCollectionNamespace.fromString(ns);\n\n    const collections = await client\n      .db(db)\n      .listCollections(filter, {\n        promoteLongs: false,\n        promoteValues: false\n      })\n      .toArray();\n\n    const info = collections.length > 0 ? serialize(collections[0]) : null;\n    return info;\n  }\n\n  /**\n   * Calls to the mongocryptd to provide markings for a command.\n   * Exposed for testing purposes. Do not directly invoke.\n   * @param client - A MongoClient connected to a mongocryptd\n   * @param ns - The namespace (database.collection) the command is being executed on\n   * @param command - The command to execute.\n   * @param callback - Invoked with the serialized and marked bson command, or with an error\n   */\n  async markCommand(client: MongoClient, ns: string, command: Uint8Array): Promise<Uint8Array> {\n    const options = { promoteLongs: false, promoteValues: false };\n    const { db } = MongoDBCollectionNamespace.fromString(ns);\n    const rawCommand = deserialize(command, options);\n\n    const response = await client.db(db).command(rawCommand, options);\n\n    return serialize(response, this.bsonOptions);\n  }\n\n  /**\n   * Requests keys from the keyVault collection on the topology.\n   * Exposed for testing purposes. Do not directly invoke.\n   * @param client - A MongoClient connected to the topology\n   * @param keyVaultNamespace - The namespace (database.collection) of the keyVault Collection\n   * @param filter - The filter for the find query against the keyVault Collection\n   * @param callback - Invoked with the found keys, or with an error\n   */\n  fetchKeys(\n    client: MongoClient,\n    keyVaultNamespace: string,\n    filter: Uint8Array\n  ): Promise<Array<DataKey>> {\n    const { db: dbName, collection: collectionName } =\n      MongoDBCollectionNamespace.fromString(keyVaultNamespace);\n\n    return client\n      .db(dbName)\n      .collection<DataKey>(collectionName, { readConcern: { level: 'majority' } })\n      .find(deserialize(filter))\n      .toArray();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}