{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readPreferenceServerSelector = exports.secondaryWritableServerSelector = exports.sameServerSelector = exports.writableServerSelector = exports.MIN_SECONDARY_WRITE_WIRE_VERSION = void 0;\nvar error_1 = require(\"../error\");\nvar read_preference_1 = require(\"../read_preference\");\nvar common_1 = require(\"./common\");\n// max staleness constants\nvar IDLE_WRITE_PERIOD = 10000;\nvar SMALLEST_MAX_STALENESS_SECONDS = 90;\n//  Minimum version to try writes on secondaries.\nexports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;\n/**\n * Returns a server selector that selects for writable servers\n */\nfunction writableServerSelector() {\n  return function (topologyDescription, servers) {\n    return latencyWindowReducer(topologyDescription, servers.filter(function (s) {\n      return s.isWritable;\n    }));\n  };\n}\nexports.writableServerSelector = writableServerSelector;\n/**\n * The purpose of this selector is to select the same server, only\n * if it is in a state that it can have commands sent to it.\n */\nfunction sameServerSelector(description) {\n  return function (topologyDescription, servers) {\n    if (!description) return [];\n    // Filter the servers to match the provided description only if\n    // the type is not unknown.\n    return servers.filter(function (sd) {\n      return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;\n    });\n  };\n}\nexports.sameServerSelector = sameServerSelector;\n/**\n * Returns a server selector that uses a read preference to select a\n * server potentially for a write on a secondary.\n */\nfunction secondaryWritableServerSelector(wireVersion, readPreference) {\n  // If server version < 5.0, read preference always primary.\n  // If server version >= 5.0...\n  // - If read preference is supplied, use that.\n  // - If no read preference is supplied, use primary.\n  if (!readPreference || !wireVersion || wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION) {\n    return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);\n  }\n  return readPreferenceServerSelector(readPreference);\n}\nexports.secondaryWritableServerSelector = secondaryWritableServerSelector;\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param readPreference - The read preference providing max staleness guidance\n * @param topologyDescription - The topology description\n * @param servers - The list of server descriptions to be reduced\n * @returns The list of servers that satisfy the requirements of max staleness\n */\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n  var maxStaleness = readPreference.maxStalenessSeconds;\n  var maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n  if (maxStaleness < maxStalenessVariance) {\n    throw new error_1.MongoInvalidArgumentError(\"Option \\\"maxStalenessSeconds\\\" must be at least \".concat(maxStalenessVariance, \" seconds\"));\n  }\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new error_1.MongoInvalidArgumentError(\"Option \\\"maxStalenessSeconds\\\" must be at least \".concat(SMALLEST_MAX_STALENESS_SECONDS, \" seconds\"));\n  }\n  if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {\n    var primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n    return servers.reduce(function (result, server) {\n      var _readPreference$maxSt;\n      var stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;\n      var staleness = stalenessMS / 1000;\n      var maxStalenessSeconds = (_readPreference$maxSt = readPreference.maxStalenessSeconds) !== null && _readPreference$maxSt !== void 0 ? _readPreference$maxSt : 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n      return result;\n    }, []);\n  }\n  if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n    var sMax = servers.reduce(function (max, s) {\n      return s.lastWriteDate > max.lastWriteDate ? s : max;\n    });\n    return servers.reduce(function (result, server) {\n      var _readPreference$maxSt2;\n      var stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n      var staleness = stalenessMS / 1000;\n      var maxStalenessSeconds = (_readPreference$maxSt2 = readPreference.maxStalenessSeconds) !== null && _readPreference$maxSt2 !== void 0 ? _readPreference$maxSt2 : 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n      return result;\n    }, []);\n  }\n  return servers;\n}\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param tagSet - The requested tag set to match\n * @param serverTags - The server's tags\n */\nfunction tagSetMatch(tagSet, serverTags) {\n  var keys = Object.keys(tagSet);\n  var serverTagKeys = Object.keys(serverTags);\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param readPreference - The read preference providing the requested tags\n * @param servers - The list of server descriptions to reduce\n * @returns The list of servers matching the requested tags\n */\nfunction tagSetReducer(readPreference, servers) {\n  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {\n    return servers;\n  }\n  var _loop = function _loop() {\n      var tagSet = readPreference.tags[i];\n      var serversMatchingTagset = servers.reduce(function (matched, server) {\n        if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n        return matched;\n      }, []);\n      if (serversMatchingTagset.length) {\n        return {\n          v: serversMatchingTagset\n        };\n      }\n    },\n    _ret;\n  for (var i = 0; i < readPreference.tags.length; ++i) {\n    _ret = _loop();\n    if (_ret) return _ret.v;\n  }\n  return [];\n}\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param topologyDescription - The topology description\n * @param servers - The list of servers to reduce\n * @returns The servers which fall within an acceptable latency window\n */\nfunction latencyWindowReducer(topologyDescription, servers) {\n  var low = servers.reduce(function (min, server) {\n    return min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min);\n  }, -1);\n  var high = low + topologyDescription.localThresholdMS;\n  return servers.reduce(function (result, server) {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n}\n// filters\nfunction primaryFilter(server) {\n  return server.type === common_1.ServerType.RSPrimary;\n}\nfunction secondaryFilter(server) {\n  return server.type === common_1.ServerType.RSSecondary;\n}\nfunction nearestFilter(server) {\n  return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;\n}\nfunction knownFilter(server) {\n  return server.type !== common_1.ServerType.Unknown;\n}\nfunction loadBalancerFilter(server) {\n  return server.type === common_1.ServerType.LoadBalancer;\n}\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param readPreference - The read preference to select with\n */\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new error_1.MongoInvalidArgumentError('Invalid read preference specified');\n  }\n  return function (topologyDescription, servers) {\n    var commonWireVersion = topologyDescription.commonWireVersion;\n    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {\n      throw new error_1.MongoCompatibilityError(\"Minimum wire version '\".concat(readPreference.minWireVersion, \"' required, but found '\").concat(commonWireVersion, \"'\"));\n    }\n    if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {\n      return servers.filter(loadBalancerFilter);\n    }\n    if (topologyDescription.type === common_1.TopologyType.Unknown) {\n      return [];\n    }\n    if (topologyDescription.type === common_1.TopologyType.Single || topologyDescription.type === common_1.TopologyType.Sharded) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n    var mode = readPreference.mode;\n    if (mode === read_preference_1.ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n    if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {\n      var result = servers.filter(primaryFilter);\n      if (result.length) {\n        return result;\n      }\n    }\n    var filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    var selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));\n    if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n    return selectedServers;\n  };\n}\nexports.readPreferenceServerSelector = readPreferenceServerSelector;","map":{"version":3,"names":["error_1","require","read_preference_1","common_1","IDLE_WRITE_PERIOD","SMALLEST_MAX_STALENESS_SECONDS","exports","MIN_SECONDARY_WRITE_WIRE_VERSION","writableServerSelector","topologyDescription","servers","latencyWindowReducer","filter","s","isWritable","sameServerSelector","description","sd","address","type","ServerType","Unknown","secondaryWritableServerSelector","wireVersion","readPreference","readPreferenceServerSelector","ReadPreference","primary","maxStalenessReducer","maxStalenessSeconds","maxStaleness","maxStalenessVariance","heartbeatFrequencyMS","MongoInvalidArgumentError","concat","TopologyType","ReplicaSetWithPrimary","Array","from","values","primaryFilter","reduce","result","server","_readPreference$maxSt","stalenessMS","lastUpdateTime","lastWriteDate","staleness","push","ReplicaSetNoPrimary","length","sMax","max","_readPreference$maxSt2","tagSetMatch","tagSet","serverTags","keys","Object","serverTagKeys","i","key","indexOf","tagSetReducer","tags","isArray","_loop","serversMatchingTagset","matched","v","_ret","low","min","roundTripTime","Math","high","localThresholdMS","RSPrimary","secondaryFilter","RSSecondary","nearestFilter","knownFilter","loadBalancerFilter","LoadBalancer","isValid","commonWireVersion","minWireVersion","MongoCompatibilityError","LoadBalanced","Single","Sharded","mode","PRIMARY","PRIMARY_PREFERRED","NEAREST","selectedServers","SECONDARY_PREFERRED"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\sdam\\server_selection.ts"],"sourcesContent":["import { MongoCompatibilityError, MongoInvalidArgumentError } from '../error';\nimport { ReadPreference } from '../read_preference';\nimport { ServerType, TopologyType } from './common';\nimport type { ServerDescription, TagSet } from './server_description';\nimport type { TopologyDescription } from './topology_description';\n\n// max staleness constants\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n\n//  Minimum version to try writes on secondaries.\nexport const MIN_SECONDARY_WRITE_WIRE_VERSION = 13;\n\n/** @internal */\nexport type ServerSelector = (\n  topologyDescription: TopologyDescription,\n  servers: ServerDescription[]\n) => ServerDescription[];\n\n/**\n * Returns a server selector that selects for writable servers\n */\nexport function writableServerSelector(): ServerSelector {\n  return (\n    topologyDescription: TopologyDescription,\n    servers: ServerDescription[]\n  ): ServerDescription[] =>\n    latencyWindowReducer(\n      topologyDescription,\n      servers.filter((s: ServerDescription) => s.isWritable)\n    );\n}\n\n/**\n * The purpose of this selector is to select the same server, only\n * if it is in a state that it can have commands sent to it.\n */\nexport function sameServerSelector(description?: ServerDescription): ServerSelector {\n  return (\n    topologyDescription: TopologyDescription,\n    servers: ServerDescription[]\n  ): ServerDescription[] => {\n    if (!description) return [];\n    // Filter the servers to match the provided description only if\n    // the type is not unknown.\n    return servers.filter(sd => {\n      return sd.address === description.address && sd.type !== ServerType.Unknown;\n    });\n  };\n}\n\n/**\n * Returns a server selector that uses a read preference to select a\n * server potentially for a write on a secondary.\n */\nexport function secondaryWritableServerSelector(\n  wireVersion?: number,\n  readPreference?: ReadPreference\n): ServerSelector {\n  // If server version < 5.0, read preference always primary.\n  // If server version >= 5.0...\n  // - If read preference is supplied, use that.\n  // - If no read preference is supplied, use primary.\n  if (\n    !readPreference ||\n    !wireVersion ||\n    (wireVersion && wireVersion < MIN_SECONDARY_WRITE_WIRE_VERSION)\n  ) {\n    return readPreferenceServerSelector(ReadPreference.primary);\n  }\n  return readPreferenceServerSelector(readPreference);\n}\n\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param readPreference - The read preference providing max staleness guidance\n * @param topologyDescription - The topology description\n * @param servers - The list of server descriptions to be reduced\n * @returns The list of servers that satisfy the requirements of max staleness\n */\nfunction maxStalenessReducer(\n  readPreference: ReadPreference,\n  topologyDescription: TopologyDescription,\n  servers: ServerDescription[]\n): ServerDescription[] {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance =\n    (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n  if (maxStaleness < maxStalenessVariance) {\n    throw new MongoInvalidArgumentError(\n      `Option \"maxStalenessSeconds\" must be at least ${maxStalenessVariance} seconds`\n    );\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new MongoInvalidArgumentError(\n      `Option \"maxStalenessSeconds\" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`\n    );\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\n    const primary: ServerDescription = Array.from(topologyDescription.servers.values()).filter(\n      primaryFilter\n    )[0];\n\n    return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\n      const stalenessMS =\n        server.lastUpdateTime -\n        server.lastWriteDate -\n        (primary.lastUpdateTime - primary.lastWriteDate) +\n        topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n\n    const sMax = servers.reduce((max: ServerDescription, s: ServerDescription) =>\n      s.lastWriteDate > max.lastWriteDate ? s : max\n    );\n\n    return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\n      const stalenessMS =\n        sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param tagSet - The requested tag set to match\n * @param serverTags - The server's tags\n */\nfunction tagSetMatch(tagSet: TagSet, serverTags: TagSet) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param readPreference - The read preference providing the requested tags\n * @param servers - The list of server descriptions to reduce\n * @returns The list of servers matching the requested tags\n */\nfunction tagSetReducer(\n  readPreference: ReadPreference,\n  servers: ServerDescription[]\n): ServerDescription[] {\n  if (\n    readPreference.tags == null ||\n    (Array.isArray(readPreference.tags) && readPreference.tags.length === 0)\n  ) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce(\n      (matched: ServerDescription[], server: ServerDescription) => {\n        if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n        return matched;\n      },\n      []\n    );\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param topologyDescription - The topology description\n * @param servers - The list of servers to reduce\n * @returns The servers which fall within an acceptable latency window\n */\nfunction latencyWindowReducer(\n  topologyDescription: TopologyDescription,\n  servers: ServerDescription[]\n): ServerDescription[] {\n  const low = servers.reduce(\n    (min: number, server: ServerDescription) =>\n      min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min),\n    -1\n  );\n\n  const high = low + topologyDescription.localThresholdMS;\n  return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n}\n\n// filters\nfunction primaryFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\n}\n\nfunction knownFilter(server: ServerDescription): boolean {\n  return server.type !== ServerType.Unknown;\n}\n\nfunction loadBalancerFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.LoadBalancer;\n}\n\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param readPreference - The read preference to select with\n */\nexport function readPreferenceServerSelector(readPreference: ReadPreference): ServerSelector {\n  if (!readPreference.isValid()) {\n    throw new MongoInvalidArgumentError('Invalid read preference specified');\n  }\n\n  return (\n    topologyDescription: TopologyDescription,\n    servers: ServerDescription[]\n  ): ServerDescription[] => {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n    if (\n      commonWireVersion &&\n      readPreference.minWireVersion &&\n      readPreference.minWireVersion > commonWireVersion\n    ) {\n      throw new MongoCompatibilityError(\n        `Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`\n      );\n    }\n\n    if (topologyDescription.type === TopologyType.LoadBalanced) {\n      return servers.filter(loadBalancerFilter);\n    }\n\n    if (topologyDescription.type === TopologyType.Unknown) {\n      return [];\n    }\n\n    if (\n      topologyDescription.type === TopologyType.Single ||\n      topologyDescription.type === TopologyType.Sharded\n    ) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    const mode = readPreference.mode;\n    if (mode === ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (mode === ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n      if (result.length) {\n        return result;\n      }\n    }\n\n    const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    const selectedServers = latencyWindowReducer(\n      topologyDescription,\n      tagSetReducer(\n        readPreference,\n        maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))\n      )\n    );\n\n    if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n\n    return selectedServers;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}