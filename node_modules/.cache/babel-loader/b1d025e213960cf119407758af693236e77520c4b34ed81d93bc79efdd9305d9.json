{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _objectSpread = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _defineProperty = require(\"C:/Users/raphm/Documents/Projects/youtube-transcript/youtube-transcript/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _ref;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ServerCapabilities = exports.Topology = void 0;\nvar timers_1 = require(\"timers\");\nvar util_1 = require(\"util\");\nvar connection_string_1 = require(\"../connection_string\");\nvar constants_1 = require(\"../constants\");\nvar error_1 = require(\"../error\");\nvar mongo_types_1 = require(\"../mongo_types\");\nvar read_preference_1 = require(\"../read_preference\");\nvar utils_1 = require(\"../utils\");\nvar common_1 = require(\"./common\");\nvar events_1 = require(\"./events\");\nvar server_1 = require(\"./server\");\nvar server_description_1 = require(\"./server_description\");\nvar server_selection_1 = require(\"./server_selection\");\nvar srv_polling_1 = require(\"./srv_polling\");\nvar topology_description_1 = require(\"./topology_description\");\n// Global state\nvar globalTopologyCounter = 0;\nvar stateTransition = (0, utils_1.makeStateMachine)((_ref = {}, _defineProperty(_ref, common_1.STATE_CLOSED, [common_1.STATE_CLOSED, common_1.STATE_CONNECTING]), _defineProperty(_ref, common_1.STATE_CONNECTING, [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CONNECTED, [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CLOSING, [common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _ref));\n/** @internal */\nvar kCancelled = Symbol('cancelled');\n/** @internal */\nvar kWaitQueue = Symbol('waitQueue');\n/**\n * A container of server instances representing a connection to a MongoDB topology.\n * @internal\n */\nvar Topology = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(Topology, _mongo_types_1$TypedE);\n  var _super = _createSuper(Topology);\n  /**\n   * @param seedlist - a list of HostAddress instances to connect to\n   */\n  function Topology(client, seeds, options) {\n    var _options, _options2;\n    var _this;\n    _classCallCheck(this, Topology);\n    _this = _super.call(this);\n    _this.client = client;\n    _this.selectServerAsync = (0, util_1.promisify)(function (selector, options, callback) {\n      return _this.selectServer(selector, options, callback);\n    });\n    // Options should only be undefined in tests, MongoClient will always have defined options\n    options = (_options = options) !== null && _options !== void 0 ? _options : _objectSpread(_objectSpread({\n      hosts: [utils_1.HostAddress.fromString('localhost:27017')]\n    }, Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries())), Object.fromEntries(connection_string_1.FEATURE_FLAGS.entries()));\n    if (typeof seeds === 'string') {\n      seeds = [utils_1.HostAddress.fromString(seeds)];\n    } else if (!Array.isArray(seeds)) {\n      seeds = [seeds];\n    }\n    var seedlist = [];\n    var _iterator = _createForOfIteratorHelper(seeds),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var seed = _step.value;\n        if (typeof seed === 'string') {\n          seedlist.push(utils_1.HostAddress.fromString(seed));\n        } else if (seed instanceof utils_1.HostAddress) {\n          seedlist.push(seed);\n        } else {\n          // FIXME(NODE-3483): May need to be a MongoParseError\n          throw new error_1.MongoRuntimeError(\"Topology cannot be constructed from \".concat(JSON.stringify(seed)));\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var topologyType = topologyTypeFromOptions(options);\n    var topologyId = globalTopologyCounter++;\n    var selectedHosts = options.srvMaxHosts == null || options.srvMaxHosts === 0 || options.srvMaxHosts >= seedlist.length ? seedlist : (0, utils_1.shuffle)(seedlist, options.srvMaxHosts);\n    var serverDescriptions = new Map();\n    var _iterator2 = _createForOfIteratorHelper(selectedHosts),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var hostAddress = _step2.value;\n        serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    _this[kWaitQueue] = new utils_1.List();\n    _this.s = {\n      // the id of this topology\n      id: topologyId,\n      // passed in options\n      options: options,\n      // initial seedlist of servers to connect to\n      seedlist: seedlist,\n      // initial state\n      state: common_1.STATE_CLOSED,\n      // the topology description\n      description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, undefined, undefined, undefined, options),\n      serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,\n      // a map of server instances to normalized addresses\n      servers: new Map(),\n      credentials: (_options2 = options) === null || _options2 === void 0 ? void 0 : _options2.credentials,\n      clusterTime: undefined,\n      // timer management\n      connectionTimers: new Set(),\n      detectShardedTopology: function detectShardedTopology(ev) {\n        return _this.detectShardedTopology(ev);\n      },\n      detectSrvRecords: function detectSrvRecords(ev) {\n        return _this.detectSrvRecords(ev);\n      }\n    };\n    if (options.srvHost && !options.loadBalanced) {\n      var _options$srvPoller;\n      _this.s.srvPoller = (_options$srvPoller = options.srvPoller) !== null && _options$srvPoller !== void 0 ? _options$srvPoller : new srv_polling_1.SrvPoller({\n        heartbeatFrequencyMS: _this.s.heartbeatFrequencyMS,\n        srvHost: options.srvHost,\n        srvMaxHosts: options.srvMaxHosts,\n        srvServiceName: options.srvServiceName\n      });\n      _this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, _this.s.detectShardedTopology);\n    }\n    return _this;\n  }\n  _createClass(Topology, [{\n    key: \"detectShardedTopology\",\n    value: function detectShardedTopology(event) {\n      var _this$s$srvPoller;\n      var previousType = event.previousDescription.type;\n      var newType = event.newDescription.type;\n      var transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;\n      var srvListeners = (_this$s$srvPoller = this.s.srvPoller) === null || _this$s$srvPoller === void 0 ? void 0 : _this$s$srvPoller.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);\n      var listeningToSrvPolling = !!(srvListeners !== null && srvListeners !== void 0 && srvListeners.includes(this.s.detectSrvRecords));\n      if (transitionToSharded && !listeningToSrvPolling) {\n        var _this$s$srvPoller2, _this$s$srvPoller3;\n        (_this$s$srvPoller2 = this.s.srvPoller) === null || _this$s$srvPoller2 === void 0 || _this$s$srvPoller2.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);\n        (_this$s$srvPoller3 = this.s.srvPoller) === null || _this$s$srvPoller3 === void 0 || _this$s$srvPoller3.start();\n      }\n    }\n  }, {\n    key: \"detectSrvRecords\",\n    value: function detectSrvRecords(ev) {\n      var previousTopologyDescription = this.s.description;\n      this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);\n      if (this.s.description === previousTopologyDescription) {\n        // Nothing changed, so return\n        return;\n      }\n      updateServers(this);\n      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));\n    }\n    /**\n     * @returns A `TopologyDescription` for this topology\n     */\n  }, {\n    key: \"description\",\n    get: function get() {\n      return this.s.description;\n    }\n  }, {\n    key: \"loadBalanced\",\n    get: function get() {\n      return this.s.options.loadBalanced;\n    }\n  }, {\n    key: \"capabilities\",\n    get: function get() {\n      return new ServerCapabilities(this.lastHello());\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(options, callback) {\n      var _options3,\n        _this2 = this,\n        _options$readPreferen;\n      if (typeof options === 'function') callback = options, options = {};\n      options = (_options3 = options) !== null && _options3 !== void 0 ? _options3 : {};\n      if (this.s.state === common_1.STATE_CONNECTED) {\n        if (typeof callback === 'function') {\n          callback();\n        }\n        return;\n      }\n      stateTransition(this, common_1.STATE_CONNECTING);\n      // emit SDAM monitoring events\n      this.emit(Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id));\n      // emit an event for the topology change\n      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown),\n      // initial is always Unknown\n      this.s.description));\n      // connect all known servers, then attempt server selection to connect\n      var serverDescriptions = Array.from(this.s.description.servers.values());\n      this.s.servers = new Map(serverDescriptions.map(function (serverDescription) {\n        return [serverDescription.address, createAndConnectServer(_this2, serverDescription)];\n      }));\n      // In load balancer mode we need to fake a server description getting\n      // emitted from the monitor, since the monitor doesn't exist.\n      if (this.s.options.loadBalanced) {\n        var _iterator3 = _createForOfIteratorHelper(serverDescriptions),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var description = _step3.value;\n            var newDescription = new server_description_1.ServerDescription(description.hostAddress, undefined, {\n              loadBalanced: this.s.options.loadBalanced\n            });\n            this.serverUpdateHandler(newDescription);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      var exitWithError = function exitWithError(error) {\n        return callback ? callback(error) : _this2.emit(Topology.ERROR, error);\n      };\n      var readPreference = (_options$readPreferen = options.readPreference) !== null && _options$readPreferen !== void 0 ? _options$readPreferen : read_preference_1.ReadPreference.primary;\n      this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), options, function (err, server) {\n        var _callback2;\n        if (err) {\n          return _this2.close({\n            force: false\n          }, function () {\n            return exitWithError(err);\n          });\n        }\n        // TODO: NODE-2471\n        var skipPingOnConnect = _this2.s.options[Symbol.for('@@mdb.skipPingOnConnect')] === true;\n        if (!skipPingOnConnect && server && _this2.s.credentials) {\n          server.command((0, utils_1.ns)('admin.$cmd'), {\n            ping: 1\n          }, {}, function (err) {\n            var _callback;\n            if (err) {\n              return exitWithError(err);\n            }\n            stateTransition(_this2, common_1.STATE_CONNECTED);\n            _this2.emit(Topology.OPEN, _this2);\n            _this2.emit(Topology.CONNECT, _this2);\n            (_callback = callback) === null || _callback === void 0 || _callback(undefined, _this2);\n          });\n          return;\n        }\n        stateTransition(_this2, common_1.STATE_CONNECTED);\n        _this2.emit(Topology.OPEN, _this2);\n        _this2.emit(Topology.CONNECT, _this2);\n        (_callback2 = callback) === null || _callback2 === void 0 || _callback2(undefined, _this2);\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(options, callback) {\n      var _options4,\n        _this3 = this;\n      options = (_options4 = options) !== null && _options4 !== void 0 ? _options4 : {\n        force: false\n      };\n      if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {\n        return callback === null || callback === void 0 ? void 0 : callback();\n      }\n      var destroyedServers = Array.from(this.s.servers.values(), function (server) {\n        var _options5;\n        return (0, util_1.promisify)(destroyServer)(server, _this3, {\n          force: !!((_options5 = options) !== null && _options5 !== void 0 && _options5.force)\n        });\n      });\n      Promise.all(destroyedServers).then(function () {\n        _this3.s.servers.clear();\n        stateTransition(_this3, common_1.STATE_CLOSING);\n        drainWaitQueue(_this3[kWaitQueue], new error_1.MongoTopologyClosedError());\n        (0, common_1.drainTimerQueue)(_this3.s.connectionTimers);\n        if (_this3.s.srvPoller) {\n          _this3.s.srvPoller.stop();\n          _this3.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, _this3.s.detectSrvRecords);\n        }\n        _this3.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, _this3.s.detectShardedTopology);\n        stateTransition(_this3, common_1.STATE_CLOSED);\n        // emit an event for close\n        _this3.emit(Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(_this3.s.id));\n      }).finally(function () {\n        return callback === null || callback === void 0 ? void 0 : callback();\n      });\n    }\n    /**\n     * Selects a server according to the selection predicate provided\n     *\n     * @param selector - An optional selector to select servers by, defaults to a random selection within a latency window\n     * @param options - Optional settings related to server selection\n     * @param callback - The callback used to indicate success or failure\n     * @returns An instance of a `Server` meeting the criteria of the predicate provided\n     */\n  }, {\n    key: \"selectServer\",\n    value: function selectServer(selector, options, callback) {\n      var _this4 = this;\n      var serverSelector;\n      if (typeof selector !== 'function') {\n        if (typeof selector === 'string') {\n          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));\n        } else {\n          var readPreference;\n          if (selector instanceof read_preference_1.ReadPreference) {\n            readPreference = selector;\n          } else {\n            read_preference_1.ReadPreference.translate(options);\n            readPreference = options.readPreference || read_preference_1.ReadPreference.primary;\n          }\n          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);\n        }\n      } else {\n        serverSelector = selector;\n      }\n      options = Object.assign({}, {\n        serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS\n      }, options);\n      var isSharded = this.description.type === common_1.TopologyType.Sharded;\n      var session = options.session;\n      var transaction = session && session.transaction;\n      if (isSharded && transaction && transaction.server) {\n        callback(undefined, transaction.server);\n        return;\n      }\n      var waitQueueMember = {\n        serverSelector: serverSelector,\n        transaction: transaction,\n        callback: callback\n      };\n      var serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;\n      if (serverSelectionTimeoutMS) {\n        waitQueueMember.timer = (0, timers_1.setTimeout)(function () {\n          waitQueueMember[kCancelled] = true;\n          waitQueueMember.timer = undefined;\n          var timeoutError = new error_1.MongoServerSelectionError(\"Server selection timed out after \".concat(serverSelectionTimeoutMS, \" ms\"), _this4.description);\n          waitQueueMember.callback(timeoutError);\n        }, serverSelectionTimeoutMS);\n      }\n      this[kWaitQueue].push(waitQueueMember);\n      processWaitQueue(this);\n    }\n    /**\n     * Update the internal TopologyDescription with a ServerDescription\n     *\n     * @param serverDescription - The server to update in the internal list of server descriptions\n     */\n  }, {\n    key: \"serverUpdateHandler\",\n    value: function serverUpdateHandler(serverDescription) {\n      if (!this.s.description.hasServer(serverDescription.address)) {\n        return;\n      }\n      // ignore this server update if its from an outdated topologyVersion\n      if (isStaleServerDescription(this.s.description, serverDescription)) {\n        return;\n      }\n      // these will be used for monitoring events later\n      var previousTopologyDescription = this.s.description;\n      var previousServerDescription = this.s.description.servers.get(serverDescription.address);\n      if (!previousServerDescription) {\n        return;\n      }\n      // Driver Sessions Spec: \"Whenever a driver receives a cluster time from\n      // a server it MUST compare it to the current highest seen cluster time\n      // for the deployment. If the new cluster time is higher than the\n      // highest seen cluster time it MUST become the new highest seen cluster\n      // time. Two cluster times are compared using only the BsonTimestamp\n      // value of the clusterTime embedded field.\"\n      var clusterTime = serverDescription.$clusterTime;\n      if (clusterTime) {\n        (0, common_1._advanceClusterTime)(this, clusterTime);\n      }\n      // If we already know all the information contained in this updated description, then\n      // we don't need to emit SDAM events, but still need to update the description, in order\n      // to keep client-tracked attributes like last update time and round trip time up to date\n      var equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);\n      // first update the TopologyDescription\n      this.s.description = this.s.description.update(serverDescription);\n      if (this.s.description.compatibilityError) {\n        this.emit(Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));\n        return;\n      }\n      // emit monitoring events for this change\n      if (!equalDescriptions) {\n        var newDescription = this.s.description.servers.get(serverDescription.address);\n        if (newDescription) {\n          this.emit(Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));\n        }\n      }\n      // update server list from updated descriptions\n      updateServers(this, serverDescription);\n      // attempt to resolve any outstanding server selection attempts\n      if (this[kWaitQueue].length > 0) {\n        processWaitQueue(this);\n      }\n      if (!equalDescriptions) {\n        this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));\n      }\n    }\n  }, {\n    key: \"auth\",\n    value: function auth(credentials, callback) {\n      if (typeof credentials === 'function') callback = credentials, credentials = undefined;\n      if (typeof callback === 'function') callback(undefined, true);\n    }\n  }, {\n    key: \"clientMetadata\",\n    get: function get() {\n      return this.s.options.metadata;\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.s.state === common_1.STATE_CONNECTED;\n    }\n  }, {\n    key: \"isDestroyed\",\n    value: function isDestroyed() {\n      return this.s.state === common_1.STATE_CLOSED;\n    }\n    // NOTE: There are many places in code where we explicitly check the last hello\n    //       to do feature support detection. This should be done any other way, but for\n    //       now we will just return the first hello seen, which should suffice.\n  }, {\n    key: \"lastHello\",\n    value: function lastHello() {\n      var serverDescriptions = Array.from(this.description.servers.values());\n      if (serverDescriptions.length === 0) return {};\n      var sd = serverDescriptions.filter(function (sd) {\n        return sd.type !== common_1.ServerType.Unknown;\n      })[0];\n      var result = sd || {\n        maxWireVersion: this.description.commonWireVersion\n      };\n      return result;\n    }\n  }, {\n    key: \"commonWireVersion\",\n    get: function get() {\n      return this.description.commonWireVersion;\n    }\n  }, {\n    key: \"logicalSessionTimeoutMinutes\",\n    get: function get() {\n      return this.description.logicalSessionTimeoutMinutes;\n    }\n  }, {\n    key: \"clusterTime\",\n    get: function get() {\n      return this.s.clusterTime;\n    },\n    set: function set(clusterTime) {\n      this.s.clusterTime = clusterTime;\n    }\n  }]);\n  return Topology;\n}(mongo_types_1.TypedEventEmitter);\n/** @event */\nTopology.SERVER_OPENING = constants_1.SERVER_OPENING;\n/** @event */\nTopology.SERVER_CLOSED = constants_1.SERVER_CLOSED;\n/** @event */\nTopology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;\n/** @event */\nTopology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;\n/** @event */\nTopology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;\n/** @event */\nTopology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;\n/** @event */\nTopology.ERROR = constants_1.ERROR;\n/** @event */\nTopology.OPEN = constants_1.OPEN;\n/** @event */\nTopology.CONNECT = constants_1.CONNECT;\n/** @event */\nTopology.CLOSE = constants_1.CLOSE;\n/** @event */\nTopology.TIMEOUT = constants_1.TIMEOUT;\nexports.Topology = Topology;\n/** Destroys a server, and removes all event listeners from the instance */\nfunction destroyServer(server, topology, options, callback) {\n  var _options6;\n  options = (_options6 = options) !== null && _options6 !== void 0 ? _options6 : {\n    force: false\n  };\n  var _iterator4 = _createForOfIteratorHelper(constants_1.LOCAL_SERVER_EVENTS),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var event = _step4.value;\n      server.removeAllListeners(event);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  server.destroy(options, function () {\n    topology.emit(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));\n    var _iterator5 = _createForOfIteratorHelper(constants_1.SERVER_RELAY_EVENTS),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var event = _step5.value;\n        server.removeAllListeners(event);\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n    if (typeof callback === 'function') {\n      callback();\n    }\n  });\n}\n/** Predicts the TopologyType from options */\nfunction topologyTypeFromOptions(options) {\n  if (options !== null && options !== void 0 && options.directConnection) {\n    return common_1.TopologyType.Single;\n  }\n  if (options !== null && options !== void 0 && options.replicaSet) {\n    return common_1.TopologyType.ReplicaSetNoPrimary;\n  }\n  if (options !== null && options !== void 0 && options.loadBalanced) {\n    return common_1.TopologyType.LoadBalanced;\n  }\n  return common_1.TopologyType.Unknown;\n}\n/**\n * Creates new server instances and attempts to connect them\n *\n * @param topology - The topology that this server belongs to\n * @param serverDescription - The description for the server to initialize and connect to\n */\nfunction createAndConnectServer(topology, serverDescription) {\n  topology.emit(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));\n  var server = new server_1.Server(topology, serverDescription, topology.s.options);\n  var _iterator6 = _createForOfIteratorHelper(constants_1.SERVER_RELAY_EVENTS),\n    _step6;\n  try {\n    var _loop = function _loop() {\n      var event = _step6.value;\n      server.on(event, function (e) {\n        return topology.emit(event, e);\n      });\n    };\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  server.on(server_1.Server.DESCRIPTION_RECEIVED, function (description) {\n    return topology.serverUpdateHandler(description);\n  });\n  server.connect();\n  return server;\n}\n/**\n * @param topology - Topology to update.\n * @param incomingServerDescription - New server description.\n */\nfunction updateServers(topology, incomingServerDescription) {\n  // update the internal server's description\n  if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {\n    var server = topology.s.servers.get(incomingServerDescription.address);\n    if (server) {\n      server.s.description = incomingServerDescription;\n      if (incomingServerDescription.error instanceof error_1.MongoError && incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.ResetPool)) {\n        var interruptInUseConnections = incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);\n        server.pool.clear({\n          interruptInUseConnections: interruptInUseConnections\n        });\n      } else if (incomingServerDescription.error == null) {\n        var newTopologyType = topology.s.description.type;\n        var shouldMarkPoolReady = incomingServerDescription.isDataBearing || incomingServerDescription.type !== common_1.ServerType.Unknown && newTopologyType === common_1.TopologyType.Single;\n        if (shouldMarkPoolReady) {\n          server.pool.ready();\n        }\n      }\n    }\n  }\n  // add new servers for all descriptions we currently don't know about locally\n  var _iterator7 = _createForOfIteratorHelper(topology.description.servers.values()),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var serverDescription = _step7.value;\n      if (!topology.s.servers.has(serverDescription.address)) {\n        var _server = createAndConnectServer(topology, serverDescription);\n        topology.s.servers.set(serverDescription.address, _server);\n      }\n    }\n    // for all servers no longer known, remove their descriptions and destroy their instances\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  var _iterator8 = _createForOfIteratorHelper(topology.s.servers),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var entry = _step8.value;\n      var serverAddress = entry[0];\n      if (topology.description.hasServer(serverAddress)) {\n        continue;\n      }\n      if (!topology.s.servers.has(serverAddress)) {\n        continue;\n      }\n      var _server2 = topology.s.servers.get(serverAddress);\n      topology.s.servers.delete(serverAddress);\n      // prepare server for garbage collection\n      if (_server2) {\n        destroyServer(_server2, topology);\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n}\nfunction drainWaitQueue(queue, err) {\n  while (queue.length) {\n    var waitQueueMember = queue.shift();\n    if (!waitQueueMember) {\n      continue;\n    }\n    if (waitQueueMember.timer) {\n      (0, timers_1.clearTimeout)(waitQueueMember.timer);\n    }\n    if (!waitQueueMember[kCancelled]) {\n      waitQueueMember.callback(err);\n    }\n  }\n}\nfunction processWaitQueue(topology) {\n  if (topology.s.state === common_1.STATE_CLOSED) {\n    drainWaitQueue(topology[kWaitQueue], new error_1.MongoTopologyClosedError());\n    return;\n  }\n  var isSharded = topology.description.type === common_1.TopologyType.Sharded;\n  var serverDescriptions = Array.from(topology.description.servers.values());\n  var membersToProcess = topology[kWaitQueue].length;\n  for (var i = 0; i < membersToProcess; ++i) {\n    var waitQueueMember = topology[kWaitQueue].shift();\n    if (!waitQueueMember) {\n      continue;\n    }\n    if (waitQueueMember[kCancelled]) {\n      continue;\n    }\n    var selectedDescriptions = void 0;\n    try {\n      var serverSelector = waitQueueMember.serverSelector;\n      selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;\n    } catch (e) {\n      if (waitQueueMember.timer) {\n        (0, timers_1.clearTimeout)(waitQueueMember.timer);\n      }\n      waitQueueMember.callback(e);\n      continue;\n    }\n    var selectedServer = void 0;\n    if (selectedDescriptions.length === 0) {\n      topology[kWaitQueue].push(waitQueueMember);\n      continue;\n    } else if (selectedDescriptions.length === 1) {\n      selectedServer = topology.s.servers.get(selectedDescriptions[0].address);\n    } else {\n      var descriptions = (0, utils_1.shuffle)(selectedDescriptions, 2);\n      var server1 = topology.s.servers.get(descriptions[0].address);\n      var server2 = topology.s.servers.get(descriptions[1].address);\n      selectedServer = server1 && server2 && server1.s.operationCount < server2.s.operationCount ? server1 : server2;\n    }\n    if (!selectedServer) {\n      waitQueueMember.callback(new error_1.MongoServerSelectionError('server selection returned a server description but the server was not found in the topology', topology.description));\n      return;\n    }\n    var transaction = waitQueueMember.transaction;\n    if (isSharded && transaction && transaction.isActive && selectedServer) {\n      transaction.pinServer(selectedServer);\n    }\n    if (waitQueueMember.timer) {\n      (0, timers_1.clearTimeout)(waitQueueMember.timer);\n    }\n    waitQueueMember.callback(undefined, selectedServer);\n  }\n  if (topology[kWaitQueue].length > 0) {\n    // ensure all server monitors attempt monitoring soon\n    var _iterator9 = _createForOfIteratorHelper(topology.s.servers),\n      _step9;\n    try {\n      var _loop2 = function _loop2() {\n        var _step9$value = _slicedToArray(_step9.value, 2),\n          server = _step9$value[1];\n        process.nextTick(function scheduleServerCheck() {\n          return server.requestCheck();\n        });\n      };\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        _loop2();\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n  }\n}\nfunction isStaleServerDescription(topologyDescription, incomingServerDescription) {\n  var currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);\n  var currentTopologyVersion = currentServerDescription === null || currentServerDescription === void 0 ? void 0 : currentServerDescription.topologyVersion;\n  return (0, server_description_1.compareTopologyVersion)(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;\n}\n/** @public */\nvar ServerCapabilities = /*#__PURE__*/function () {\n  function ServerCapabilities(hello) {\n    _classCallCheck(this, ServerCapabilities);\n    this.minWireVersion = hello.minWireVersion || 0;\n    this.maxWireVersion = hello.maxWireVersion || 0;\n  }\n  _createClass(ServerCapabilities, [{\n    key: \"hasAggregationCursor\",\n    get: function get() {\n      return this.maxWireVersion >= 1;\n    }\n  }, {\n    key: \"hasWriteCommands\",\n    get: function get() {\n      return this.maxWireVersion >= 2;\n    }\n  }, {\n    key: \"hasTextSearch\",\n    get: function get() {\n      return this.minWireVersion >= 0;\n    }\n  }, {\n    key: \"hasAuthCommands\",\n    get: function get() {\n      return this.maxWireVersion >= 1;\n    }\n  }, {\n    key: \"hasListCollectionsCommand\",\n    get: function get() {\n      return this.maxWireVersion >= 3;\n    }\n  }, {\n    key: \"hasListIndexesCommand\",\n    get: function get() {\n      return this.maxWireVersion >= 3;\n    }\n  }, {\n    key: \"supportsSnapshotReads\",\n    get: function get() {\n      return this.maxWireVersion >= 13;\n    }\n  }, {\n    key: \"commandsTakeWriteConcern\",\n    get: function get() {\n      return this.maxWireVersion >= 5;\n    }\n  }, {\n    key: \"commandsTakeCollation\",\n    get: function get() {\n      return this.maxWireVersion >= 5;\n    }\n  }]);\n  return ServerCapabilities;\n}();\nexports.ServerCapabilities = ServerCapabilities;","map":{"version":3,"names":["timers_1","require","util_1","connection_string_1","constants_1","error_1","mongo_types_1","read_preference_1","utils_1","common_1","events_1","server_1","server_description_1","server_selection_1","srv_polling_1","topology_description_1","globalTopologyCounter","stateTransition","makeStateMachine","_ref","_defineProperty","STATE_CLOSED","STATE_CONNECTING","STATE_CLOSING","STATE_CONNECTED","kCancelled","Symbol","kWaitQueue","Topology","_mongo_types_1$TypedE","_inherits","_super","_createSuper","client","seeds","options","_options","_options2","_this","_classCallCheck","call","selectServerAsync","promisify","selector","callback","selectServer","_objectSpread","hosts","HostAddress","fromString","Object","fromEntries","DEFAULT_OPTIONS","entries","FEATURE_FLAGS","Array","isArray","seedlist","_iterator","_createForOfIteratorHelper","_step","s","n","done","seed","value","push","MongoRuntimeError","concat","JSON","stringify","err","e","f","topologyType","topologyTypeFromOptions","topologyId","selectedHosts","srvMaxHosts","length","shuffle","serverDescriptions","Map","_iterator2","_step2","hostAddress","set","toString","ServerDescription","List","id","state","description","TopologyDescription","replicaSet","undefined","serverSelectionTimeoutMS","heartbeatFrequencyMS","minHeartbeatFrequencyMS","servers","credentials","clusterTime","connectionTimers","Set","detectShardedTopology","ev","detectSrvRecords","srvHost","loadBalanced","_options$srvPoller","srvPoller","SrvPoller","srvServiceName","on","TOPOLOGY_DESCRIPTION_CHANGED","_createClass","key","event","_this$s$srvPoller","previousType","previousDescription","type","newType","newDescription","transitionToSharded","TopologyType","Sharded","srvListeners","listeners","SRV_RECORD_DISCOVERY","listeningToSrvPolling","includes","_this$s$srvPoller2","_this$s$srvPoller3","start","previousTopologyDescription","updateFromSrvPollingEvent","updateServers","emit","TopologyDescriptionChangedEvent","get","ServerCapabilities","lastHello","connect","_options3","_this2","_options$readPreferen","TOPOLOGY_OPENING","TopologyOpeningEvent","Unknown","from","values","map","serverDescription","address","createAndConnectServer","_iterator3","_step3","serverUpdateHandler","exitWithError","error","ERROR","readPreference","ReadPreference","primary","readPreferenceServerSelector","server","_callback2","close","force","skipPingOnConnect","for","command","ns","ping","_callback","OPEN","CONNECT","_options4","_this3","destroyedServers","_options5","destroyServer","Promise","all","then","clear","drainWaitQueue","MongoTopologyClosedError","drainTimerQueue","stop","removeListener","TOPOLOGY_CLOSED","TopologyClosedEvent","finally","_this4","serverSelector","translate","assign","isSharded","session","transaction","waitQueueMember","timer","setTimeout","timeoutError","MongoServerSelectionError","processWaitQueue","hasServer","isStaleServerDescription","previousServerDescription","$clusterTime","_advanceClusterTime","equalDescriptions","equals","update","compatibilityError","MongoCompatibilityError","SERVER_DESCRIPTION_CHANGED","ServerDescriptionChangedEvent","auth","metadata","isConnected","isDestroyed","sd","filter","ServerType","result","maxWireVersion","commonWireVersion","logicalSessionTimeoutMinutes","TypedEventEmitter","SERVER_OPENING","SERVER_CLOSED","CLOSE","TIMEOUT","exports","topology","_options6","_iterator4","LOCAL_SERVER_EVENTS","_step4","removeAllListeners","destroy","ServerClosedEvent","_iterator5","SERVER_RELAY_EVENTS","_step5","directConnection","Single","ReplicaSetNoPrimary","LoadBalanced","ServerOpeningEvent","Server","_iterator6","_step6","_loop","DESCRIPTION_RECEIVED","incomingServerDescription","has","MongoError","hasErrorLabel","MongoErrorLabel","ResetPool","interruptInUseConnections","InterruptInUseConnections","pool","newTopologyType","shouldMarkPoolReady","isDataBearing","ready","_iterator7","_step7","_iterator8","_step8","entry","serverAddress","delete","queue","shift","clearTimeout","membersToProcess","i","selectedDescriptions","selectedServer","descriptions","server1","server2","operationCount","isActive","pinServer","_iterator9","_step9","_loop2","_step9$value","_slicedToArray","process","nextTick","scheduleServerCheck","requestCheck","topologyDescription","currentServerDescription","currentTopologyVersion","topologyVersion","compareTopologyVersion","hello","minWireVersion"],"sources":["C:\\Users\\raphm\\Documents\\Projects\\youtube-transcript\\youtube-transcript\\node_modules\\mongodb\\src\\sdam\\topology.ts"],"sourcesContent":["import { clearTimeout, setTimeout } from 'timers';\nimport { promisify } from 'util';\n\nimport type { BSONSerializeOptions, Document } from '../bson';\nimport type { MongoCredentials } from '../cmap/auth/mongo_credentials';\nimport type { ConnectionEvents, DestroyOptions } from '../cmap/connection';\nimport type { CloseOptions, ConnectionPoolEvents } from '../cmap/connection_pool';\nimport type { ClientMetadata } from '../cmap/handshake/client_metadata';\nimport { DEFAULT_OPTIONS, FEATURE_FLAGS } from '../connection_string';\nimport {\n  CLOSE,\n  CONNECT,\n  ERROR,\n  LOCAL_SERVER_EVENTS,\n  OPEN,\n  SERVER_CLOSED,\n  SERVER_DESCRIPTION_CHANGED,\n  SERVER_OPENING,\n  SERVER_RELAY_EVENTS,\n  TIMEOUT,\n  TOPOLOGY_CLOSED,\n  TOPOLOGY_DESCRIPTION_CHANGED,\n  TOPOLOGY_OPENING\n} from '../constants';\nimport {\n  MongoCompatibilityError,\n  type MongoDriverError,\n  MongoError,\n  MongoErrorLabel,\n  MongoRuntimeError,\n  MongoServerSelectionError,\n  MongoTopologyClosedError\n} from '../error';\nimport type { MongoClient, ServerApi } from '../mongo_client';\nimport { TypedEventEmitter } from '../mongo_types';\nimport { ReadPreference, type ReadPreferenceLike } from '../read_preference';\nimport type { ClientSession } from '../sessions';\nimport type { Transaction } from '../transactions';\nimport {\n  type Callback,\n  type EventEmitterWithState,\n  HostAddress,\n  List,\n  makeStateMachine,\n  ns,\n  shuffle\n} from '../utils';\nimport {\n  _advanceClusterTime,\n  type ClusterTime,\n  drainTimerQueue,\n  ServerType,\n  STATE_CLOSED,\n  STATE_CLOSING,\n  STATE_CONNECTED,\n  STATE_CONNECTING,\n  type TimerQueue,\n  TopologyType\n} from './common';\nimport {\n  ServerClosedEvent,\n  ServerDescriptionChangedEvent,\n  ServerOpeningEvent,\n  TopologyClosedEvent,\n  TopologyDescriptionChangedEvent,\n  TopologyOpeningEvent\n} from './events';\nimport { Server, type ServerEvents, type ServerOptions } from './server';\nimport { compareTopologyVersion, ServerDescription } from './server_description';\nimport { readPreferenceServerSelector, type ServerSelector } from './server_selection';\nimport { SrvPoller, type SrvPollingEvent } from './srv_polling';\nimport { TopologyDescription } from './topology_description';\n\n// Global state\nlet globalTopologyCounter = 0;\n\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],\n  [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],\n  [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]\n});\n\n/** @internal */\nconst kCancelled = Symbol('cancelled');\n/** @internal */\nconst kWaitQueue = Symbol('waitQueue');\n\n/** @internal */\nexport type ServerSelectionCallback = Callback<Server>;\n\n/** @internal */\nexport interface ServerSelectionRequest {\n  serverSelector: ServerSelector;\n  transaction?: Transaction;\n  callback: ServerSelectionCallback;\n  timer?: NodeJS.Timeout;\n  [kCancelled]?: boolean;\n}\n\n/** @internal */\nexport interface TopologyPrivate {\n  /** the id of this topology */\n  id: number;\n  /** passed in options */\n  options: TopologyOptions;\n  /** initial seedlist of servers to connect to */\n  seedlist: HostAddress[];\n  /** initial state */\n  state: string;\n  /** the topology description */\n  description: TopologyDescription;\n  serverSelectionTimeoutMS: number;\n  heartbeatFrequencyMS: number;\n  minHeartbeatFrequencyMS: number;\n  /** A map of server instances to normalized addresses */\n  servers: Map<string, Server>;\n  credentials?: MongoCredentials;\n  clusterTime?: ClusterTime;\n  /** timers created for the initial connect to a server */\n  connectionTimers: TimerQueue;\n\n  /** related to srv polling */\n  srvPoller?: SrvPoller;\n  detectShardedTopology: (event: TopologyDescriptionChangedEvent) => void;\n  detectSrvRecords: (event: SrvPollingEvent) => void;\n}\n\n/** @internal */\nexport interface TopologyOptions extends BSONSerializeOptions, ServerOptions {\n  srvMaxHosts: number;\n  srvServiceName: string;\n  hosts: HostAddress[];\n  retryWrites: boolean;\n  retryReads: boolean;\n  /** How long to block for server selection before throwing an error */\n  serverSelectionTimeoutMS: number;\n  /** The name of the replica set to connect to */\n  replicaSet?: string;\n  srvHost?: string;\n  srvPoller?: SrvPoller;\n  /** Indicates that a client should directly connect to a node without attempting to discover its topology type */\n  directConnection: boolean;\n  loadBalanced: boolean;\n  metadata: ClientMetadata;\n  /** MongoDB server API version */\n  serverApi?: ServerApi;\n  [featureFlag: symbol]: any;\n}\n\n/** @public */\nexport interface ConnectOptions {\n  readPreference?: ReadPreference;\n}\n\n/** @public */\nexport interface SelectServerOptions {\n  readPreference?: ReadPreferenceLike;\n  /** How long to block for server selection before throwing an error */\n  serverSelectionTimeoutMS?: number;\n  session?: ClientSession;\n}\n\n/** @public */\nexport type TopologyEvents = {\n  /** Top level MongoClient doesn't emit this so it is marked: @internal */\n  connect(topology: Topology): void;\n  serverOpening(event: ServerOpeningEvent): void;\n  serverClosed(event: ServerClosedEvent): void;\n  serverDescriptionChanged(event: ServerDescriptionChangedEvent): void;\n  topologyClosed(event: TopologyClosedEvent): void;\n  topologyOpening(event: TopologyOpeningEvent): void;\n  topologyDescriptionChanged(event: TopologyDescriptionChangedEvent): void;\n  error(error: Error): void;\n  /** @internal */\n  open(topology: Topology): void;\n  close(): void;\n  timeout(): void;\n} & Omit<ServerEvents, 'connect'> &\n  ConnectionPoolEvents &\n  ConnectionEvents &\n  EventEmitterWithState;\n/**\n * A container of server instances representing a connection to a MongoDB topology.\n * @internal\n */\nexport class Topology extends TypedEventEmitter<TopologyEvents> {\n  /** @internal */\n  s: TopologyPrivate;\n  /** @internal */\n  [kWaitQueue]: List<ServerSelectionRequest>;\n  /** @internal */\n  hello?: Document;\n  /** @internal */\n  _type?: string;\n\n  client!: MongoClient;\n\n  /** @event */\n  static readonly SERVER_OPENING = SERVER_OPENING;\n  /** @event */\n  static readonly SERVER_CLOSED = SERVER_CLOSED;\n  /** @event */\n  static readonly SERVER_DESCRIPTION_CHANGED = SERVER_DESCRIPTION_CHANGED;\n  /** @event */\n  static readonly TOPOLOGY_OPENING = TOPOLOGY_OPENING;\n  /** @event */\n  static readonly TOPOLOGY_CLOSED = TOPOLOGY_CLOSED;\n  /** @event */\n  static readonly TOPOLOGY_DESCRIPTION_CHANGED = TOPOLOGY_DESCRIPTION_CHANGED;\n  /** @event */\n  static readonly ERROR = ERROR;\n  /** @event */\n  static readonly OPEN = OPEN;\n  /** @event */\n  static readonly CONNECT = CONNECT;\n  /** @event */\n  static readonly CLOSE = CLOSE;\n  /** @event */\n  static readonly TIMEOUT = TIMEOUT;\n\n  selectServerAsync: (\n    selector: string | ReadPreference | ServerSelector,\n    options: SelectServerOptions\n  ) => Promise<Server>;\n\n  /**\n   * @param seedlist - a list of HostAddress instances to connect to\n   */\n  constructor(\n    client: MongoClient,\n    seeds: string | string[] | HostAddress | HostAddress[],\n    options: TopologyOptions\n  ) {\n    super();\n\n    this.client = client;\n    this.selectServerAsync = promisify(\n      (\n        selector: string | ReadPreference | ServerSelector,\n        options: SelectServerOptions,\n        callback: (e: Error, r: Server) => void\n      ) => this.selectServer(selector, options, callback as any)\n    );\n\n    // Options should only be undefined in tests, MongoClient will always have defined options\n    options = options ?? {\n      hosts: [HostAddress.fromString('localhost:27017')],\n      ...Object.fromEntries(DEFAULT_OPTIONS.entries()),\n      ...Object.fromEntries(FEATURE_FLAGS.entries())\n    };\n\n    if (typeof seeds === 'string') {\n      seeds = [HostAddress.fromString(seeds)];\n    } else if (!Array.isArray(seeds)) {\n      seeds = [seeds];\n    }\n\n    const seedlist: HostAddress[] = [];\n    for (const seed of seeds) {\n      if (typeof seed === 'string') {\n        seedlist.push(HostAddress.fromString(seed));\n      } else if (seed instanceof HostAddress) {\n        seedlist.push(seed);\n      } else {\n        // FIXME(NODE-3483): May need to be a MongoParseError\n        throw new MongoRuntimeError(`Topology cannot be constructed from ${JSON.stringify(seed)}`);\n      }\n    }\n\n    const topologyType = topologyTypeFromOptions(options);\n    const topologyId = globalTopologyCounter++;\n\n    const selectedHosts =\n      options.srvMaxHosts == null ||\n      options.srvMaxHosts === 0 ||\n      options.srvMaxHosts >= seedlist.length\n        ? seedlist\n        : shuffle(seedlist, options.srvMaxHosts);\n\n    const serverDescriptions = new Map();\n    for (const hostAddress of selectedHosts) {\n      serverDescriptions.set(hostAddress.toString(), new ServerDescription(hostAddress));\n    }\n\n    this[kWaitQueue] = new List();\n    this.s = {\n      // the id of this topology\n      id: topologyId,\n      // passed in options\n      options,\n      // initial seedlist of servers to connect to\n      seedlist,\n      // initial state\n      state: STATE_CLOSED,\n      // the topology description\n      description: new TopologyDescription(\n        topologyType,\n        serverDescriptions,\n        options.replicaSet,\n        undefined,\n        undefined,\n        undefined,\n        options\n      ),\n      serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,\n      // a map of server instances to normalized addresses\n      servers: new Map(),\n      credentials: options?.credentials,\n      clusterTime: undefined,\n\n      // timer management\n      connectionTimers: new Set<NodeJS.Timeout>(),\n      detectShardedTopology: ev => this.detectShardedTopology(ev),\n      detectSrvRecords: ev => this.detectSrvRecords(ev)\n    };\n\n    if (options.srvHost && !options.loadBalanced) {\n      this.s.srvPoller =\n        options.srvPoller ??\n        new SrvPoller({\n          heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,\n          srvHost: options.srvHost,\n          srvMaxHosts: options.srvMaxHosts,\n          srvServiceName: options.srvServiceName\n        });\n\n      this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);\n    }\n  }\n\n  private detectShardedTopology(event: TopologyDescriptionChangedEvent) {\n    const previousType = event.previousDescription.type;\n    const newType = event.newDescription.type;\n\n    const transitionToSharded =\n      previousType !== TopologyType.Sharded && newType === TopologyType.Sharded;\n    const srvListeners = this.s.srvPoller?.listeners(SrvPoller.SRV_RECORD_DISCOVERY);\n    const listeningToSrvPolling = !!srvListeners?.includes(this.s.detectSrvRecords);\n\n    if (transitionToSharded && !listeningToSrvPolling) {\n      this.s.srvPoller?.on(SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);\n      this.s.srvPoller?.start();\n    }\n  }\n\n  private detectSrvRecords(ev: SrvPollingEvent) {\n    const previousTopologyDescription = this.s.description;\n    this.s.description = this.s.description.updateFromSrvPollingEvent(\n      ev,\n      this.s.options.srvMaxHosts\n    );\n    if (this.s.description === previousTopologyDescription) {\n      // Nothing changed, so return\n      return;\n    }\n\n    updateServers(this);\n\n    this.emit(\n      Topology.TOPOLOGY_DESCRIPTION_CHANGED,\n      new TopologyDescriptionChangedEvent(\n        this.s.id,\n        previousTopologyDescription,\n        this.s.description\n      )\n    );\n  }\n\n  /**\n   * @returns A `TopologyDescription` for this topology\n   */\n  get description(): TopologyDescription {\n    return this.s.description;\n  }\n\n  get loadBalanced(): boolean {\n    return this.s.options.loadBalanced;\n  }\n\n  get capabilities(): ServerCapabilities {\n    return new ServerCapabilities(this.lastHello());\n  }\n\n  /** Initiate server connect */\n  connect(callback: Callback): void;\n  connect(options: ConnectOptions, callback: Callback): void;\n  connect(options?: ConnectOptions | Callback, callback?: Callback): void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n    if (this.s.state === STATE_CONNECTED) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    stateTransition(this, STATE_CONNECTING);\n\n    // emit SDAM monitoring events\n    this.emit(Topology.TOPOLOGY_OPENING, new TopologyOpeningEvent(this.s.id));\n\n    // emit an event for the topology change\n    this.emit(\n      Topology.TOPOLOGY_DESCRIPTION_CHANGED,\n      new TopologyDescriptionChangedEvent(\n        this.s.id,\n        new TopologyDescription(TopologyType.Unknown), // initial is always Unknown\n        this.s.description\n      )\n    );\n\n    // connect all known servers, then attempt server selection to connect\n    const serverDescriptions = Array.from(this.s.description.servers.values());\n    this.s.servers = new Map(\n      serverDescriptions.map(serverDescription => [\n        serverDescription.address,\n        createAndConnectServer(this, serverDescription)\n      ])\n    );\n\n    // In load balancer mode we need to fake a server description getting\n    // emitted from the monitor, since the monitor doesn't exist.\n    if (this.s.options.loadBalanced) {\n      for (const description of serverDescriptions) {\n        const newDescription = new ServerDescription(description.hostAddress, undefined, {\n          loadBalanced: this.s.options.loadBalanced\n        });\n        this.serverUpdateHandler(newDescription);\n      }\n    }\n\n    const exitWithError = (error: Error) =>\n      callback ? callback(error) : this.emit(Topology.ERROR, error);\n\n    const readPreference = options.readPreference ?? ReadPreference.primary;\n    this.selectServer(readPreferenceServerSelector(readPreference), options, (err, server) => {\n      if (err) {\n        return this.close({ force: false }, () => exitWithError(err));\n      }\n\n      // TODO: NODE-2471\n      const skipPingOnConnect = this.s.options[Symbol.for('@@mdb.skipPingOnConnect')] === true;\n      if (!skipPingOnConnect && server && this.s.credentials) {\n        server.command(ns('admin.$cmd'), { ping: 1 }, {}, err => {\n          if (err) {\n            return exitWithError(err);\n          }\n\n          stateTransition(this, STATE_CONNECTED);\n          this.emit(Topology.OPEN, this);\n          this.emit(Topology.CONNECT, this);\n\n          callback?.(undefined, this);\n        });\n\n        return;\n      }\n\n      stateTransition(this, STATE_CONNECTED);\n      this.emit(Topology.OPEN, this);\n      this.emit(Topology.CONNECT, this);\n\n      callback?.(undefined, this);\n    });\n  }\n\n  /** Close this topology */\n  close(options: CloseOptions): void;\n  close(options: CloseOptions, callback: Callback): void;\n  close(options?: CloseOptions, callback?: Callback): void {\n    options = options ?? { force: false };\n\n    if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {\n      return callback?.();\n    }\n\n    const destroyedServers = Array.from(this.s.servers.values(), server => {\n      return promisify(destroyServer)(server, this, { force: !!options?.force });\n    });\n\n    Promise.all(destroyedServers)\n      .then(() => {\n        this.s.servers.clear();\n\n        stateTransition(this, STATE_CLOSING);\n\n        drainWaitQueue(this[kWaitQueue], new MongoTopologyClosedError());\n        drainTimerQueue(this.s.connectionTimers);\n\n        if (this.s.srvPoller) {\n          this.s.srvPoller.stop();\n          this.s.srvPoller.removeListener(SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);\n        }\n\n        this.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);\n\n        stateTransition(this, STATE_CLOSED);\n\n        // emit an event for close\n        this.emit(Topology.TOPOLOGY_CLOSED, new TopologyClosedEvent(this.s.id));\n      })\n      .finally(() => callback?.());\n  }\n\n  /**\n   * Selects a server according to the selection predicate provided\n   *\n   * @param selector - An optional selector to select servers by, defaults to a random selection within a latency window\n   * @param options - Optional settings related to server selection\n   * @param callback - The callback used to indicate success or failure\n   * @returns An instance of a `Server` meeting the criteria of the predicate provided\n   */\n  selectServer(\n    selector: string | ReadPreference | ServerSelector,\n    options: SelectServerOptions,\n    callback: Callback<Server>\n  ): void {\n    let serverSelector;\n    if (typeof selector !== 'function') {\n      if (typeof selector === 'string') {\n        serverSelector = readPreferenceServerSelector(ReadPreference.fromString(selector));\n      } else {\n        let readPreference;\n        if (selector instanceof ReadPreference) {\n          readPreference = selector;\n        } else {\n          ReadPreference.translate(options);\n          readPreference = options.readPreference || ReadPreference.primary;\n        }\n\n        serverSelector = readPreferenceServerSelector(readPreference as ReadPreference);\n      }\n    } else {\n      serverSelector = selector;\n    }\n\n    options = Object.assign(\n      {},\n      { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS },\n      options\n    );\n\n    const isSharded = this.description.type === TopologyType.Sharded;\n    const session = options.session;\n    const transaction = session && session.transaction;\n\n    if (isSharded && transaction && transaction.server) {\n      callback(undefined, transaction.server);\n      return;\n    }\n\n    const waitQueueMember: ServerSelectionRequest = {\n      serverSelector,\n      transaction,\n      callback\n    };\n\n    const serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;\n    if (serverSelectionTimeoutMS) {\n      waitQueueMember.timer = setTimeout(() => {\n        waitQueueMember[kCancelled] = true;\n        waitQueueMember.timer = undefined;\n        const timeoutError = new MongoServerSelectionError(\n          `Server selection timed out after ${serverSelectionTimeoutMS} ms`,\n          this.description\n        );\n\n        waitQueueMember.callback(timeoutError);\n      }, serverSelectionTimeoutMS);\n    }\n\n    this[kWaitQueue].push(waitQueueMember);\n    processWaitQueue(this);\n  }\n\n  /**\n   * Update the internal TopologyDescription with a ServerDescription\n   *\n   * @param serverDescription - The server to update in the internal list of server descriptions\n   */\n  serverUpdateHandler(serverDescription: ServerDescription): void {\n    if (!this.s.description.hasServer(serverDescription.address)) {\n      return;\n    }\n\n    // ignore this server update if its from an outdated topologyVersion\n    if (isStaleServerDescription(this.s.description, serverDescription)) {\n      return;\n    }\n\n    // these will be used for monitoring events later\n    const previousTopologyDescription = this.s.description;\n    const previousServerDescription = this.s.description.servers.get(serverDescription.address);\n    if (!previousServerDescription) {\n      return;\n    }\n\n    // Driver Sessions Spec: \"Whenever a driver receives a cluster time from\n    // a server it MUST compare it to the current highest seen cluster time\n    // for the deployment. If the new cluster time is higher than the\n    // highest seen cluster time it MUST become the new highest seen cluster\n    // time. Two cluster times are compared using only the BsonTimestamp\n    // value of the clusterTime embedded field.\"\n    const clusterTime = serverDescription.$clusterTime;\n    if (clusterTime) {\n      _advanceClusterTime(this, clusterTime);\n    }\n\n    // If we already know all the information contained in this updated description, then\n    // we don't need to emit SDAM events, but still need to update the description, in order\n    // to keep client-tracked attributes like last update time and round trip time up to date\n    const equalDescriptions =\n      previousServerDescription && previousServerDescription.equals(serverDescription);\n\n    // first update the TopologyDescription\n    this.s.description = this.s.description.update(serverDescription);\n    if (this.s.description.compatibilityError) {\n      this.emit(Topology.ERROR, new MongoCompatibilityError(this.s.description.compatibilityError));\n      return;\n    }\n\n    // emit monitoring events for this change\n    if (!equalDescriptions) {\n      const newDescription = this.s.description.servers.get(serverDescription.address);\n      if (newDescription) {\n        this.emit(\n          Topology.SERVER_DESCRIPTION_CHANGED,\n          new ServerDescriptionChangedEvent(\n            this.s.id,\n            serverDescription.address,\n            previousServerDescription,\n            newDescription\n          )\n        );\n      }\n    }\n\n    // update server list from updated descriptions\n    updateServers(this, serverDescription);\n\n    // attempt to resolve any outstanding server selection attempts\n    if (this[kWaitQueue].length > 0) {\n      processWaitQueue(this);\n    }\n\n    if (!equalDescriptions) {\n      this.emit(\n        Topology.TOPOLOGY_DESCRIPTION_CHANGED,\n        new TopologyDescriptionChangedEvent(\n          this.s.id,\n          previousTopologyDescription,\n          this.s.description\n        )\n      );\n    }\n  }\n\n  auth(credentials?: MongoCredentials, callback?: Callback): void {\n    if (typeof credentials === 'function') (callback = credentials), (credentials = undefined);\n    if (typeof callback === 'function') callback(undefined, true);\n  }\n\n  get clientMetadata(): ClientMetadata {\n    return this.s.options.metadata;\n  }\n\n  isConnected(): boolean {\n    return this.s.state === STATE_CONNECTED;\n  }\n\n  isDestroyed(): boolean {\n    return this.s.state === STATE_CLOSED;\n  }\n\n  // NOTE: There are many places in code where we explicitly check the last hello\n  //       to do feature support detection. This should be done any other way, but for\n  //       now we will just return the first hello seen, which should suffice.\n  lastHello(): Document {\n    const serverDescriptions = Array.from(this.description.servers.values());\n    if (serverDescriptions.length === 0) return {};\n    const sd = serverDescriptions.filter(\n      (sd: ServerDescription) => sd.type !== ServerType.Unknown\n    )[0];\n\n    const result = sd || { maxWireVersion: this.description.commonWireVersion };\n    return result;\n  }\n\n  get commonWireVersion(): number | undefined {\n    return this.description.commonWireVersion;\n  }\n\n  get logicalSessionTimeoutMinutes(): number | null {\n    return this.description.logicalSessionTimeoutMinutes;\n  }\n\n  get clusterTime(): ClusterTime | undefined {\n    return this.s.clusterTime;\n  }\n\n  set clusterTime(clusterTime: ClusterTime | undefined) {\n    this.s.clusterTime = clusterTime;\n  }\n}\n\n/** Destroys a server, and removes all event listeners from the instance */\nfunction destroyServer(\n  server: Server,\n  topology: Topology,\n  options?: DestroyOptions,\n  callback?: Callback\n) {\n  options = options ?? { force: false };\n  for (const event of LOCAL_SERVER_EVENTS) {\n    server.removeAllListeners(event);\n  }\n\n  server.destroy(options, () => {\n    topology.emit(\n      Topology.SERVER_CLOSED,\n      new ServerClosedEvent(topology.s.id, server.description.address)\n    );\n\n    for (const event of SERVER_RELAY_EVENTS) {\n      server.removeAllListeners(event);\n    }\n    if (typeof callback === 'function') {\n      callback();\n    }\n  });\n}\n\n/** Predicts the TopologyType from options */\nfunction topologyTypeFromOptions(options?: TopologyOptions) {\n  if (options?.directConnection) {\n    return TopologyType.Single;\n  }\n\n  if (options?.replicaSet) {\n    return TopologyType.ReplicaSetNoPrimary;\n  }\n\n  if (options?.loadBalanced) {\n    return TopologyType.LoadBalanced;\n  }\n\n  return TopologyType.Unknown;\n}\n\n/**\n * Creates new server instances and attempts to connect them\n *\n * @param topology - The topology that this server belongs to\n * @param serverDescription - The description for the server to initialize and connect to\n */\nfunction createAndConnectServer(topology: Topology, serverDescription: ServerDescription) {\n  topology.emit(\n    Topology.SERVER_OPENING,\n    new ServerOpeningEvent(topology.s.id, serverDescription.address)\n  );\n\n  const server = new Server(topology, serverDescription, topology.s.options);\n  for (const event of SERVER_RELAY_EVENTS) {\n    server.on(event, (e: any) => topology.emit(event, e));\n  }\n\n  server.on(Server.DESCRIPTION_RECEIVED, description => topology.serverUpdateHandler(description));\n\n  server.connect();\n  return server;\n}\n\n/**\n * @param topology - Topology to update.\n * @param incomingServerDescription - New server description.\n */\nfunction updateServers(topology: Topology, incomingServerDescription?: ServerDescription) {\n  // update the internal server's description\n  if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {\n    const server = topology.s.servers.get(incomingServerDescription.address);\n    if (server) {\n      server.s.description = incomingServerDescription;\n      if (\n        incomingServerDescription.error instanceof MongoError &&\n        incomingServerDescription.error.hasErrorLabel(MongoErrorLabel.ResetPool)\n      ) {\n        const interruptInUseConnections = incomingServerDescription.error.hasErrorLabel(\n          MongoErrorLabel.InterruptInUseConnections\n        );\n\n        server.pool.clear({ interruptInUseConnections });\n      } else if (incomingServerDescription.error == null) {\n        const newTopologyType = topology.s.description.type;\n        const shouldMarkPoolReady =\n          incomingServerDescription.isDataBearing ||\n          (incomingServerDescription.type !== ServerType.Unknown &&\n            newTopologyType === TopologyType.Single);\n        if (shouldMarkPoolReady) {\n          server.pool.ready();\n        }\n      }\n    }\n  }\n\n  // add new servers for all descriptions we currently don't know about locally\n  for (const serverDescription of topology.description.servers.values()) {\n    if (!topology.s.servers.has(serverDescription.address)) {\n      const server = createAndConnectServer(topology, serverDescription);\n      topology.s.servers.set(serverDescription.address, server);\n    }\n  }\n\n  // for all servers no longer known, remove their descriptions and destroy their instances\n  for (const entry of topology.s.servers) {\n    const serverAddress = entry[0];\n    if (topology.description.hasServer(serverAddress)) {\n      continue;\n    }\n\n    if (!topology.s.servers.has(serverAddress)) {\n      continue;\n    }\n\n    const server = topology.s.servers.get(serverAddress);\n    topology.s.servers.delete(serverAddress);\n\n    // prepare server for garbage collection\n    if (server) {\n      destroyServer(server, topology);\n    }\n  }\n}\n\nfunction drainWaitQueue(queue: List<ServerSelectionRequest>, err?: MongoDriverError) {\n  while (queue.length) {\n    const waitQueueMember = queue.shift();\n    if (!waitQueueMember) {\n      continue;\n    }\n\n    if (waitQueueMember.timer) {\n      clearTimeout(waitQueueMember.timer);\n    }\n\n    if (!waitQueueMember[kCancelled]) {\n      waitQueueMember.callback(err);\n    }\n  }\n}\n\nfunction processWaitQueue(topology: Topology) {\n  if (topology.s.state === STATE_CLOSED) {\n    drainWaitQueue(topology[kWaitQueue], new MongoTopologyClosedError());\n    return;\n  }\n\n  const isSharded = topology.description.type === TopologyType.Sharded;\n  const serverDescriptions = Array.from(topology.description.servers.values());\n  const membersToProcess = topology[kWaitQueue].length;\n  for (let i = 0; i < membersToProcess; ++i) {\n    const waitQueueMember = topology[kWaitQueue].shift();\n    if (!waitQueueMember) {\n      continue;\n    }\n\n    if (waitQueueMember[kCancelled]) {\n      continue;\n    }\n\n    let selectedDescriptions;\n    try {\n      const serverSelector = waitQueueMember.serverSelector;\n      selectedDescriptions = serverSelector\n        ? serverSelector(topology.description, serverDescriptions)\n        : serverDescriptions;\n    } catch (e) {\n      if (waitQueueMember.timer) {\n        clearTimeout(waitQueueMember.timer);\n      }\n\n      waitQueueMember.callback(e);\n      continue;\n    }\n\n    let selectedServer;\n    if (selectedDescriptions.length === 0) {\n      topology[kWaitQueue].push(waitQueueMember);\n      continue;\n    } else if (selectedDescriptions.length === 1) {\n      selectedServer = topology.s.servers.get(selectedDescriptions[0].address);\n    } else {\n      const descriptions = shuffle(selectedDescriptions, 2);\n      const server1 = topology.s.servers.get(descriptions[0].address);\n      const server2 = topology.s.servers.get(descriptions[1].address);\n\n      selectedServer =\n        server1 && server2 && server1.s.operationCount < server2.s.operationCount\n          ? server1\n          : server2;\n    }\n\n    if (!selectedServer) {\n      waitQueueMember.callback(\n        new MongoServerSelectionError(\n          'server selection returned a server description but the server was not found in the topology',\n          topology.description\n        )\n      );\n      return;\n    }\n    const transaction = waitQueueMember.transaction;\n    if (isSharded && transaction && transaction.isActive && selectedServer) {\n      transaction.pinServer(selectedServer);\n    }\n\n    if (waitQueueMember.timer) {\n      clearTimeout(waitQueueMember.timer);\n    }\n\n    waitQueueMember.callback(undefined, selectedServer);\n  }\n\n  if (topology[kWaitQueue].length > 0) {\n    // ensure all server monitors attempt monitoring soon\n    for (const [, server] of topology.s.servers) {\n      process.nextTick(function scheduleServerCheck() {\n        return server.requestCheck();\n      });\n    }\n  }\n}\n\nfunction isStaleServerDescription(\n  topologyDescription: TopologyDescription,\n  incomingServerDescription: ServerDescription\n) {\n  const currentServerDescription = topologyDescription.servers.get(\n    incomingServerDescription.address\n  );\n  const currentTopologyVersion = currentServerDescription?.topologyVersion;\n  return (\n    compareTopologyVersion(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0\n  );\n}\n\n/** @public */\nexport class ServerCapabilities {\n  maxWireVersion: number;\n  minWireVersion: number;\n\n  constructor(hello: Document) {\n    this.minWireVersion = hello.minWireVersion || 0;\n    this.maxWireVersion = hello.maxWireVersion || 0;\n  }\n\n  get hasAggregationCursor(): boolean {\n    return this.maxWireVersion >= 1;\n  }\n\n  get hasWriteCommands(): boolean {\n    return this.maxWireVersion >= 2;\n  }\n  get hasTextSearch(): boolean {\n    return this.minWireVersion >= 0;\n  }\n\n  get hasAuthCommands(): boolean {\n    return this.maxWireVersion >= 1;\n  }\n\n  get hasListCollectionsCommand(): boolean {\n    return this.maxWireVersion >= 3;\n  }\n\n  get hasListIndexesCommand(): boolean {\n    return this.maxWireVersion >= 3;\n  }\n\n  get supportsSnapshotReads(): boolean {\n    return this.maxWireVersion >= 13;\n  }\n\n  get commandsTakeWriteConcern(): boolean {\n    return this.maxWireVersion >= 5;\n  }\n\n  get commandsTakeCollation(): boolean {\n    return this.maxWireVersion >= 5;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}